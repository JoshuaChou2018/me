<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>leetcode - Tag - Juexiao Zhou</title>
        <link>https://www.joshuachou.ink/tags/leetcode/</link>
        <description>leetcode - Tag - Juexiao Zhou</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 08 Feb 2022 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://www.joshuachou.ink/tags/leetcode/" rel="self" type="application/rss+xml" /><item>
    <title>lc297. Serialize and Deserialize Binary Tree</title>
    <link>https://www.joshuachou.ink/lc297.-serialize-and-deserialize-binary-tree/</link>
    <pubDate>Tue, 08 Feb 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc297.-serialize-and-deserialize-binary-tree/</guid>
    <description><![CDATA[Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.]]></description>
</item><item>
    <title>lc314. Binary Tree Vertical Order Traversal</title>
    <link>https://www.joshuachou.ink/lc314.binary-tree-vertical-order-traversal/</link>
    <pubDate>Tue, 08 Feb 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc314.binary-tree-vertical-order-traversal/</guid>
    <description><![CDATA[Given the root of a binary tree, return the vertical order traversal of its nodes' values. (i.e., from top to bottom, column by column).
If two nodes are in the same row and column, the order should be from left to right.
Example 1:
1 2  Input: root = [3,9,20,null,null,15,7] Output: [[9],[3,15],[20],[7]]   Example 2:
1 2  Input: root = [3,9,8,4,0,1,7] Output: [[4],[9],[3,0,1],[8],[7]]   Example 3:]]></description>
</item><item>
    <title>lc253. 会议室 II</title>
    <link>https://www.joshuachou.ink/lc253.%E4%BC%9A%E8%AE%AE%E5%AE%A4ii/</link>
    <pubDate>Thu, 03 Feb 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc253.%E4%BC%9A%E8%AE%AE%E5%AE%A4ii/</guid>
    <description><![CDATA[给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，返回 所需会议室的最小数量 。
示例 1：
输入：intervals = [[0,30],[5,10],[15,20]] 输出：2
示例 2：
输入：intervals = [[7,10],[2,4]] 输出：1
提示：
1 &lt;= intervals.length &lt;= 104 0 &lt;= starti &lt; endi &lt;= 106
解题思路 我们可以想象把这些interval给叠起来，所需要会议室的最小数量就等于最大重叠的interval的数目。
转化为上下车问题，每个interval的开始时间+1，每个interval的结束时间-1，然后我们统计counter的最大数值。
换个思路就是我们以时间为单位，我们可以知道每个单位时间车上的总人数是增加多少还是减少多少，这样我们可以直接求和从开始扫描到结束，获取当前车上最大的人数就可以。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution(object): def minMeetingRooms(self, intervals): &#34;&#34;&#34; :type intervals: List[List[int]] :rtype: int &#34;&#34;&#34; dic={} for interval in intervals: try: dic[interval[0]]+=1 except: dic[interval[0]]=1 try: dic[interval[1]]-=1 except: dic[interval[1]]=-1 max_=0 count=0 for key in sorted(dic.]]></description>
</item><item>
    <title>lc938. Range Sum of BST</title>
    <link>https://www.joshuachou.ink/lc938.range_sum_of_bst/</link>
    <pubDate>Thu, 03 Feb 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc938.range_sum_of_bst/</guid>
    <description><![CDATA[Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].
Example 1:
1 2 3  Input: root = [10,5,15,3,7,null,18], low = 7, high = 15 Output: 32 Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.   Example 2:]]></description>
</item><item>
    <title>lc10. Regular Expression Matching</title>
    <link>https://www.joshuachou.ink/lc10.regular_expression_matching/</link>
    <pubDate>Thu, 27 Jan 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc10.regular_expression_matching/</guid>
    <description><![CDATA[Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:
 '.' Matches any single character. '*' Matches zero or more of the preceding element.  The matching should cover the entire input string (not partial).
Example 1:
1 2 3  Input: s = &#34;aa&#34;, p = &#34;a&#34; Output: false Explanation: &#34;a&#34; does not match the entire string &#34;aa&#34;.   Example 2:]]></description>
</item><item>
    <title>lc31. Next Permutation</title>
    <link>https://www.joshuachou.ink/lc31.next_permutation/</link>
    <pubDate>Thu, 27 Jan 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc31.next_permutation/</guid>
    <description><![CDATA[A permutation of an array of integers is an arrangement of its members into a sequence or linear order.
 For example, for arr = [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1].  The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container.]]></description>
</item><item>
    <title>lc56. Merge Intervals</title>
    <link>https://www.joshuachou.ink/lc56.merge_intervals/</link>
    <pubDate>Thu, 27 Jan 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc56.merge_intervals/</guid>
    <description><![CDATA[Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
Example 1:
1 2 3  Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].   Example 2:
1 2 3  Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping.]]></description>
</item><item>
    <title>lc125. Valid Palindrome</title>
    <link>https://www.joshuachou.ink/lc125.valid_palindrome/</link>
    <pubDate>Wed, 26 Jan 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc125.valid_palindrome/</guid>
    <description><![CDATA[A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
Given a string s, return true if it is a palindrome, or false otherwise.
Example 1:
1 2 3  Input: s = &#34;A man, a plan, a canal: Panama&#34; Output: true Explanation: &#34;amanaplanacanalpanama&#34; is a palindrome.   Example 2:]]></description>
</item><item>
    <title>lc238. Product of Array Except Self</title>
    <link>https://www.joshuachou.ink/lc238._product_of_array_except_self/</link>
    <pubDate>Wed, 26 Jan 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc238._product_of_array_except_self/</guid>
    <description><![CDATA[Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].
The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
You must write an algorithm that runs in O(n) time and without using the division operation.
Example 1:
1 2  Input: nums = [1,2,3,4] Output: [24,12,8,6]   Example 2:]]></description>
</item><item>
    <title>lc415. Add Strings</title>
    <link>https://www.joshuachou.ink/lc415.add_strings/</link>
    <pubDate>Wed, 26 Jan 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc415.add_strings/</guid>
    <description><![CDATA[Given two non-negative integers, num1 and num2 represented as string, return the sum of num1and num2 as a string.
You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.
Example 1:
1 2  Input: num1 = &#34;11&#34;, num2 = &#34;123&#34; Output: &#34;134&#34;   Example 2:
1 2  Input: num1 = &#34;456&#34;, num2 = &#34;77&#34; Output: &#34;533&#34;   Example 3:]]></description>
</item></channel>
</rss>
