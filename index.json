[{"categories":["leetcode"],"content":"Convert a non-negative integer num to its English words representation. Example 1: Input: num = 123 Output: \"One Hundred Twenty Three\" Example 2: Input: num = 12345 Output: \"Twelve Thousand Three Hundred Forty Five\" Example 3: Input: num = 1234567 Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\" Constraints: 0 \u003c= num \u003c= 2^31 - 1 解题思路： 根据数字长度分成不同的翻译位: 亿，百万，千，百，Billion, Million, Thousand, Hundred 90-20的整10读法: Ninety, Eighty, Seventy, Sixty, Fifty, Fourty, Thirty, Twenty 19-11的读法：Nienteen, Eighteen, Seventeen, Sixteen, Fifteen, Fourteen, Thirteen, Twelve, Eleven 10-0的读法：Ten, Nine, Eight, Seven, Six, Five, Four, Three, Two, One, Zero 难点：把数字根据位数拆开。 **两种解法：**递归和迭代。 递归解法： class Solution(object): def numberToWords(self, num): \"\"\" :type num: int :rtype: str \"\"\" from0to19=['','One','Two','Three','Four','Five','Six','Seven','Eight','Nine','Ten','Eleven','Twelve','Thirteen','Fourteen','Fifteen','Sixteen','Seventeen','Eighteen','Nineteen'] from20to90=['','','Twenty','Thirty','Forty','Fifty','Sixty','Seventy','Eighty','Ninety'] def recursive(num): if num\u003e=1000000000: # larger than 1 billion ans='{}Billion'.format(from0to19[num//1000000000])+recursive(num%1000000000) return ans elif num\u003e=1000000: ans='{}Million'.format(recursive(num//1000000))+recursive(num%1000000) return ans elif num\u003e=1000: ans='{}Thousand'.format(recursive(num//1000))+recursive(num%1000) return ans elif num\u003e=100: ans='{}Hundred'.format(from0to19[num//100])+recursive(num%100) return ans elif num\u003e=20: ans='{}'.format(from20to90[num//10])+recursive(num%10) return ans else: return '{}'.format(from0to19[num]) def addBlank(s): _s='' for _ in s: if _.isupper(): _s+=' {}'.format(_) else: _s+=_ return _s if num==0: return 'Zero' else: ans=recursive(num) return addBlank(ans)[1:] Runtime: 24 ms, faster than 54.38% of Python online submissions for Integer to English Words. Memory Usage: 13.6 MB, less than 13.33% of Python online submissions for Integer to English Words. 踩坑： 空格问题 数字区间分割 Billion位忘记转英文 英文拼写错误，eg: forteen ","date":"2022-01-17","objectID":"/lc273.integer_to_english_words/:0:0","tags":["leetcode"],"title":"lc273. Integer to English Words","uri":"/lc273.integer_to_english_words/"},{"categories":["leetcode"],"content":"Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid. Return all the possible results. You may return the answer in any order. Example 1: Input: s = \"()())()\" Output: [\"(())()\",\"()()()\"] Example 2: Input: s = \"(a)())()\" Output: [\"(a())()\",\"(a)()()\"] Example 3: Input: s = \")(\" Output: [\"\"] Constraints: 1 \u003c= s.length \u003c= 25 s consists of lowercase English letters and parentheses '(' and ')'. There will be at most 20 parentheses in s. 难点：本题和1249. 移除无效的括号非常相似，但是这里最难的点是如何找到所有的可能解。 解题思路： 由于我们需要找到的是最小Removal，同时需要找到在当前最小Removal下的所有解，我们可以采用BFS搜索方法。对于BFS的tree中每一层可以认为是在上一层的字符串中删除一个括号之后的所有可能字符串，然后我们对所有节点判断是否为有效括号。使用BFS，有2个好处： 如果父节点已经是合法字符串，则无需再考虑任何子节点。 如果有一个节点已经是合法字符串，则其它所有结果都只可能出现在和这个节点同一层（为了确保minimal removal）。 ","date":"2022-01-17","objectID":"/lc301.remove_invalid_parentheses/:0:0","tags":["leetcode"],"title":"lc301. Remove Invalid Parentheses","uri":"/lc301.remove_invalid_parentheses/"},{"categories":["leetcode"],"content":"Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2). You may return the answer in any order. The answer is guaranteed to be unique(except for the order that it is in). Example 1: Input: points = [[1,3],[-2,2]], k = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10). The distance between (-2, 2) and the origin is sqrt(8). Since sqrt(8) \u003c sqrt(10), (-2, 2) is closer to the origin. We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]]. Example 2: Input: points = [[3,3],[5,-1],[-2,4]], k = 2 Output: [[3,3],[-2,4]] Explanation: The answer [[-2,4],[3,3]] would also be accepted. Constraints: 1 \u003c= k \u003c= points.length \u003c= 104 -104 \u003c xi, yi \u003c 104 解题思路： 最直接的解法就是把每个点的距离计算出来之后，然后根据大小排序取前k。 难点：如何在排序算法中采用最快的方式。 可以考虑使用快速排序方法： class Solution(object): def kClosest(self, points, k): \"\"\" :type points: List[List[int]] :type k: int :rtype: List[List[int]] \"\"\" def calDist(points): return [(x,x[0]*x[0]+x[1]*x[1]) for x in points] def quickSort(lists,i,j): if i \u003e= j: return list pivot = lists[i] low = i high = j while i \u003c j: while i \u003c j and lists[j][1] \u003e= pivot[1]: j -= 1 lists[i]=lists[j] while i \u003c j and lists[i][1] \u003c=pivot[1]: i += 1 lists[j]=lists[i] lists[j] = pivot quickSort(lists,low,i-1) quickSort(lists,i+1,high) return lists _points=calDist(points) _points=quickSort(_points,0,len(_points)-1) return [_points[idx][0] for idx in range(k)] 但是快速排序性能不稳定，性能取决于pivot的选择。因为这个题有限制条件为topK，所以我们可以进一步考虑使用堆排序，通过维护一个大小为K的堆来遍历数据。 这里为了简化代码，我们调用python自带的heapq模块。由于heapq模块默认的保留K最大，所以为了获得k距离最近的点，我们需要把距离取负值。 import heapq class Solution(object): def kClosest(self, points, k): \"\"\" :type points: List[List[int]] :type k: int :rtype: List[List[int]] \"\"\" def dist(point): return (-(point[0]**2+point[1]**2),point) h=[] for point in points: if len(h)\u003ck: heapq.heappush(h,dist(point)) else: _new=dist(point) if h[0][0]\u003c_new[0]: heapq.heappop(h) heapq.heappush(h,_new) return [x[1] for x in h] 执行用时：148 ms, 在所有 Python 提交中击败了37.37%的用户 内存消耗：18.1 MB, 在所有 Python 提交中击败了53.54%的用户 使用堆在性能上显著优于使用快排。 ","date":"2022-01-16","objectID":"/lc973.k_closest_points_to_origin/:0:0","tags":["leetcode"],"title":"lc973. K Closest Points to Origin","uri":"/lc973.k_closest_points_to_origin/"},{"categories":["leetcode"],"content":"Given a string s, return true if the s can be palindrome after deleting at most one character from it. Example 1: Input: s = \"aba\" Output: true Example 2: Input: s = \"abca\" Output: true Explanation: You could delete the character 'c'. Example 3: Input: s = \"abc\" Output: false Constraints: 1 \u003c= s.length \u003c= 105 s consists of lowercase English letters. 解题思路： 如果最多删除一个字母可以使字符串满足回文序列即返回true。 我们可以从字符串两端开始依次比较，如果遇到不同，我们有一次机会删除其中一个字母继续比较，一个简单的while循环就可以完成任务。 代码： class Solution(object): def validPalindrome(self, s): \"\"\" :type s: str :rtype: bool \"\"\" def isPalindrome(_s): _left=0 _right=len(_s)-1 while _left\u003c_right: if _s[_left]!=_s[_right]: return False else: _left+=1 _right-=1 return True delcount=0 left=0 right=len(s)-1 while left\u003cright: if s[left]==s[right]: left+=1 right-=1 else: if delcount==0: delcount+=1 if isPalindrome(s[left+1:right+1])==True: left+=1 elif isPalindrome(s[left:right])==True: right-=1 else: return False else: return False return True 性能： 执行用时：140 ms, 在所有 Python 提交中击败了17.65%的用户 内存消耗：13.6 MB, 在所有 Python 提交中击败了47.06%的用户 ","date":"2022-01-13","objectID":"/lc680.valid_palindrome_ii/:0:0","tags":["leetcode"],"title":"lc680. Valid Palindrome II","uri":"/lc680.valid_palindrome_ii/"},{"categories":["leetcode"],"content":"In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language. Example 1: Input: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\" Output: true Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted. Example 2: Input: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\" Output: false Explanation: As 'd' comes after 'l' in this language, then words[0] \u003e words[1], hence the sequence is unsorted. Example 3: Input: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\" Output: false Explanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" \u003e \"app\", because 'l' \u003e '∅', where '∅' is defined as the blank character which is less than any other character (More info). Constraints: 1 \u003c= words.length \u003c= 100 1 \u003c= words[i].length \u003c= 20 order.length == 26 All characters in words[i] and order are English lowercase letters. 解题思路： 对于每一个单词的每一个字母我们都可以用其在字典中的位置来编码，比如说： hello=[0,6,1,1,14]，对于字典order = “hlabcdefgijkmnopqrstuvwxyz” 给定一组词汇如：words = [“hello”,“leetcode”] 我们可以把其中的单词全部翻译成index，然后依次比较。 代码： class Solution(object): def isAlienSorted(self, words, order): \"\"\" :type words: List[str] :type order: str :rtype: bool \"\"\" def word2idx(word,order): out=[] for _ in word: out.append(order.index(_)) return out A_idx=None # to record the left one B_idx=None # to record the right one for i in range(len(words)-1): A_idx=word2idx(words[i],order) B_idx=word2idx(words[i+1],order) flag=True while len(A_idx)!=0 and len(B_idx)!=0 and flag==True: A=A_idx[0] A_idx=A_idx[1:] B=B_idx[0] B_idx=B_idx[1:] if A\u003cB: flag=False elif A\u003eB: return False elif A==B: pass if flag==True: if len(A_idx)!=0: return False else: pass return True 性能： 执行用时：20 ms, 在所有 Python 提交中击败了69.01%的用户 内存消耗：13 MB, 在所有 Python 提交中击败了87.32%的用户 优化： 原始代码中定义了一些不必要的操作步骤，导致拉满速度和时间，以下代码采用了一样的思路，但运行速度更快： class Solution: def isAlienSorted(self, words: List[str], order: str) -\u003e bool: di = dict() # storing the alphabet order of language via hashmap for i in range(len(order)): di[order[i]] = i+1 # helper function comparing two words def compareWords(w1, w2): i = 0 # looping depends on smaller word while i\u003cmin(len(w1), len(w2)): # getting order/rank of words rank1, rank2 = di.get(w1[i]), di.get(w2[i]) # correct order if w2's rank is greater if rank1 \u003c rank2: return True # continue if letters are same elif rank1 == rank2: i += 1 continue # incorrect order if w1's rank is greater else: return False # w1 should be smaller if all letters are equal if len(w1)\u003elen(w2): return False else: return True for i in range(len(words)-1): w1, w2 = words[i], words[i+1] # comparing with the immediate next word if not compareWords(w1, w2): return False return True ","date":"2022-01-12","objectID":"/lc953.verifying_an_alien_dictionary/:0:0","tags":["leetcode"],"title":"lc953. Verifying an Alien Dictionary","uri":"/lc953.verifying_an_alien_dictionary/"},{"categories":["leetcode"],"content":"Given a string s of '(' , ')' and lowercase English characters. Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string. Formally, a parentheses string is valid if and only if: It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. Example 1: Input: s = \"lee(t(c)o)de)\" Output: \"lee(t(c)o)de\" Explanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted. Example 2: Input: s = \"a)b(c)d\" Output: \"ab(c)d\" Example 3: Input: s = \"))((\" Output: \"\" Explanation: An empty string is also valid. Constraints: 1 \u003c= s.length \u003c= 105 s[i] is either'(' , ')', or lowercase English letter. 解题思路： 有效字符串的意味着其中的左括号和右括号一对一匹配的（paired），最终序列中没有多余的括号，所以使用栈或者计数器来统计括号出现是比较好的解法。 题中的Minimum remove非常的让人困惑怀疑题目是否存在某些边界条件，比如说字符串存在多种remove方式都可以获得有效字符串（不考虑同时remove paired括号），其中有一种需要移除的括号数目是最少的。仔细思考后会发现这种情况是不存在的，字符串可能存在多种移除方式，但是这些移除方式所移除的数目都是相同的。 class Solution: def minRemoveToMakeValid(self, s): left, right, output = 0, s.count(')'),'' for _chr in s: if _chr=='(': if right\u003e0: # 有效左括号 left+=1 right-=1 output+=_chr elif _chr==')': if left==0: # 无效右括号 right-=1 else: left-=1 output+=_chr else: # 非括号字符 output+=_chr return output 性能： 执行用时：1456 ms, 在所有 Python 提交中击败了29.47%的用户 内存消耗：14.8 MB, 在所有 Python 提交中击败了94.74%的用户 ","date":"2022-01-11","objectID":"/lc1249.minimum_remove_to_make_valid_parentheses/:0:0","tags":["linux","leetcode"],"title":"lc1249. Minimum Remove to Make Valid Parentheses","uri":"/lc1249.minimum_remove_to_make_valid_parentheses/"},{"categories":["leetcode"],"content":"Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class: MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. Example 1: Input [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 Constraints: -231 \u003c= val \u003c= 231 - 1 Methods pop, top and getMinoperations will always be called on non-empty stacks. At most 3 * 104 calls will be made to push, pop, top, and getMin. 解题思路 Stack进行push和pop操作都非常简单，困难的是如何操作getMin。 getMin即拿到stack中所有未出栈数据中的最小值，因此我们在push和pop时可以给每个数据附加上一个属性，即当前的最小值。 each element is (x,x), the first value if the real value and the second value if the current min value 有几个注意点： 考虑边界条件，比如说stack中的最后一个数据被pop 每次pop之后需要把当前最小值变为top数据的最小值。 class MinStack(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.data=[] self.current_min=None # each element is (x,x), the first value if the real value and the second value if the current min value def push(self, x): \"\"\" :type x: int :rtype: None \"\"\" if self.current_min==None: self.current_min=x self.data.append((x,self.current_min)) elif x\u003e=self.current_min: self.data.append((x,self.current_min)) elif x\u003cself.current_min: self.current_min=x self.data.append((x,self.current_min)) return None def pop(self): \"\"\" :rtype: None \"\"\" self.data.pop(-1) if len(self.data)==0: self.current_min=None else: self.current_min=self.data[-1][1] return None def top(self): \"\"\" :rtype: int \"\"\" return self.data[-1][0] def min(self): \"\"\" :rtype: int \"\"\" return self.data[-1][1] # Your MinStack object will be instantiated and called as such: # obj = MinStack() # obj.push(x) # obj.pop() # param_3 = obj.top() # param_4 = obj.min() 性能： 执行用时：108 ms, 在所有 Python 提交中击败了85.47%的用户 内存消耗：17 MB, 在所有 Python 提交中击败了5.14%的用户 其它可能解法： 辅助栈 取巧的方法可以直接使用min函数 ","date":"2022-01-08","objectID":"/lc155.min_stack/:0:0","tags":["linux","leetcode"],"title":"lc155.Min Stack","uri":"/lc155.min_stack/"},{"categories":["leetcode"],"content":"用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 输入： [\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2： 输入： [\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示： 1 \u003c= values \u003c= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 输入为两个栈， 第一个栈对应的是操作： [“CQueue”,“appendTail”,“deleteHead”,“deleteHead”] CQueue表示init一个CQueue object appendTail表示调用appendTail函数 deleteHead表示调用deleteHead函数 第二个栈对应的是操作的值。 栈（Stack）的特点是先入后出，但是我们需要实现直接操作Head的功能。因此使用两个Stack可以实现列表倒序。 class CQueue: def __init__(self): self.A, self.B = [], [] def appendTail(self, value: int) -\u003e None: self.A.append(value) def deleteHead(self) -\u003e int: if self.B: return self.B.pop() if not self.A: return -1 while self.A: self.B.append(self.A.pop()) return self.B.pop() 时间复杂度： appendTail()为O(1), deleteHead()为O(N) 空间复杂度：O(N) ","date":"2022-01-08","objectID":"/jz09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/:0:0","tags":["linux","leetcode"],"title":"剑指 Offer 09. 用两个栈实现队列","uri":"/jz09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"categories":["Papers"],"content":"Title: A geometric deep learning approach to predict binding conformations of bioactive molecules DOI: https://doi.org/10.1038/s42256-021-00409-9 INFO: NATURE MACHINE INTELLIGENCE | VOL 3 | DECEMBER 2021 发表周期: Received: 18 May 2021; Accepted: 28 September 2021; Published online: 2 December 2021 药物设计是近年来AI应用的极火领域之一，其中一个最有挑战的问题就是空间结构设计。 One of the difficulties arises from the fact that only a small portion of the large chemical space will bind to a specific biological target and result in a therapeutic effect. 这篇文章中作者应用深度学习模型DeepDock捕获protein-ligand complex中的原子级微环境特征学习其中的结合构象。 数据集制备 The model reported in this study was trained using the general set of the PDBbind database (v.2019)30, which contains a collection of 17,679 protein–ligand structures with their respective potency (half-maximum inhibitory concentration, dissociation constant and so on). From these, we removed those complexes that are included in the CASF-2016 benchmark and those that failed during the preprocessing step, leaving a total of 16,367 protein–ligand complexes, which were randomly divided in a training set containing 15,000 complexes and a test set with 1,367. PDBbind数据库（http://www.pdbbind.org.cn）是基于PDB数据库，整合了大量实验统计所得的蛋白亲和力数据。 The PDBbind database is a comprehensive collection of experimentally measured binding affinity data (Kd, Ki, and IC50) for the protein-ligand complexes deposited in the Protein Data Bank (PDB).[1][2] It thus provides a link between energetic and structural information of protein-ligand complexes, which is of great value to various studies on molecular recognition occurred in biological systems. 作者使用图结构表示蛋白空间结构，node表示原子，edge表示bond。 Every node is represented by a one-hot vector that indicates the atom type among 28 possibilities (Be, B, C, N, O, F, Mg, Si, P, S, Cl, V, Fe, Co, Cu, Zn, As, Se, Br, Ru, Rh, Sb, I, Re, Os, Ir, Pt and Hg). 目标蛋白表面使用MSMS建模。 As in MaSIF, protein surfaces were triangulated using MSMS37 with a density of 3.0 nodes per Å^2 and a probe radius of 1.5 Å. The resulting meshes were downsampled to a resolution of 1 Å and processed using PyMesh. 只有具备结合位点性质的node才用于模型训练。 网络训练 如Fig1c，平行的图卷积网络被用来分别提取ligand和target结构中的表征以及特征编码。 Our approach directly uses the molecular surface of the binding site in the form of a polygon mesh. Both the target mesh and the ligand graph are processed by independent residual GNNs. Through this procedure, the processed node fea- tures not only contain information of an individual atom or point in the molecular surface, but also have information about the other nodes around them. In other words, the processed atom features encode all the atomic environment around a specific atom, whereas the target features encode a patch of the molecular surface around a specific point. GNN从ligand和target中分别提取出来的特征在特征向量上简单拼接后被送入mixture density network (MDN)。 by using this probability density function we can estimate the likelihood of finding ligand node i separated from a target node j by any distance $d_{ij}$. 模型评估 作者通过在CASF-2016 benchmark预测 Docking power Forward screening power Reverse screening power 来评估模型性能。 Docking power The evaluation of docking power measures the ability of a scor- ing function to identify native ligand binding poses among a set of decoys. Screening power The evaluation of screening power in CASF-2016 is designed to measure the ability of a scoring function to identify true binders of a specific target from a pool of random compounds. 模型细节 模型可分为3部分： 特征提取 特征融合 MDN First, the node and edge features are projected to a 128D embedding using a linear layer. We then use a sequence of three GNNs to update each node and edge based on their neighbouring nodes and the type of edges connecting them. After the initial processing by the GNNs, the node and edge features were processed by 10 residual GNN blocks. The MDN uses an MLP to create a hidden representation $h_{r,s}$ that combines the concatenated target and ligand node information. All MLPs used are composed of a linear layer followed by batch n","date":"2022-01-02","objectID":"/nmi-a-geometric-deep-learning-approach-to-predict-binding-conformations-of-bioactive-molecules/:0:0","tags":["NMI","Machine learning","proteins"],"title":"[NMI] A geometric deep learning approach to predict binding conformations of bioactive molecules 解读","uri":"/nmi-a-geometric-deep-learning-approach-to-predict-binding-conformations-of-bioactive-molecules/"},{"categories":["database"],"content":"ER diagram Notation: Chen Notation Crow’s Foot Notation UML Class Diagram Notation ","date":"2022-01-02","objectID":"/er_diagram_notation/:0:0","tags":["SQL","database"],"title":"ER Diagram Notation","uri":"/er_diagram_notation/"},{"categories":["system"],"content":"Example MD ","date":"2022-01-01","objectID":"/example/:0:0","tags":["linux"],"title":"Example","uri":"/example/"},{"categories":["system"],"content":"Problem Description Fors some unknow reason, the user is unable to click the text boxes or type anything into the publish window after running the Build \u0026 Publish. When the user clicks the main window in Unity, the cursor disappears and the user can not select the text boxes or anything else. This problem happens under my settings, macOS Catalina 10.15.7, Unity 2019.4.31f1, VRChat SDK3. Solution The reason of this problem is that when you click the temp scene created by the SDK3, the cursor will be invisible and locked. Find this file: VRCSDK/Dependencies/VRChat/ Scripts/RuntimeWorldCreation.cs Find this content, marked function Start(). new void Start() { if (!Application.isEditor || !Application.isPlaying) return; base.Start(); IsCurrentWorldInCommunityLabs = false; IsCurrentWorldUploaded = false; IsCurrentWorldPubliclyPublished = false; var desc = pipelineManager.GetComponent\u003cVRC.SDKBase.VRC_SceneDescriptor\u003e(); desc.PositionPortraitCamera(imageCapture.shotCamera.transform); Application.runInBackground = true; UnityEngine.XR.XRSettings.enabled = false; uploadButton.onClick.AddListener(SetupUpload); openCommunityLabsDocsButton.onClick.AddListener(OpenCommunityLabsDocumentation); shouldUpdateImageToggle.onValueChanged.AddListener(ToggleUpdateImage); releasePublic.gameObject.SetActive(false); System.Action\u003cstring\u003e onError = (err) =\u003e { VRC.Core.Logger.LogError(\"Could not authenticate - \" + err, DebugLevel.Always); blueprintPanel.SetActive(false); errorPanel.SetActive(true); }; Add 2 lines. Cursor.visible=true; Cursor.lockState=0; Now the final content will be new void Start() { Cursor.visible=true; Cursor.lockState=0; if (!Application.isEditor || !Application.isPlaying) return; base.Start(); IsCurrentWorldInCommunityLabs = false; IsCurrentWorldUploaded = false; IsCurrentWorldPubliclyPublished = false; var desc = pipelineManager.GetComponent\u003cVRC.SDKBase.VRC_SceneDescriptor\u003e(); desc.PositionPortraitCamera(imageCapture.shotCamera.transform); Application.runInBackground = true; UnityEngine.XR.XRSettings.enabled = false; uploadButton.onClick.AddListener(SetupUpload); openCommunityLabsDocsButton.onClick.AddListener(OpenCommunityLabsDocumentation); shouldUpdateImageToggle.onValueChanged.AddListener(ToggleUpdateImage); releasePublic.gameObject.SetActive(false); System.Action\u003cstring\u003e onError = (err) =\u003e { VRC.Core.Logger.LogError(\"Could not authenticate - \" + err, DebugLevel.Always); blueprintPanel.SetActive(false); errorPanel.SetActive(true); }; if (!ApiCredentials.Load()) onError(\"Not logged in\"); else APIUser.InitialFetchCurrentUser( delegate (ApiModelContainer\u003cAPIUser\u003e c) { UserLoggedInCallback(c.Model as APIUser); }, delegate (ApiModelContainer\u003cAPIUser\u003e c) { onError(c.Error); } ); Now rebuild, you find you can edit the texts now. ","date":"2021-12-17","objectID":"/vrcsdk_can_not_edit_text/:0:0","tags":["linux"],"title":"Unable to interact with text boxes during Build \u0026 Publish for VRChat SDK3","uri":"/vrcsdk_can_not_edit_text/"},{"categories":["system"],"content":" Avticate your environment，check for package ipykernel python -m ipykernel –version If it’s not installed： python -m pip install ipykernel Add kernel to Jupyter notebook python -m ipykernel install –user –name ‘kernelname’ Check Jupyter notebook kernel jupyter kernelspec list Delet jupyter kernel jupyter kernelspec remove kernelname ","date":"2021-11-28","objectID":"/install-jupyter-kernel/:0:0","tags":["system","linux","conda","python"],"title":"Install kernel for jupyter notebook","uri":"/install-jupyter-kernel/"},{"categories":["leetcode"],"content":"Given a string s, find the length of the longest substring without repeating characters. Example 1: Input: s = \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: s = \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: s = \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring. Example 4: Input: s = \"\" Output: 0 Constraints: 0 \u003c= s.length \u003c= 5 * 104 s consists of English letters, digits, symbols and spaces. Thinking The simplest method to do is the brute force searching. Given a substring, we check whether it contains repeated characters. Then for all substrings of a given string, we do such a test and the total number of substrings of a given string with length $n$ is $n*(n+1)/2$. For example, For each substring str[i, j] i.e. starting from index i and ending at index j, we use a function areUnique(str, i, j) to check if all the characters in the substring are unique or not. It will return true if all the characters are unique, otherwise false. The time complexity of areUnque(str,i,j) is $O(j-i+1)$. So the overall time compelxity is $n*(n+1)/2*O(j-i+1)=O(n^2)*O(j-i+1)$. In the worst-case, $O(j-i+1)=O(n)$, so the worst-case overall time complexity is $O(n^3)$. We are using few extra variables and a constant size set visited[]. So space complexity = O(1). To optimize, here is an optimization insight: In the brute force idea, we repeatedly check a substring starting from the character str[i] to see if it has a duplicate character or not. We can optimize it further because, during the loop, if a substring str[i, j-1] is already checked to have no duplicate characters, then for the substring str[i, j], we only need to check if str[j] is already present in the substring str[i, j-1] or not. Partially cited from: https://www.enjoyalgorithms.com/blog/longest-substring-without-repeating-characters 暴力解法： class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" _max=0 for i in range(len(s)): sub=[s[i]] for j in range(i+1,len(s)): if s[j] not in sub: sub.append(s[j]) else: break if len(sub)\u003e_max: _max=len(sub) return _max 时间复杂度为O(N^2) 滑动窗口解法： class Solution: def lengthOfLongestSubstring(self, s): if not s:return 0 left = 0 lookup = set() n = len(s) max_len = 0 cur_len = 0 for i in range(n): cur_len += 1 while s[i] in lookup: lookup.remove(s[left]) left += 1 cur_len -= 1 if cur_len \u003e max_len:max_len = cur_len lookup.add(s[i]) return max_len 时间复杂度为O(N) ","date":"2021-11-18","objectID":"/lc3.longest_substring_without_repeating_characters/:0:0","tags":["coding"],"title":"lc3.Longest Substring Without Repeating Characters","uri":"/lc3.longest_substring_without_repeating_characters/"},{"categories":["interview"],"content":"Q. What are genetic algorithm and evolutionary algorithm? Genetic algorithm (GA) is a sub-class of evolutionary algorithm (EA). There are 3 implementation of EAs: GA, evolution strategies (ES), and evolutionary programming (EP). Among these, GAs have proved to be the most popular of the 3 EAs. These algorithms are similar in general, yet there are big differences among them: GA: They were developed by Holland and thoroughly reviewed by Goldberg; ES: They were developed by Rechenberg and Schwefe; and EP: It was developed by L.J. Fogel and D.B. Fogel. Similarity and Differences: All 3 operate on fixed length strings, which contain real values in ESs and EP and binary numbers in the canonical GA. All 3 incorporate a mutation operator: for ESs and EP mutation is the driving force. GAs and ESs also use a recombination operator, which is the primary operator for the GA. All 3 use a selection operator which applies evolutionary pressure, either instinctive (in ESs and EP, the operator determines which individuals will be excluded from the new population) or preservative (in the GA the operator selects individuals for breeding).. In GAs and EP selection is probabilistic, while ESs use a deterministic selection. ESs and meta-EP allow self-adaptation, where parameters controlling mutation are allowed to evolve along with object variables. Finally, it is worth noting that the implementer is free to modify these algorithms. For example, the GA can be run using an integer alphabet. From: https://www.researchgate.net/post/Are_Genetic_Algorithms_GA_and_Evolutionary_Algorithms_EA_the_same_or_different ","date":"2021-11-14","objectID":"/i4.gaea/:0:0","tags":["interview","machine learning"],"title":"i4.genetic algorithm and evolutionary algorithm","uri":"/i4.gaea/"},{"categories":["system"],"content":"Install sudo apt install slurm-wlm slurm-wlm-doc -y Modify config rm /etc/slurm-llnl/slurm.conf vi /etc/slurm-llnl/slurm.conf Example of config # slurm.conf file generated by configurator easy.html. # Put this file on all nodes of your cluster. # See the slurm.conf man page for more information. # ControlMachine=girl #ControlAddr= # #MailProg=/bin/mail MpiDefault=none #MpiParams=ports=#-# ProctrackType=proctrack/pgid ReturnToService=1 SlurmctldPidFile=/var/run/slurm-llnl/slurmctld.pid #SlurmctldPort=6817 SlurmdPidFile=/var/run/slurm-llnl/slurmd.pid #SlurmdPort=6818 SlurmdSpoolDir=/var/spool/slurmd SlurmUser=slurm #SlurmdUser=root StateSaveLocation=/var/spool/slurm-llnl SwitchType=switch/none TaskPlugin=task/none # # # TIMERS #KillWait=30 #MinJobAge=300 #SlurmctldTimeout=120 #SlurmdTimeout=300 # # # SCHEDULING FastSchedule=1 SchedulerType=sched/backfill SelectType=select/linear #SelectTypeParameters= # # # LOGGING AND ACCOUNTING AccountingStorageType=accounting_storage/none ClusterName=cluster #JobAcctGatherFrequency=30 JobAcctGatherType=jobacct_gather/none #SlurmctldDebug=3 #SlurmctldLogFile= #SlurmdDebug=3 #SlurmdLogFile= # # # COMPUTE NODES NodeName=girl CPUs=4 State=UNKNOWN PartitionName=debug Nodes=girl Default=YES MaxTime=INFINITE State=UP Mkdir and Chown rm -rf /var/spool/slurm-llnl mkdir /var/spool/slurm-llnl chown -R slurm.slurm /var/spool/slurm-llnl rm -rf /var/run/slurm-llnl/ mkdir /var/run/slurm-llnl/ chown -R slurm.slurm /var/run/slurm-llnl/ Start slurmd and enable on boot systemctl start slurmd systemctl enable slurmd systemctl start slurmctld systemctl enable slurmctld Start service systemctl restart slurmctld systemctl restart slurmd ","date":"2021-11-14","objectID":"/install-slurm/:0:0","tags":["system","linux"],"title":"Install Slurm in Ubuntu","uri":"/install-slurm/"},{"categories":["system"],"content":"问题在于VNCServer使用Python编写，所以受到系统Python版本影响。 解决方案： $ cd $HOME $ vim .bashrc 找到如下语句： export PATH=\"/home/user/anaconda2/bin:$PATH\" 并修改为，并保存退出。 export PATH=\"$PATH:/home/user/anaconda2/bin\" $ vncserver -kill :id $ source .bashrc $ conda config --set auto_activate_base false #取消conda自动启动base ","date":"2021-11-14","objectID":"/%E5%AE%89%E8%A3%85python%E5%AF%BC%E8%87%B4vnc%E7%95%8C%E9%9D%A2%E9%BB%91%E5%B1%8F/:0:0","tags":["system","linux"],"title":"安装Python导致VNC黑屏解决方案","uri":"/%E5%AE%89%E8%A3%85python%E5%AF%BC%E8%87%B4vnc%E7%95%8C%E9%9D%A2%E9%BB%91%E5%B1%8F/"},{"categories":["interview"],"content":"Q. What Are the Different Types of Machine Learning? Supervised learning A model makes predictions or decisions based on past or labeled data. Labeled data refers to sets of data that are given tags or labels, and thus made more meaningful. Unsupervised learning In this case, we don’t have labeled data, a model can identify patterns, anomalies, and relationships in the input data. Reinforcement learning The model learn based on the rewards received from the previous action. ","date":"2021-11-08","objectID":"/i3.different-types-of-machine-learning/:0:0","tags":["interview","machine learning"],"title":"i3.different types of machine learning","uri":"/i3.different-types-of-machine-learning/"},{"categories":["leetcode"],"content":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 1: Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. Example 2: Input: l1 = [0], l2 = [0] Output: [0] Example 3: Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1] Constraints: The number of nodes in each linked list is in the range [1, 100]. 0 \u003c= Node.val \u003c= 9 It is guaranteed that the list represents a number that does not have leading zeros. Thinking To understand the question, we need to specify: 2-\u003e4-\u003e3 stands for the number 342 5-\u003e6-\u003e4 stands for the number 465 So, the sum should be 807, which can be represented as 7-\u003e0-\u003e8 Then the process goes easily. Firstly we add 2 and 5, which is the first element of both lists, if the sum is smaller than 10, then we simply output the sum to the corresponding element in the output list. Let’s say 2+5-\u003e7. If sum is \u003e=10, we leave the mode to the corresponding position in the output list and add 1 to the follow position as we know the sum \u003c=19 (9+9+?1), here ?1 depends on whether there is a 1 from the previous position. Solution class Solution: def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -\u003e Optional[ListNode]: _add2next=0 initialNode=ListNode() currentNode=initialNode while True: try: _l1=l1.val except: _l1=0 try: _l2=l2.val except: _l2=0 _sum=_l1+_l2+_add2next currentNode.val=_sum%10 _add2next=_sum//10 try: l1=l1.next except: l1=None try: l2=l2.next except: l2=None if l1==l2==None and _add2next==0: break elif l1==l2==None and _add2next==1: currentNode.next=ListNode(val=1) break else: nextNode=ListNode() currentNode.next=nextNode currentNode=nextNode return initialNode Runtime: 68ms Memory: 14.4MB ","date":"2021-11-07","objectID":"/lc2.add2numbers/:0:0","tags":["coding"],"title":"lc2.Add Two Numbers","uri":"/lc2.add2numbers/"},{"categories":["system"],"content":"MacOS install uPic brew install uPic Set uPic Set uPic host to Github The default host is SMMS Set Typora uploading to uPic ","date":"2021-11-07","objectID":"/typora-upic-github-image-hosting-service/:0:0","tags":["linux"],"title":"typora \u0026 uPic \u0026 Github image hosting service","uri":"/typora-upic-github-image-hosting-service/"},{"categories":["system"],"content":"Mofidy .inputrc sudo vi ~/.inputrc Add this line set completion-ignore-case on Restart your terminal Now you can ignore the upper and lower case when you use Tab in terminal ","date":"2021-11-05","objectID":"/how-to-ignore-upperlower-case-with-tab-in-ubuntu/:0:0","tags":["linux"],"title":"How to ignore upper and lower case when using Tab in Ubuntu","uri":"/how-to-ignore-upperlower-case-with-tab-in-ubuntu/"},{"categories":["system"],"content":"Mofidy bash.bashrc sudo vi /etc/bash.bashrc Find those code in the file #enable bash completion in interactive shells #if ! shopt -oq posix; then # if [-f /usr/share/bash-completion/bash_completion ]; then # . /usr/share/bash-completion/bash_completion # elif [ -f /etc/bash_completion]; then # . /etc/bash_completion # fi #fi Remove # Like below: #enable bash completion in interactive shells if ! shopt -oq posix; then if [-f /usr/share/bash-completion/bash_completion ]; then . /usr/share/bash-completion/bash_completion elif [ -f /etc/bash_completion]; then . /etc/bash_completion fi fi Source it sudo source /etc/bash.bashrc Now you can use Tab to autocomplete your command ","date":"2021-11-04","objectID":"/how-to-set-autocomplete-in-ubuntu/:0:0","tags":["linux"],"title":"How to set autocomplete in Ubuntu","uri":"/how-to-set-autocomplete-in-ubuntu/"},{"categories":["interview"],"content":"Q. How Many Times Do A Clock’s Hands Overlap In A Day? The most important is not the answer but the way to think and work out problems. In total 22, because the clock hands approximately overlap at 12:00, 1:05, 2:10, 3:15, 4:20, 5:25, 6:30, 7:35, 8:40, 9:45 and 10:50 twice a day. Although reaching the wrong answer is fine to an extent, you should avoid these common errors. Don’t just blurt out an answer without thinking it through. If you give the wrong answer, don’t get flustered. Don’t say, “I don’t know.” Don’t sit in silence. If you just sit in your chair quietly, then the interviewer is not going to know how you came to your answer. Talking the answer out gives the hiring manager valuable insight into how you are able to think. cite from: https://www.livecareer.com/resources/interviews/questions/how-many-times-do-a-clocks-hands-overlap-in-a-day ","date":"2021-11-04","objectID":"/i2.clock-hand-overlap/:0:0","tags":["interview","thinking"],"title":"i2.How Many Times Do A Clock’s Hands Overlap In A Day?","uri":"/i2.clock-hand-overlap/"},{"categories":["system"],"content":"Install You can find it at here: https://github.com/svenstaro/miniserve/releases Usage miniserve --help miniserve 0.4.1 Sven-Hendrik Haase \u003csvenstaro@gmail.com\u003e, Boastful Squirrel \u003cboastful.squirrel@gmail.com\u003e For when you really just want to serve some files over HTTP right now! USAGE: miniserve [FLAGS] [OPTIONS] [--] [PATH] FLAGS: -u, --upload-files Enable file uploading -h, --help Prints help information -P, --no-symlinks Do not follow symbolic links -o, --overwrite-files Enable overriding existing files during file upload --random-route Generate a random 6-hexdigit route -V, --version Prints version information -v, --verbose Be verbose, includes emitting access logs OPTIONS: -a, --auth \u003cauth\u003e Set authentication (username:password) -c, --color-scheme \u003ccolor_scheme\u003e Default color scheme [default: Squirrel] [possible values: Archlinux, Zenburn, Monokai, Squirrel] -i, --if \u003cinterfaces\u003e... Interface to listen on -p, --port \u003cport\u003e Port to use [default: 8080] ARGS: \u003cPATH\u003e Which path to serve Serve single folder miniserve share/ -u -o Serve single file miniserve file Start user verification miniserve --auth joe:123 some_dir ","date":"2021-11-04","objectID":"/miniserver/:0:0","tags":["linux"],"title":"Miniserve, an elegant file server","uri":"/miniserver/"},{"categories":["interview"],"content":"Q. What is the most efficient way to sort a million integers? Time Complexity Sorting Algorithm Average Case Best Case Worst Case Bubble Sort O(n^2) O(n) O(n^2) Insertion Sort O(n^2) O(n) O(n^2) Selection Sort O(n^2) O(n^2) O(n^2) Quick Sort O(n.log(n)) O(n.log(n)) O(n^2) Merge Sort O(n.log(n)) O(n.log(n)) O(n.log(n)) Heap Sort O(n.log(n)) O(n.log(n)) O(n.log(n)) Counting Sort O(n+k) O(n+k) O(n+k) Radix Sort O(n*k) O(n*k) O(n*k) Bucket Sort O(n+k) O(n+k) O(n^2) Space Complexity Sorting Algorithm Space Complexity Bubble Sort O(1) Insertion Sort O(1) Selection Sort O(1) Quick Sort O(log(n)) Merge Sort O(n) Heap Sort O(1) Counting Sort O(k) Radix Sort O(n + k) Bucket Sort O(n) Stability Sorting Algorithm Stable Sort? Bubble Sort Yes Insertion Sort Yes Selection Sort No Quick Sort No Merge Sort Yes Heap Sort No Counting Sort Yes Radix Sort Yes Bucket Sort Yes Consider above all, merge sort will be the best choice. ","date":"2021-11-03","objectID":"/i1.sort-1-million/:0:0","tags":["interview","bat","algorithm"],"title":"i1.What is the most efficient way to sort a million integers?","uri":"/i1.sort-1-million/"},{"categories":["coding"],"content":"Install Conda Packaging Tool conda install conda-build anaconda-client ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:0","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"File Structure - home/ - my_package/ - my_package/ - package_lib/ - setup.py - README.md - run_test.py - build.sh - meta.yaml ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:1","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"meta.yaml This file tells conda-build how to package files under my_package/ package: name: my_package version: 1.1.2 source: path: my_package/my_package/ build: number: 0 requirements: build: - python \u003e=3 - setuptools run: - python \u003e=3 - numpy \u003e=1.20 - scipy - pandas - scikit-learn \u003e=0.22 - lightgbm - matplotlib - seaborn - plink \u003e=1.9 test: source_files: - run_test.py about: home: https://github.com/JoshuaChou2018 license: MIT ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:2","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"build.sh The build.sh script contains methods to compile and install. So we use setuptools to complete the compilation and installation process. Content of build.sh # Install my_package $PYTHON setup.py install ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:3","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"setup.py # -*- coding: utf-8 -*- from setuptools import setup, find_packages setup( name='my_package', version='1.0.3', description=( 'my_package' ), author='my_package', author_email='my_package', maintainer='my_package', maintainer_email='my_package', license='MIT License', url='https://github.com/JoshuaChou2018/my_package', packages=find_packages(), entry_points={ 'console_scripts': [ 'run = my_package.entry:main', ] }, classifiers=[ 'Operating System :: OS Independent', 'License :: OSI Approved :: MIT License', 'Programming Language :: Python :: 3' ], python_requires='\u003e=3' ) ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:4","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"Start build conda build my_package/ ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:5","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"Publish anaconda login anaconda upload /home/miniconda3/conda-bld/linux-64/my_package-1.0.0-py39_0.tar.bz2 ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:6","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":null,"content":"I’m Juexiao Zhou, Joshua Chou, 周觉晓 PhD student @KAUST. Major in Bioinformatics and Computer Science. Email: juexiao.zhou@gmail.com Wechat: JoshuaChou666 QQ: 414816433 CV, Github, Linkedln, ORCID, Google Scholar Education PhD Student, Supervised by Prof. Xin Gao, Computational Bioscience Research Center (CBRC), King Abdullah University of Science and Technology, Dec 2021 - Present MS Student, Supervised by Prof. Xin Gao, Computational Bioscience Research Center (CBRC), King Abdullah University of Science and Technology, Aug 2020 - Dec 2021 Visiting Student, Supervised by Prof. Xin Gao, Computational Bioscience Research Center (CBRC), King Abdullah University of Science and Technology, Sep 2019 - Feb 2020 B.S. (Honored) in Bioinformatics, Supervised by Prof. Wei Chen, Southern University of Science and Technology, Sep 2016 - Jun 2020 Research Interest Bioinformatics \u0026 Deep Learning Analysis and integration of biological omics data with deep learning methods. Developing new bioinformatics tools. Brain Science \u0026 Cognitive Neuroscience Mechanism of Language, Emotion, Memory, and Dream. Macroscopic phenomena and application of brain. The human brain and Artificial Intelligence. Brain Computer Interface Artificial Intelligence Theoretical Research of Deep Learning. Medical Imaging EEG, X-ray, fMRI Membership Chinese Association for Artificial Intelligence (CAAI) Member Reviewer Journal of Bioinformatics and Computational Biology ICONIP2020 MICCAI2020 ICMLA2021 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"King Abdullah University of Science and Technology ","date":"0001-01-01","objectID":"/honours/:1:0","tags":null,"title":"","uri":"/honours/"},{"categories":null,"content":"KAUST, 2021-Present PhD, Computer Science GPA: 4.00 / 4.00 Excellent Research Award, CEMSE, 2021 ","date":"0001-01-01","objectID":"/honours/:2:0","tags":null,"title":"","uri":"/honours/"},{"categories":null,"content":"King Abdullah University of Science and Technology ","date":"0001-01-01","objectID":"/honours/:3:0","tags":null,"title":"","uri":"/honours/"},{"categories":null,"content":"KAUST, 2020-2021 MS, Computer Science GPA: 3.95 / 4.00 Student ambassador, CEMSE, 2021 Yearly best studetnt award, CEMSE, 2021 Full scholarship for MS/PhD study, 2020 ","date":"0001-01-01","objectID":"/honours/:4:0","tags":null,"title":"","uri":"/honours/"},{"categories":null,"content":"Southern University of Science and Technology ","date":"0001-01-01","objectID":"/honours/:5:0","tags":null,"title":"","uri":"/honours/"},{"categories":null,"content":"SUSTech, 2016-2020 Bachelor, Bioinformatics, Biology GPA: 3.92 / 4.00 (Top 0.1%), Core GPA: 3.94/4.00 Outstanding graduate of SUSTech, 2020. Cum Laude Graduate of the Department of Biology (Top 1/10), 2020. The Guinness world record for “the most vows received by a single civilized act activity”, 2019 Candidate for 2019 National Scholarship, 2019 Summer social practice excellent experience Award, 2018 Excellent Student, The First Prize Scholarship, 2018 Outstanding volunteer for the 12th CBIS Biennial Meeting, Shenzhen, China, 2018 Candidate for 2018 National Scholarship, 2018 Outstanding Volunteer of the 3rd Shenzhen International Life Science \u0026 Health Industry Summit (2016) Excellent Student, The First Prize Scholarship, 2017 Dean scholarship, The First Prize Scholarship, 2017 Excellent Student Cadre, 2017 Outstanding Volunteer of 2017 Shenzhen International Precision Medicine Summit, 2017 Alma mater practice excellent team, 2017 National Literary Creation Award, 2016 Excellent Student, The Second Prize Scholarship, 2016 ","date":"0001-01-01","objectID":"/honours/:6:0","tags":null,"title":"","uri":"/honours/"},{"categories":null,"content":"Journal An interpretable computer-aided diagnosis method for periodontitis from panoramic radiographs. Haoyang Li, Juexiao Zhou, Yi Zhou, Jieyu Chen, Feng Gao, Ying Xu, Xin Gao. Frontiers in Physiology, section Computational Physiology and Medicine, doi: 10.3389/fphys.2021.655556. [ link ] [ pdf ] Automatic and interpretable model for periodontitis diagnosis in panoramic radiographs. Haoyang Li, Juexiao Zhou, Yi Zhou, Jieyu Chen, Feng Gao, Ying Xu, Xin Gao. Medical Image Computing and Computer Assisted Interventions 2020. doi: 10.1007/978-3-030-59713-9_44 [ link ] [ pdf ] DeeReCT-APA: Prediction of Alternative Polyadenylation Site Usage through Deep Learning. Zhongxiao Li, Yisheng Li, Bin Zhang, Yu Li, Yongkang Long, Juexiao Zhou, Xudong Zou, Min Zhang, Yuhui Hu, Wei Chen, Xin Gao. Genomics Proteomics and Bioinformatics. doi: 10.1016/j.gpb.2020.05.004 [ link ] [ pdf ] A Rapid, Accurate and Machine-agnostic Segmentation and Quantification Method for CT-based COVID-19 Diagnosis. Liongxi Zhou, Zhongxiao Li, Juexiao Zhou , Haoyang Li , Yupeng Chen, Yuxin Huang, Dexuan Xie, Lintao Zhao, Ming Fan, Shahrukh Hashmi, Faisal AbdelKareem, Riham Eiada, Xigang Xiao, Lihua Li, Zhaowen Qiu, and Xin Gao. Transactions on Medical Imaging, 2020. doi: 10.1109/TMI.2020.3001810 [ link ] [ pdf ] CaMeRe: A novel tool for inference of cancer metabolic reprogramming. Haoyang Li , Juexiao Zhou, Huiyan Sun, Zhaowen Qiu, Xin Gao and Ying Xu. Front. Oncol., 2020. doi: 10.3389/fonc.2020.00207 [ link ] [ pdf ] Pan-tissue analysis of allelic alternative polyadenylation suggests widespread functional regulation. Yisheng Li* , Bernhard Schaefke* , Xudong Zou , Min Zhang , Florian Heyd , Wei Sun , Bin Zhang , Guipeng Li , Weizheng Liang , Yuhao He , Juexiao Zhou , Yunfei Li , Liang Fang , Yuhui Hu. Molecular Systems Biology, 2020. doi: 10.15252/msb.20199367 [ link ] [ pdf ] ","date":"0001-01-01","objectID":"/publications/:1:0","tags":null,"title":"","uri":"/publications/"},{"categories":null,"content":"Preprint or under review DeeReCT-TSS: A novel meta-learning-based method annotates TSS in multiple cell types based on DNA sequences and RNA-seq data. Juexiao Zhou*, Bin Zhang*, Haoyang Li, Longxi Zhou, Zhongxiao Li, Yongkang Long, Wenkai Han, Mengran Wang, Huanhuan Cui, Wei Chen, Xin Gao. under review. A Workflow for Automatic, Accurate and Robust Breast Tumor Segmentation on Multi-Database DCE-MRI. Longxi Zhou, Yitong Ding, Jiayang Guo, Ming Fan, Juexiao Zhou, Haoyang Li, Yujiao Li, Yuxin Huang, Yi Zhao, Yuetan Chu, Kun Wang, Qiming Fang, Xin Gao. Hongxia Zhang; Lihua Li. under review. Seeing the Unseen: Discovering Interpretable Sub-Visual Abnormalities in CT Scans of COVID-19 Patients and Survivors by Deep Learning. Longxi Zhou*, Xianglin Meng*, Yuxin Huang*, Kai Kang , Juexiao Zhou, Yuetan Chu , Haoyang Li , Dexuan Xie , Jiannan Zhang , Weizhen Yang , Na Bai , Yi Zhao , Mingyan Zhao , Guohuag Wang, Lawrence Carin, Xigang Xiao, Kaijiang Yu, Zhaowen Qiu , and Xin Gao. under review. SD2: Spatially resolved transcriptomics deconvolution through integration of spatial and dropout information. Haoyang Li, Hanmin Li, Juexiao Zhou and Xin Gao. under review. ","date":"0001-01-01","objectID":"/publications/:2:0","tags":null,"title":"","uri":"/publications/"},{"categories":null,"content":"Conference Deetal-Perio: DEEp denTAL Advisor for Periodontitis Diagnosis based on Two-step Segmentation of Teeth and Gingiva with Lower-dimensional Features. Haoyang Li, Juexiao Zhou , Xin Gao. Poster. DigitalHealth, KAUST, 2020. CaMeRe: A novel tool for inference of cancer metabolic reprogramming. Haoyang Li, Juexiao Zhou, Huiyan Sun, Zhaowen Qiu, Xin Gao and Ying Xu. Poster. Advance In Artificial Intelligence, KAUST, 2019. DeeRect-PAS—A Deep-Learning based method for Transcriptome-wide PAS Identification. Yongkang Long, Juexiao Zhou, Zhongxiao Li, Wei Chen, Xin Gao. Poster. Advance In Artificial Intelligence, KAUST, 2019. Systematical discovery of cis-elements regulating alternative polyadenylationin mammalian cells. Min Zhang, Yisheng Li, Juexiao Zhou, Yuhao He, Guipeng Li, Liang Fang, Wei Chen. Poster. RNA Biology, CSH Asia, 2019. Systematical discovery of cis-elements regulating alternative polyadenylationin mammalian cells. Min Zhang, Yisheng Li, Juexiao Zhou, Yuhao He, Guipeng Li, Liang Fang, Wei Chen. Poster. Regulatory RNAs, Cell Symposia, Berlin, Germany, May 12-14, 2019. ","date":"0001-01-01","objectID":"/publications/:3:0","tags":null,"title":"","uri":"/publications/"}]