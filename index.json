[{"categories":["course"],"content":"[Note] This is a draft version. ","date":"2025-04-23","objectID":"/backup/csc3100-data-structure---2025fall/:0:0","tags":["CSC3100"],"title":"CSC3100-2025-Fall Data Structure","uri":"/backup/csc3100-data-structure---2025fall/"},{"categories":["course"],"content":"Course Description This course provides an introduction to the field of machine learning, covering fundamental concepts, algorithms, and applications. Students will learn various machine learning techniques, including classic machine learning algorithms (Linear regression, Support Vector Machine, K-Means, etc.), and neural networks (MLP, CNN, RNN, Transformer). The course combines theoretical foundations with practical implementation, preparing students for advanced study and research in machine learning. By the end of this course, students will be able to: Understand the fundamental concepts and principles of machine learning. Implement and apply various machine learning algorithms. Analyze and solve real-world problems using machine learning techniques. Evaluate the performance of machine learning models. ","date":"2025-04-23","objectID":"/backup/csc3100-data-structure---2025fall/:0:1","tags":["CSC3100"],"title":"CSC3100-2025-Fall Data Structure","uri":"/backup/csc3100-data-structure---2025fall/"},{"categories":["course"],"content":"Teaching Team Instructors: Session 1: Prof. Haizhou Li (haizhouli@cuhk.edu.cn) Session 2: Prof. Juexiao Zhou (juexiao.zhou@gmail.com) Office location: TBD Office hours: TBD TAs: TBD TBD ","date":"2025-04-23","objectID":"/backup/csc3100-data-structure---2025fall/:0:2","tags":["CSC3100"],"title":"CSC3100-2025-Fall Data Structure","uri":"/backup/csc3100-data-structure---2025fall/"},{"categories":["course"],"content":"Course Time and Location Session 1 Day Start End Location Type Tuesday 13:30 15:00 TB_104 lecture Thursday 13:30 15:00 TB_104 lecture Session 2 Day Start End Location Type Tuesday 15:30 17:00 TxC201 lecture Thursday 15:30 17:00 TxC201 lecture ","date":"2025-04-23","objectID":"/backup/csc3100-data-structure---2025fall/:0:3","tags":["CSC3100"],"title":"CSC3100-2025-Fall Data Structure","uri":"/backup/csc3100-data-structure---2025fall/"},{"categories":["course"],"content":"Format In-person. Slides will be available the day before the lecture. ","date":"2025-04-23","objectID":"/backup/csc3100-data-structure---2025fall/:0:4","tags":["CSC3100"],"title":"CSC3100-2025-Fall Data Structure","uri":"/backup/csc3100-data-structure---2025fall/"},{"categories":["course"],"content":"Logistics Communications Blackboard is the main software to manage the course, and grading will be through Blackboard. We will use Feishu (Group QR code will be released in the first lecture) for discussion. You can ask questions and discuss on Feishu. For personal matters, please send a private message to the instructor or TAs. You are also very welcome to send emails to the teaching team. Grading Written Assignment (30%): Three graded homeworks (W1, W2, W3; 10%, 10%, 10%). Programming Assignment (20%): Two graded homeworks (P1, P2; 10%, 10%). Course Project (10%): A graded individual project with a pre-defined or self-proposed topic. The project has three components: a midterm report (5%), a final report (10%), and a presentation (5%). Final exam (40%): A graded final exam with one bonus question (extra 1%). Late Submission: You have 2 weeks to independently complete each assignment (written \u0026 programming). Late submission will get a discounted score: (0, 48] hours →50%; (48, ∞) hours →0%. Bonus (3%): One bonus question in the Final exam (1%). Post-lecture surveys: 0.5% for each, and the maximum is 2%. We do encourage you to complete all of them so that we know your feedback and can adjust the course accordingly. Plagiarism: Zero marks are given for the whole assignment (including written and programming) in the first plagiarism case. Students will FAIL the whole course for repeated plagiarism. Note: If there are heavy overlaps between two answers, then both will be identified as plagiarism (we don’t have time to distinguish). Thus, discussions are encouraged, but you must finish the assignment by yourself, and don’t share your answer with others. Final Grading: will be determined according to the distribution of all students. A class (A, A-): ~20% B class (B+, B, B-): ~60% C class (C+, C, C-): ~20% D class (D+, D-): accordingly. F class: accordingly. AI tools use policy You can use AI tools, including ChatGPT, to polish your report if applicable. However, you are required to submit both your own version and the one polished using AI tools. You are required to write a statement about how you used AI tools and which part of the report. We will grade the one you would like us to grade, but if you do not hand in your own version, we will not consider the submission complete. Programming Python (the TA will prepare a recitation class to introduce it, mainly for the non-grading homework and your project) or any other languages that you are familiar with. For Python, we suggest you use Colab. Projects The course project topic will be announced later. Students are free to form teams (with a maximum of 5 members per team). Each team will submit their algorithm and results based on the project topic. The course project will be graded according to the team’s ranking on the overall leaderboard. Bonus: If a team ranks in the global top 10 on the leaderboard, they will receive additional bonus points. Post-lecture survey Deadline for each survey: 11:59 pm on the day before the next lecture. We do this because we could have time to answer the questions you mentioned in the survey. We also encourage you to complete all of them so that we know your feedback and can adjust the course accordingly. ","date":"2025-04-23","objectID":"/backup/csc3100-data-structure---2025fall/:0:5","tags":["CSC3100"],"title":"CSC3100-2025-Fall Data Structure","uri":"/backup/csc3100-data-structure---2025fall/"},{"categories":["course"],"content":"Course schedule and materials Lecture Date Location Topic Slides Notes Reading Important dates (All due at 11:59 pm) 1 Sep 2 (Tue) TB_104 (S1) / TxC201 (S2) Introduction 2 Sep 4 (Thu) TB_104 (S1) / TxC201 (S2) Introduction 3 Sep 9 (Tue) TB_104 (S1) / TxC201 (S2) Review: Probability, linear algebra, optimization 4 Sep 11 (Thu) TB_104 (S1) / TxC201 (S2) Review: Probability, linear algebra, optimization 5 Sep 16 (Tue) TB_104 (S1) / TxC201 (S2) Linear regression 6 Sep 18 (Thu) TB_104 (S1) / TxC201 (S2) Linear regression 7 Sep 23 (Tue) TB_104 (S1) / TxC201 (S2) Logistic regression 8 Sep 25 (Thu) TB_104 (S1) / TxC201 (S2) Logistic regression 9 Sep 30 (Tue) TB_104 (S1) / TxC201 (S2) Support vector machine 10 Oct 9 (Thu) TB_104 (S1) / TxC201 (S2) Support vector machine 11 Oct 14 (Tue) TB_104 (S1) / TxC201 (S2) Decision tree and random forest 12 Oct 16 (Thu) TB_104 (S1) / TxC201 (S2) Decision tree and random forest 13 Oct 21 (Tue) TB_104 (S1) / TxC201 (S2) Neural networks I (MLP \u0026 CNN) 14 Oct 23 (Thu) TB_104 (S1) / TxC201 (S2) Neural networks I (MLP \u0026 CNN) 15 Oct 28 (Tue) TB_104 (S1) / TxC201 (S2) Neural networks II (RNN \u0026 Transformer) 16 Oct 30 (Thu) TB_104 (S1) / TxC201 (S2) Neural networks II (RNN \u0026 Transformer) 17 Nov 4 (Tue) TB_104 (S1) / TxC201 (S2) Over-fitting, bias-variance trade-off 18 Nov 6 (Thu) TB_104 (S1) / TxC201 (S2) Over-fitting, bias-variance trade-off 19 Nov 11 (Tue) TB_104 (S1) / TxC201 (S2) Performance evaluation 20 Nov 13 (Thu) TB_104 (S1) / TxC201 (S2) Performance evaluation 21 Nov 18 (Tue) TB_104 (S1) / TxC201 (S2) Introduction to unsupervised learning 22 Nov 20 (Thu) TB_104 (S1) / TxC201 (S2) Introduction to unsupervised learning 23 Nov 25 (Tue) TB_104 (S1) / TxC201 (S2) K-means and Gaussian mixture models 24 Nov 27 (Thu) TB_104 (S1) / TxC201 (S2) K-means and Gaussian mixture models 25 Dec 2 (Tue) TB_104 (S1) / TxC201 (S2) Expectation Maximization 26 Dec 4 (Thu) TB_104 (S1) / TxC201 (S2) Expectation Maximization 27 Dec 9 (Tue) TB_104 (S1) / TxC201 (S2) PCA 28 Dec 11 (Thu) TB_104 (S1) / TxC201 (S2) PCA Snapshot of Project Leaderboard TBD TBD Final Exam ","date":"2025-04-23","objectID":"/backup/csc3100-data-structure---2025fall/:0:6","tags":["CSC3100"],"title":"CSC3100-2025-Fall Data Structure","uri":"/backup/csc3100-data-structure---2025fall/"},{"categories":["course"],"content":"Written Assignment TBD ","date":"2025-04-23","objectID":"/backup/csc3100-data-structure---2025fall/:0:7","tags":["CSC3100"],"title":"CSC3100-2025-Fall Data Structure","uri":"/backup/csc3100-data-structure---2025fall/"},{"categories":["course"],"content":"Programming Assignment TBD ","date":"2025-04-23","objectID":"/backup/csc3100-data-structure---2025fall/:0:8","tags":["CSC3100"],"title":"CSC3100-2025-Fall Data Structure","uri":"/backup/csc3100-data-structure---2025fall/"},{"categories":["course"],"content":"Course Project TBD ","date":"2025-04-23","objectID":"/backup/csc3100-data-structure---2025fall/:0:9","tags":["CSC3100"],"title":"CSC3100-2025-Fall Data Structure","uri":"/backup/csc3100-data-structure---2025fall/"},{"categories":["course"],"content":"Course Description This course provides an introduction to the field of machine learning, covering fundamental concepts, algorithms, and applications. Students will learn various machine learning techniques, including classic machine learning algorithms (Linear regression, Support Vector Machine, K-Means, etc.), and neural networks (MLP, CNN, RNN, Transformer). The course combines theoretical foundations with practical implementation, preparing students for advanced study and research in machine learning. By the end of this course, students will be able to: Understand the fundamental concepts and principles of machine learning. Implement and apply various machine learning algorithms. Analyze and solve real-world problems using machine learning techniques. Evaluate the performance of machine learning models. ","date":"2025-04-23","objectID":"/backup/dda3020-machine-learning---2025fall/:0:1","tags":["DDA3020"],"title":"DDA3020-2025-Fall Machine Learning","uri":"/backup/dda3020-machine-learning---2025fall/"},{"categories":["course"],"content":"Teaching Team Instructors Session 1: Prof. Jicong Fan (fanjicong@cuhk.edu.cn) Session 2: Prof. Juexiao Zhou (juexiao.zhou@gmail.com) Office location: Zhixin Building 403b Office hours: 10:00–11:00 am, Tuesday in the odd weeks (3/5/7/9/11/13) TAs TBD TBD ","date":"2025-04-23","objectID":"/backup/dda3020-machine-learning---2025fall/:0:2","tags":["DDA3020"],"title":"DDA3020-2025-Fall Machine Learning","uri":"/backup/dda3020-machine-learning---2025fall/"},{"categories":["course"],"content":"Course Time and Location Session 1 Day Start End Location Type Tuesday 13:30 15:00 TB_104 lecture Thursday 13:30 15:00 TB_104 lecture Session 2 Day Start End Location Type Tuesday 15:30 17:00 TxC201 lecture Thursday 15:30 17:00 TxC201 lecture ","date":"2025-04-23","objectID":"/backup/dda3020-machine-learning---2025fall/:0:3","tags":["DDA3020"],"title":"DDA3020-2025-Fall Machine Learning","uri":"/backup/dda3020-machine-learning---2025fall/"},{"categories":["course"],"content":"Teaching Format In-person. Slides will be available the day before the lecture. ","date":"2025-04-23","objectID":"/backup/dda3020-machine-learning---2025fall/:0:4","tags":["DDA3020"],"title":"DDA3020-2025-Fall Machine Learning","uri":"/backup/dda3020-machine-learning---2025fall/"},{"categories":["course"],"content":"Logistics Communications Blackboard is the main software to manage the course, and grading will be through Blackboard. We will use Feishu (Group QR code will be released in the first lecture) for discussion. You can ask questions and discuss on Feishu. For personal matters, please send a private message to the instructor or TAs. You are also very welcome to send emails to the teaching team. Grading Written Assignment (30%): Three graded homeworks (W1, W2, W3; 10%, 10%, 10%). Programming Assignment (20%): Two graded programming homeworks (P1, P2; 10%, 10%). Course Project (10%): A graded individual project with a pre-defined topic. The project has two components: final code submission (5%) and a final report (5%). Final exam (40%): A graded final exam. Late Submission: You have 2 weeks to independently complete each assignment (written \u0026 programming). Late submission will get a discounted score: (0, 48] hours →50%; (48, ∞) hours →0%. Plagiarism: Zero marks are given for the whole assignment (including written and programming) in the first plagiarism case. Students will FAIL the whole course for repeated plagiarism. Note: If there are heavy overlaps between two answers, then both will be identified as plagiarism (we don’t have time to distinguish). Thus, discussions are encouraged, but you must finish the assignment by yourself, and don’t share your answer with others. Final Grading: will be determined according to the distribution of all students. AI Tools Use Policy You can use AI tools, including ChatGPT, to polish your report if applicable. You are also encouraged to use AI tools to help with your learning. However, you are required to submit both your own version and the one polished using AI tools. You are required to write a statement about how you used AI tools and which part of the report. We will grade the one you would like us to grade, but if you do not hand in your own version, we will not consider the submission complete. Programming Python (the TA will prepare a recitation class to introduce it, mainly for the non-grading homework and your project) or any other languages that you are familiar with. For Python, we suggest you use Colab. Projects The course project topic will be announced later. Post-lecture Survey Deadline for each survey: 11:59 pm on the day before the next lecture. We do this because we could have time to answer the questions you mentioned in the survey. We also encourage you to complete all of them so that we know your feedback and can adjust the course accordingly. ","date":"2025-04-23","objectID":"/backup/dda3020-machine-learning---2025fall/:0:5","tags":["DDA3020"],"title":"DDA3020-2025-Fall Machine Learning","uri":"/backup/dda3020-machine-learning---2025fall/"},{"categories":["course"],"content":"Course Schedule and Materials Week Lecture Date Location Topic Slides Notes Reading Important dates (All due at 11:59 pm) W1 1 Sep 2 (Tue) TB_104 (S1) / TxC201 (S2) Introduction W1 2 Sep 4 (Thu) TB_104 (S1) / TxC201 (S2) Introduction W2 3 Sep 9 (Tue) TB_104 (S1) / TxC201 (S2) Review: Probability, linear algebra, optimization W2 4 Sep 11 (Thu) TB_104 (S1) / TxC201 (S2) Review: Probability, linear algebra, optimization W3 5 Sep 16 (Tue) TB_104 (S1) / TxC201 (S2) Linear regression W1 + P1 release W3 6 Sep 18 (Thu) TB_104 (S1) / TxC201 (S2) Linear regression W4 7 Sep 23 (Tue) TB_104 (S1) / TxC201 (S2) Logistic regression W4 8 Sep 25 (Thu) TB_104 (S1) / TxC201 (S2) Logistic regression W5 9 Sep 30 (Tue) TB_104 (S1) / TxC201 (S2) Support vector machine W5 10 Oct 9 (Thu) TB_104 (S1) / TxC201 (S2) Support vector machine W6 11 Oct 14 (Tue) TB_104 (S1) / TxC201 (S2) Decision tree and random forest W6 12 Oct 16 (Thu) TB_104 (S1) / TxC201 (S2) Decision tree and random forest W2 + P2 release W7 13 Oct 21 (Tue) TB_104 (S1) / TxC201 (S2) Neural networks I (MLP \u0026 CNN) W7 14 Oct 23 (Thu) TB_104 (S1) / TxC201 (S2) Neural networks I (MLP \u0026 CNN) Project release W8 15 Oct 28 (Tue) TB_104 (S1) / TxC201 (S2) Neural networks II (RNN \u0026 Transformer) W8 16 Oct 30 (Thu) TB_104 (S1) / TxC201 (S2) Neural networks II (RNN \u0026 Transformer) W9 17 Nov 4 (Tue) TB_104 (S1) / TxC201 (S2) Over-fitting, bias-variance trade-off W9 18 Nov 6 (Thu) TB_104 (S1) / TxC201 (S2) Over-fitting, bias-variance trade-off W10 19 Nov 11 (Tue) TB_104 (S1) / TxC201 (S2) Performance evaluation W10 20 Nov 13 (Thu) TB_104 (S1) / TxC201 (S2) Performance evaluation W11 21 Nov 18 (Tue) TB_104 (S1) / TxC201 (S2) Introduction to unsupervised learning, K-means W3 release W11 22 Nov 20 (Thu) TB_104 (S1) / TxC201 (S2) Introduction to unsupervised learning, K-means W12 23 Nov 25 (Tue) TB_104 (S1) / TxC201 (S2) Expectation Maximization W12 24 Nov 27 (Thu) TB_104 (S1) / TxC201 (S2) Expectation Maximization W13 25 Dec 2 (Tue) TB_104 (S1) / TxC201 (S2) PCA W13 26 Dec 4 (Thu) TB_104 (S1) / TxC201 (S2) PCA W14 27 Dec 9 (Tue) TB_104 (S1) / TxC201 (S2) Review W14 28 Dec 11 (Thu) TB_104 (S1) / TxC201 (S2) Review TBD TBD Final Exam ","date":"2025-04-23","objectID":"/backup/dda3020-machine-learning---2025fall/:0:6","tags":["DDA3020"],"title":"DDA3020-2025-Fall Machine Learning","uri":"/backup/dda3020-machine-learning---2025fall/"},{"categories":["course"],"content":"Written Assignment W1 W2 W3 ","date":"2025-04-23","objectID":"/backup/dda3020-machine-learning---2025fall/:0:7","tags":["DDA3020"],"title":"DDA3020-2025-Fall Machine Learning","uri":"/backup/dda3020-machine-learning---2025fall/"},{"categories":["course"],"content":"Programming Assignment P1 P2 ","date":"2025-04-23","objectID":"/backup/dda3020-machine-learning---2025fall/:0:8","tags":["DDA3020"],"title":"DDA3020-2025-Fall Machine Learning","uri":"/backup/dda3020-machine-learning---2025fall/"},{"categories":["course"],"content":"Course Project TBD ","date":"2025-04-23","objectID":"/backup/dda3020-machine-learning---2025fall/:0:9","tags":["DDA3020"],"title":"DDA3020-2025-Fall Machine Learning","uri":"/backup/dda3020-machine-learning---2025fall/"},{"categories":["openings"],"content":"Position: Intern Requirements: Highly self-motivated, passionate about research, and interested in pursuing further studies in the future. Candidates with experience in publishing academic papers will be given preference. Salary and Benefits This internship is unpaid. However, outstanding research contributions will be recognized and rewarded. You will have opportunities to participate in research projects and may earn authorship on publications, which will strengthen your future academic applications. Application Procedure Please submit a full curriculum vitae, copies of relevant qualification documents, and at least two reference contacts via email to juexiao.zhou@gmail.com. If you are qualified, I will contact you for the next steps. Review of applications will begin immediately and continue until the position is filled. ","date":"2025-03-06","objectID":"/openings/intern/:0:0","tags":["openings"],"title":"Intern","uri":"/openings/intern/"},{"categories":["openings"],"content":"Position: PhD/MPhil Student Admissions Requirements: The school’s admissions committee has strict requirements, which is what I cannot control. Applicants for the MPhil/PhD programs must meet at least one of the following criteria (otherwise, admission chances will be relatively low): Ranked in the top 30% of a Project 985 university (in China) or an equivalent institution (in other countries, a high QS ranking is preferred). Or, first-author publication in a top-tier journal or conference. Or, other prestigious awards with significant recognition. And, meet the university’s minimum language requirement (IELTS 6.5 / TOEFL 80), with the option to submit proof after applying. My Preferred Qualifications: Degree in Computer Science, Big Data, Artificial Intelligence, Bioinformatics, Statistics, Mathematics, or a related field. Students from non-CS backgrounds are also welcome. Graduated from a top university with a GPA ranking in the top 10%. Strong foundation in mathematics and computer science. Preference will be given to candidates with relevant competition awards. Highly self-motivated, passionate about research, and interested in pursuing further studies in the future. Solid programming skills. Internship experience in a company is a plus. For PhD Applicants: At least one first-author/co-first paper published in areas such as Artificial Intelligence, Healthcare, or Computational Biology. Or significant contributions to popular open-source projects. If you are highly interested in joining our lab but do not yet meet these requirements, you may apply for the MPhil program, the taught Master’s program, or an RA position. Priority for PhD admission will be given to outstanding MPhil students or RAs within the lab. For MPhil Applicants: At least one first-author/co-first paper published in areas such as Artificial Intelligence, Healthcare, or Computational Biology. Or significant contributions to popular open-source projects. Please note that the MPhil program at CUHK-Shenzhen is self-funded. Key Duties and Responsibilities: I am looking for self-motivated PhD/MPhil students passionate about AI and healthcare. If you have ambition and a dream, I will do everything I can to support you. But in case you give up on yourself, then I’ll just give up on you. I have a limited number of openings each year. Application Procedure Please send a full curriculum vitae together with copies of qualification documents by email to juexiao.zhou@gmail.com. If you are qualified, I will contact you for a short interview. Once you have passed the interview, you will receive my message and be encouraged to apply through our school’s official website. Upon approval by the admissions committee, I will officially welcome you to our lab. Review of applications will begin immediately and will continue until the position is filled. Supervision As a supervisor in computer science, I can offer you: Productivity \u0026 Technical Expertise I stay up to date with the technical details of recent research and am highly productive. This allows me to provide clear, detailed guidance to you. Beyond supervision, I actively collaborate with students, co-authoring papers and offering hands-on support throughout the research process. Science Taste and Direction Control I have a strong grasp of cutting-edge and trending research areas, thus I can identify potential topics with the potential for top-tier publications. I offer you the possibility of publishing papers in top journals and conferences. Unlimited Computational Resources Students under my supervision have unrestricted access to multiple supercomputers and cloud computing, ensuring no computational limitations for their research. Global Collaboration Network My research network spans the US, Australia, the Middle East, and Mainland China, including top institutions such as MIT, Stanford, Duke, KAUST, MBZUAI, HKUST, CUHK, and so on. I collaborate with industry researchers from leading companies such as Microsoft, Meta a","date":"2025-03-06","objectID":"/openings/phdmphil-student/:0:0","tags":["openings"],"title":"PhD/MPhil Student","uri":"/openings/phdmphil-student/"},{"categories":["openings"],"content":"Post Specification Position: Part-time/Full-time Research Assistant (RA) Key Duties and Responsibilities: Provide research support to the team. Assist with administrative tasks, including procurement and funding management. Coordinate project activities and related tasks. Perform other duties as assigned by the supervisor. Qualifications and Requirements: A degree in Computer Science, Bioinformatics, or related disciplines (Master’s degree preferred). Prior experience in AI for healthcare is an advantage. Strong English reading and writing skills. High sense of responsibility, strong team spirit, and excellent communication skills. Salary and Benefits Salary will be competitive and commensurate with qualifications and experience. Appointments will be made under the establishment of CUHK(SZ), and statutory benefits will be provided in accordance with prevailing labor laws in the PRC. The appointee will be based at the University campus in Shenzhen, PRC. Application Procedure Please send a full curriculum vitae, copies of relevant qualification documents, and at least two references to juexiao.zhou@gmail.com. Qualified candidates will be invited for a short interview. Successful candidates will receive an offer upon passing the interview. Review of applications will begin immediately and will continue until the position is filled. ","date":"2025-03-06","objectID":"/openings/research-assistant-ra/:0:0","tags":["openings"],"title":"Research Assistant (RA)","uri":"/openings/research-assistant-ra/"},{"categories":["system"],"content":"Problem: After installing onlyoffice (docker) and onlyoffice-plugin in mattermost. It shows Download failed when open files in mattermost. Reason: JWT_HEADER must be set to a value that is not Authorization, as stated here: JWT Header: If JWT protection is enabled, it is necessary to specify a custom header name since the Mattermost security policy blocks external ‘Authorization’ Headers. This header should be specified in the ONLYOFFICE Docs signature settings as well (further information can be found here). Reference: https://github.com/ONLYOFFICE/onlyoffice-mattermost?tab=readme-ov-file#plugin-settings Solution: Modify docker-compose.yml for onlyoffice and add environment JWT_HEADER version: '3' services: onlyoffice: image: onlyoffice/documentserver ports: - \"3080:80\" - \"3443:443\" environment: JWT_HEADER: AuthorizationJWT restart: unless-stopped volumes: - ./data:/var/www/onlyoffice/Data Restart docker compose up -d Modify the setting in mattermost ","date":"2024-12-19","objectID":"/download-failed-for-onlyoffice-in-mattermost/:0:0","tags":["system"],"title":"Download failed for onlyoffice in mattermost","uri":"/download-failed-for-onlyoffice-in-mattermost/"},{"categories":["system"],"content":"在 Ubuntu 中挂载硬盘后，如果发现硬盘的部分空间显示为“系统占用”或不可用，可能是由于： Ext4 默认会预留 5% 的空间给root，以便在磁盘空间耗尽时仍可进行系统操作。这部分空间通常也会显示为“系统占用”。 解决方法： 如果这是数据盘而非系统盘，可以使用 sudo tune2fs -m 0 /dev/sdX1 ","date":"2024-12-10","objectID":"/%E7%A1%AC%E7%9B%98%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F%E5%8D%A0%E7%94%A8/:0:0","tags":["system"],"title":"Ext4硬盘空间系统占用","uri":"/%E7%A1%AC%E7%9B%98%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F%E5%8D%A0%E7%94%A8/"},{"categories":["system"],"content":"问题描述 smtp服务器已配置ssl，支持465端口并且在其它软件中均可正常配置。但是使用nextcloud-aio-nextcloud docker，在Nextcloud中配置自建smtp服务器时总是遇到报错： “A problem occurred while sending the email. Please revise your settings. (Error: Email could not be sent. Check your mail server log)” ","date":"2024-10-11","objectID":"/nextcloud%E9%85%8D%E7%BD%AEsmtp%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:1","tags":["system","linux"],"title":"nextcloud配置smtp邮件服务器","uri":"/nextcloud%E9%85%8D%E7%BD%AEsmtp%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["system"],"content":"解决方案 修改config.php文件，首先在nextcloud-aio-nextcloud docker中定位数据卷的位置，如/var/lib/docker/volumes/nextcloud_aio_nextcloud/_data，在这个文件夹下的config/config.php即为配置文件。 在config/config.php中加入一行以下内容，即可解决问题： 'mail_smtpstreamoptions' =\u003e array ( 'ssl' =\u003e array ( 'allow_self_signed' =\u003e true, 'verify_peer' =\u003e false, 'verify_peer_name' =\u003e false, ), ), ","date":"2024-10-11","objectID":"/nextcloud%E9%85%8D%E7%BD%AEsmtp%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:2","tags":["system","linux"],"title":"nextcloud配置smtp邮件服务器","uri":"/nextcloud%E9%85%8D%E7%BD%AEsmtp%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["system"],"content":" free -h sudo swapoff /swapfile sudo rm /swapfile df -h sudo fallocate -l 64G /swapfile ls -lh /swapfile sudo chmod 600 /swapfile sudo mkswap /swapfile sudo swapon /swapfile sudo swapon --show free -h sudo cp /etc/fstab /etc/fstab.bak echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab ","date":"2024-10-05","objectID":"/%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BAswapfile%E6%96%87%E4%BB%B6%E4%BB%A5%E9%85%8D%E7%BD%AEswap/:0:0","tags":["system","linux"],"title":"手动创建swapfile文件以配置swap","uri":"/%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BAswapfile%E6%96%87%E4%BB%B6%E4%BB%A5%E9%85%8D%E7%BD%AEswap/"},{"categories":["linux"],"content":" -------------------------- ---- Prerequisites: ---- -------------------------- * The steps here only need to be performed once on your computer; after these are done than you only need to follow the steps under the \"Procedure\" section. 1). The user that will be connecting in via SSH must be in the 'tty' group on the system where Sunshine will be started. This is required because when we startup Xorg (the X-server we'll be using) than it will attempt to access the specific virtual TTY we give it to use. NOTE: At minimum you will have to log out and log back in after doing this as Linux won't assign the group to you in your current session. Use the 'groups' command to verify that you see 'tty' before proceeding. sudo usermod -a -G [group-name] [user-name] 2). You need to run the command below to give the capability 'CAP_SYS_RAWIO+eip' to the /usr/lib/xorg/Xorg executable: setcap CAP_SYS_RAWIO+eip /usr/lib/xorg/Xorg Note that some more research needs to be done into the implications of doing this but if you don't provide that capability than the Xorg server session will fail with an error like the following: xf86EnableIOPorts: failed to set IOPL for I/O (Operation not permitted) 3). As root you will need to edit the /etc/X11/Xwrapper.conf file and change the 'allowed_users' setting to 'anybody'. While this will have some security implications they should be managable as this should only be giving the required permission to valid and logged in users to start an Xorg server session. The default, which is typically 'console', requires that you log in with one of the virtual TTYs for the system and this is no different than physically logging into the system anyways (the exact thing we're trying to avoid). More information about this setting is available from \"man Xorg.wrap\". Reboot your system to make sure this takes effect before proceeding. As an aside it would be nice to submit a feature request to the devs working on the Xorg.wrap logic and ask them to provide a group option that gives something between \"console\" and \"anybody\". Ideally a group you specify (or even one they define) whose users would then be allowed to start the Xorg server. How to find out where/who to submit this to though.... 4). You will need to create a custom Xorg configuration file that is suitable for use with a \"headless\" session (i.e., one in which we don't really use the physically attached monitor for). To do this follow the steps below: 4a). SSH into the machine where you want to run Sunshine and then run the command below to generate a new Xorg configuration: sudo Xorg :1 -configure Expect to see the command show errors and say that it failed but a new file should appear at /root/xorg.conf.new containing the information we need. NOTE: The actual command found online was \"sudo Xorg :0 -configure\" but this almost always fails as any system with a graphical desktop environment will already be running on display :0. It is possible to halt the display manager (for example with \"/etc/init.d/lightdm stop\" or \"/etc/init.d/gdm stop\"), run the command, then restart the display manager but this is pretty invasive on the system. The result also seems to generate the same error (and a file with the same content) as the command already given. 4b). Change ownership of the file generated in step 4a and move it into your Linux user's home directory. Note that the location you place the file doesn't matter; we just want to get this out of the root users directory. 4c). Now open the moved 'xorg.conf.new' in your text editor of choice and make the following changes: A). If you have multiple GPUs than your ServerLayout section will look like the following: Section \"ServerLayout\" Identifier \"X.org Configured\" Screen 0 \"Screen0\" 0 0 Screen 1 \"Screen1\" RightOf \"Screen0\" Screen 2 \"Screen2\" RightOf \"Screen1\" Screen 3 \"Screen3\" RightOf \"Screen2\" InputDevice \"Mouse0\" \"CorePointer\" InputDevice \"Keyboard0\" \"CoreKeyboard\" EndSection This will create a screen for each GPU and will","date":"2024-09-19","objectID":"/build-sunshine-on-ubuntu-without-monitor/:0:0","tags":["linux","ubuntu"],"title":"Build Sunshine on Ubuntu without monitor","uri":"/build-sunshine-on-ubuntu-without-monitor/"},{"categories":["linux"],"content":"Problem: Get this error when install ./NVIDIA-Linux-x86_64-535.104.05.run. ![image-20240919101144517](/Users/joshuachou/Library/Application Support/typora-user-images/image-20240919101144517.png) Solution: Check if any vncserver is running and close it. ","date":"2024-09-19","objectID":"/error-you-appear-to-be-running-an-x-server/:0:0","tags":["linux","ubuntu"],"title":"ERROR: You appear to be running an X server;","uri":"/error-you-appear-to-be-running-an-x-server/"},{"categories":["linux"],"content":"Problem: NVIDIA driver install - Error: Unable to find the kernel source tree Solution: sudo apt-get install linux-headers-`uname -r` ","date":"2024-09-19","objectID":"/nvidia-driver-install-error-unable-to-find-the-kernel-source-tree/:0:0","tags":["linux","ubuntu"],"title":"NVIDIA driver install - Error: Unable to find the kernel source tree","uri":"/nvidia-driver-install-error-unable-to-find-the-kernel-source-tree/"},{"categories":["system"],"content":"问题描述：近期重启Ubuntu发现home目录写文件报错 cannot create directory ‘disk4’: Read-only file system 解决方案： sudo mount -o rw,remount / ","date":"2024-09-16","objectID":"/read-only-file-system/:0:0","tags":["system","linux"],"title":"cannot create directory ‘disk4’: Read-only file system","uri":"/read-only-file-system/"},{"categories":["system"],"content":"Problem: NVIDIA driver install - Error: Unable to find the kernel source tree Solution: sudo apt-get install linux-headers-`uname -r` ","date":"2024-09-16","objectID":"/unable-to-find-the-kernel-source-tree/:0:0","tags":["system","linux"],"title":"NVIDIA driver install - Error: Unable to find the kernel source tree","uri":"/unable-to-find-the-kernel-source-tree/"},{"categories":["forum"],"content":"Topic: As we move toward the development of Artificial General Intelligence (AGI), the possibilities for its future capabilities and applications are vast. AGI, unlike narrow AI, has the potential to understand, learn, and perform any intellectual task that a human being can, eventually surpassing human cognitive abilities in a wide range of areas. This leads us to wonder: What functions do you think AGI will be able to perform in the future? In which real-world scenarios do you believe AGI will be most effectively applied? Will AGI revolutionize industries like healthcare, transportation, and education, or will it bring about unforeseen innovations in areas such as space exploration and sustainable development? The discussion is open for your thoughts, ideas, and speculations on the possibilities and implications of AGI. Discussion Rules: Feel free to share your insights, but please adhere to the following guidelines: All comments must respect applicable laws and regulations, including those pertaining to privacy, intellectual property, and data protection. Use respectful and appropriate language in all interactions. Personal attacks, discriminatory remarks, or hate speech will not be tolerated. Avoid sharing misleading or false information. Aim for constructive and well-informed contributions. By participating, you agree to maintain the integrity and civility of the discussion. ","date":"2024-09-16","objectID":"/forum/the-future-of-agi--potential-functions-and-applications/:0:0","tags":["forum"],"title":"The Future of AGI – Potential Functions and Applications","uri":"/forum/the-future-of-agi--potential-functions-and-applications/"},{"categories":["python"],"content":"安装 Nettalk sudo apt install netatalk -y sudo apt install avahi-daemon -y Netatlk 3.x 只使用一个配置文件 /etc/netatalk/afp.conf : [Global] mimic model = TimeCapsule6,106 log level = default:warn log file = /var/log/afpd.log hosts allow = 192.168.1.0/16 [Homes] basedir regex = /home [TimeMachine] path = /home/joshuachou/myDisk/TimeMachine valid users = joshuachou time machine = yes 并且确保 avahi 处于运行状态： systemctl status avahi-daemon.service 查看 avahi 运行状态。 重启Netatalk服务： sudo service avahi-daemon restart sudo service netatalk restart ","date":"2024-09-15","objectID":"/netatalk%E5%9C%A8linux%E4%B8%8A%E9%9D%A2%E6%90%AD%E5%BB%BA%E6%97%B6%E9%97%B4%E6%9C%BA%E5%99%A8%E5%A4%87%E4%BB%BD/:0:0","tags":["numpy"],"title":"Netatalk在Linux上面搭建时间机器备份","uri":"/netatalk%E5%9C%A8linux%E4%B8%8A%E9%9D%A2%E6%90%AD%E5%BB%BA%E6%97%B6%E9%97%B4%E6%9C%BA%E5%99%A8%E5%A4%87%E4%BB%BD/"},{"categories":["python"],"content":"Mac 备份非常慢 如果你的 Mac 是第一次在这个上面进行备份，第一次备份一般都很慢，可以调节参数的方式将其调节为全速进行备份，记得备份完后将其调整回来，否则可能会导致你的电脑在正常使用的时候由于同时在备份导致卡顿。 打开终端，执行如下命令开启全速备份： sudo sysctl debug.lowpri_throttle_enabled=0 关闭全速备份： sudo sysctl debug.lowpri_throttle_enabled=1 ","date":"2024-09-15","objectID":"/netatalk%E5%9C%A8linux%E4%B8%8A%E9%9D%A2%E6%90%AD%E5%BB%BA%E6%97%B6%E9%97%B4%E6%9C%BA%E5%99%A8%E5%A4%87%E4%BB%BD/:1:0","tags":["numpy"],"title":"Netatalk在Linux上面搭建时间机器备份","uri":"/netatalk%E5%9C%A8linux%E4%B8%8A%E9%9D%A2%E6%90%AD%E5%BB%BA%E6%97%B6%E9%97%B4%E6%9C%BA%E5%99%A8%E5%A4%87%E4%BB%BD/"},{"categories":["linux"],"content":" 安装基础软件 sudo apt update sudo apt-get upgrade sudo apt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal sudo apt install tightvncserver vncserver 注: 在防火墙上打开 VNC Server 的监听端口 VNC Server 用到了三个端口：5801(*)、5901(*)、6001 修改~/.vnc/xstartup #!/bin/bash export $(dbus-launch) export XKL_XMODMAP_DISABLE=1 export XDG_CURRENT_DESKTOP=\"GNOME-Flashback:Unity\" export XDG_MENU_PREFIX=\"gnome-flashback-\" unset SESSION_MANAGER gnome-panel \u0026 gnome-settings-daemon \u0026 metacity \u0026 nautilus \u0026 gnome-terminal \u0026 # [ -x /etc/vnc/xstartup ] \u0026\u0026 exec /etc/vnc/xstartup # [ -r $HOME/.Xresources ] \u0026\u0026 xrdb $HOME/.Xresources autocutsel -fork xrdb $HOME/.Xresources xsetroot -solid grey vncconfig -iconic \u0026 x-terminal-emulator -geometry 80x24+10+10 -ls -title \"$VNCDESKTOP Desktop\" \u0026 gnome-session --session=gnome-flashback-metacity --disable-acceleration-check --debug \u0026 启动 chmod +x ~/.vnc/xstartup vncserver :1 ","date":"2024-07-02","objectID":"/ubuntu-vncserver/:0:0","tags":["linux","ubuntu"],"title":"Ubuntu配置VNCServer，一定能用，不白屏灰屏","uri":"/ubuntu-vncserver/"},{"categories":["linux"],"content":"机器无显示屏情况-设置虚拟显示屏 [转自：https://leimao.github.io/blog/Remote-Linux-Desktop/] ","date":"2024-07-02","objectID":"/ubuntu-vncserver/:1:0","tags":["linux","ubuntu"],"title":"Ubuntu配置VNCServer，一定能用，不白屏灰屏","uri":"/ubuntu-vncserver/"},{"categories":["linux"],"content":"Set Up Remote Linux Desktop ","date":"2024-07-02","objectID":"/ubuntu-vncserver/:1:1","tags":["linux","ubuntu"],"title":"Ubuntu配置VNCServer，一定能用，不白屏灰屏","uri":"/ubuntu-vncserver/"},{"categories":["linux"],"content":"X Forwarding We have to first enable X forwarding. We SSH to the remote Linux computer with -XC where X is the X service and C allows data compression. $ ssh -XC leimao@192.168.0.23 Welcome to Ubuntu 18.04.5 LTS (GNU/Linux 4.9.201-tegra aarch64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage This system has been minimized by removing packages and content that are not required on a system that users do not log into. To restore this content, you can run the 'unminimize' command. Last login: Sat May 15 09:18:28 2021 from 192.168.0.19 /usr/bin/xauth: file /home/leimao/.Xauthority does not exist We install xauth if it has not been installed on the remote Linux computer. $ sudo apt update $ sudo apt install -y xauth Make sure X11Forwarding is yes in /etc/ssh/sshd_config. $ cat /etc/ssh/sshd_config | grep X11Forwarding X11Forwarding yes Restart OpenSSH. sudo systemctl restart sshd Confirm X forwarding is enabled. $ echo $DISPLAY localhost:10.0 Quick test X forwarding with X applications. $ sudo apt install -y x11-apps $ xclock The GUI of the X applications will show up on our local computer. We could also try FireFox browser. $ sudo apt install -y firefox $ firefox ","date":"2024-07-02","objectID":"/ubuntu-vncserver/:1:2","tags":["linux","ubuntu"],"title":"Ubuntu配置VNCServer，一定能用，不白屏灰屏","uri":"/ubuntu-vncserver/"},{"categories":["linux"],"content":"Linux Desktop Forwarding We have run single X applications successfully. Can we forward the entire remote Linux desktop? Sure, we can. We will have to install the following dependencies. $ sudo touch /dev/fuse $ sudo apt install -y xfce4 xfce4-goodies gnome-icon-theme libcanberra-gtk-module Run the following command on the remote Linux computer while we are still ssh -X in. $ xfce4-session The forwarded desktop will show up on our local computer. Opening X applications from the forwarded desktop is fine. But we were not able to open terminal to run commands. ","date":"2024-07-02","objectID":"/ubuntu-vncserver/:1:3","tags":["linux","ubuntu"],"title":"Ubuntu配置VNCServer，一定能用，不白屏灰屏","uri":"/ubuntu-vncserver/"},{"categories":["linux"],"content":"Linux Desktop Forwarding via VNC A better way to forward the Linux Desktop is to use VNC service. To install the VNC server, we will install tightvncserver on the remote Linux computer. $ sudo apt install -y tightvncserver Then we could start a virtual desktop with an id of 1. $ vncserver :1 -geometry 1920x1080 -depth 24 We could then connect to the remote Linux desktop using VNC client software on our local computer. Remmina is installed by default on my local Ubuntu 20.04 LTS. Here we just have to input the remote Linux computer IP address with the VNC virtual desktop id, and press Enter. Remmina The connection was successful. However, we only see gray screen and could not do anything. To fix this problem, we disconnect the VNC connection and kill the virtual desktop. $ vncserver -kill :1 We will install lxde on the remote Linux computer. $ sudo apt install -y lxde We will modify the ~/.vnc/xstartup by adding /usr/bin/startlxde to it. The modified file will look like this. $ cat ~/.vnc/xstartup #!/bin/sh xrdb $HOME/.Xresources xsetroot -solid grey #x-terminal-emulator -geometry 80x24+10+10 -ls -title \"$VNCDESKTOP Desktop\" \u0026 #x-window-manager \u0026 # Fix to make GNOME work export XKL_XMODMAP_DISABLE=1 /etc/X11/Xsession /usr/bin/startlxde Finally, restart VNC server. $ vncserver :1 -geometry 1920x1080 -depth 24 This time, the remote Linux desktop shows correctly in Remmina. Remote Linux Desktop There are some inconvenience that copy and paste text between the local computer and the remote desktop does not work. To fix this problem, again, we disconnect the VNC connection and kill the virtual desktop. $ vncserver -kill :1 We will install autocutsel on the remote Linux computer. $ sudo apt install -y autocutsel We will modify the ~/.vnc/xstartup by adding autocutsel -fork to it. The modified file will look like this. $ cat ~/.vnc/xstartup #!/bin/sh xrdb $HOME/.Xresources xsetroot -solid grey autocutsel -fork #x-terminal-emulator -geometry 80x24+10+10 -ls -title \"$VNCDESKTOP Desktop\" \u0026 #x-window-manager \u0026 # Fix to make GNOME work export XKL_XMODMAP_DISABLE=1 /etc/X11/Xsession /usr/bin/startlxde Finally, restart VNC server. $ vncserver :1 -geometry 1920x1080 -depth 24 Now, we could copy and paste easily between the local computer and the remote desktop. ","date":"2024-07-02","objectID":"/ubuntu-vncserver/:1:4","tags":["linux","ubuntu"],"title":"Ubuntu配置VNCServer，一定能用，不白屏灰屏","uri":"/ubuntu-vncserver/"},{"categories":["linux"],"content":"References Remote Linux Desktop on Your VPS with SSH and VNC Grey Screen Comes on Connecting to VNC Server Running X Client Using Virtual X Server Xvfb Raspberry Pi: Enabling Copy and Paste over VNC https://leimao.github.io/blog/Remote-Linux-Desktop/ ","date":"2024-07-02","objectID":"/ubuntu-vncserver/:2:0","tags":["linux","ubuntu"],"title":"Ubuntu配置VNCServer，一定能用，不白屏灰屏","uri":"/ubuntu-vncserver/"},{"categories":["linux"],"content":"Problem description \u003e\u003e\u003e torch.cuda.is_available() /home/python3.8/site-packages/torch/cuda/__init__.py:141: UserWarning: CUDA initialization: CUDA unknown error - this may be due to an incorrectly set up environment, e.g. changing env variable CUDA_VISIBLE_DEVICES after program start. Setting the available devices to be zero. (Triggered internally at /opt/con da/conda-bld/pytorch_1708025845899/work/c10/cuda/CUDAFunctions.cpp:108.) return torch._C._cuda_getDeviceCount() \u003e 0 False But both nvcc - V and nvidia-smi still work ","date":"2024-03-20","objectID":"/cuda-unknown-error-this-may-be-due-to-an-incorrectly-set-up-environment/:0:1","tags":["linux","ubuntu"],"title":"CUDA unknown error - this may be due to an incorrectly set up environment","uri":"/cuda-unknown-error-this-may-be-due-to-an-incorrectly-set-up-environment/"},{"categories":["linux"],"content":"Solution sudo rmmod nvidia_uvm sudo modprobe nvidia_uvm ","date":"2024-03-20","objectID":"/cuda-unknown-error-this-may-be-due-to-an-incorrectly-set-up-environment/:0:2","tags":["linux","ubuntu"],"title":"CUDA unknown error - this may be due to an incorrectly set up environment","uri":"/cuda-unknown-error-this-may-be-due-to-an-incorrectly-set-up-environment/"},{"categories":["linux"],"content":"近期在ubuntu 18.04上开发PyQt6前段时发现问题： ubuntu 18.04.6 默认的 glibc 版本位 2.27, 在运行最新的 Qt Creator 6.0.2 时会报错 $ /opt/Qt/Tools/QtCreator/bin/qtcreator 报错 /opt/Qt/Tools/QtCreator/bin/qtcreator: /lib/x86_64-linux-gnu/libc.so.6: version `glibc_2.28' not found 此时最佳方法是升级到 ubuntu 20.04 或 ubuntu 22.04, 还有一种\"比较省心\"的方法, 保留系统仅升级 glibc 下载 https://ftp.gnu.org/gnu/glibc/glibc-2.28.tar.xz 准备编译环境 $ sudo apt install build-essential gawk bison 然后解压和编译 $ tar -xJf glibc-2.28.tar.xz $ cd glibc-2.28/ $ mkdir build $ cd build $ ../configure --prefix=/usr $ make 到这一步后不要 sudo make install 立刻安装到 /usr 制作 ubuntu 的启动盘, 通过试用 ubuntu(选择 Try Ubuntu without installing) 来完成 glibc 最后的安装 进入 ubuntu live 试用环境, 连接好网络, 同样准备一下环境 $ sudo apt update $ sudo apt install build-essential gawk bison 确定原 ubuntu 18.04 的根目录, 这个位置下包含 ‘dev’ ‘home’ ‘usr’ 等文件夹 可以通过文件夹点击指定的分区(这里是 /dev/nvme0n1p4)完成挂载 最后进入原 ubuntu 18.04 编译 glibc 的位置, 通过 sudo make install DESTDIR=xxx 安装, xxx 为原 ubuntu 18.04 的根目录 不指定 DESTDIR 时, 会安装至现有的 ubuntu 18.04 live 中, 导致当前的 ubuntu 18.04 崩溃 最后重启, 查看 glibc 的版本 这种方法仅解决了 ubuntu 18.04 系统层面上 glibc 2.28 的兼容问题, 但是 ubuntu 18.04 安装源中的软件不一定兼容 glilbc 2.28 在升级软件或新安装软件时可能会遇到 “core segmentfault” 的报错, 所以这种方式强烈不推荐 ","date":"2024-03-18","objectID":"/ubuntu-18.04-%E5%8D%87%E7%BA%A7%E8%87%B3-glibc_2.28/:0:0","tags":["linux","ubuntu"],"title":"ubuntu 18.04 升级至 glibc_2.28","uri":"/ubuntu-18.04-%E5%8D%87%E7%BA%A7%E8%87%B3-glibc_2.28/"},{"categories":["linux"],"content":"Ref https://gitcode.csdn.net/65e935d41a836825ed78d5d8.html?dp_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6NTE3MjYwMSwiZXhwIjoxNzExMzY4NDEwLCJpYXQiOjE3MTA3NjM2MTAsInVzZXJuYW1lIjoiemhvdWp1ZXhpYW8ifQ.Gx76GsG9uZlVza2jSRhK2Ii-YSlDPlQbYS6BiBT3pQM ","date":"2024-03-18","objectID":"/ubuntu-18.04-%E5%8D%87%E7%BA%A7%E8%87%B3-glibc_2.28/:1:0","tags":["linux","ubuntu"],"title":"ubuntu 18.04 升级至 glibc_2.28","uri":"/ubuntu-18.04-%E5%8D%87%E7%BA%A7%E8%87%B3-glibc_2.28/"},{"categories":["linux"],"content":"Introduction Virtual Network Computing, or VNC, is a connection system that allows you to use your keyboard and mouse to interact with a graphical desktop environment on a remote server. It makes managing files, software, and settings on a remote server easier for users who are not yet comfortable with the command line. In this guide, you’ll set up a VNC server with TightVNC on an Ubuntu 20.04 server and connect to it securely through an SSH tunnel. Then, you’ll use a VNC client program on your local machine to interact with your server through a graphical desktop environment. ","date":"2024-02-25","objectID":"/vnc-on-ubuntu-20.04/:0:1","tags":["linux","vnc"],"title":"How to Install and Configure VNC on Ubuntu 20.04","uri":"/vnc-on-ubuntu-20.04/"},{"categories":["linux"],"content":"Prerequisites To complete this tutorial, you’ll need: One Ubuntu 20.04 server with a non-root administrative user and a firewall configured with UFW. To set this up, follow our initial server setup guide for Ubuntu 20.04. A local computer with a VNC client installed. The VNC client you use must support connections over SSH tunnels: On Windows, you can use TightVNC, RealVNC, or UltraVNC. On macOS, you can use the built-in Screen Sharing program, or can use a cross-platform app like RealVNC. On Linux, you can choose from many options, including vinagre, krdc, RealVNC, or TightVNC. ","date":"2024-02-25","objectID":"/vnc-on-ubuntu-20.04/:1:0","tags":["linux","vnc"],"title":"How to Install and Configure VNC on Ubuntu 20.04","uri":"/vnc-on-ubuntu-20.04/"},{"categories":["linux"],"content":"Step 1 — Installing the Desktop Environment and VNC Server By default, an Ubuntu 20.04 server does not come with a graphical desktop environment or a VNC server installed, so you’ll begin by installing those. You have many options when it comes to which VNC server and desktop environment you choose. In this tutorial, you will install packages for the latest Xfce desktop environment and the TightVNC package available from the official Ubuntu repository. Both Xfce and TightVNC are known for being lightweight and fast, which will help ensure that the VNC connection will be smooth and stable even on slower internet connections. After connecting to your server with SSH, update your list of packages: sudo apt update Now install Xfce along with the xfce4-goodies package, which contains a few enhancements for the desktop environment: sudo apt install xfce4 xfce4-goodies During installation, you may be prompted to choose a default display manager for Xfce. A display manager is a program that allows you to select and log in to a desktop environment through a graphical interface. You’ll only be using Xfce when you connect with a VNC client, and in these Xfce sessions you’ll already be logged in as your non-root Ubuntu user. So for the purposes of this tutorial, your choice of display manager isn’t pertinent. Select either one and press ENTER. Once that installation completes, install the TightVNC server: sudo apt install tightvncserver Next, run the vncserver command to set a VNC access password, create the initial configuration files, and start a VNC server instance: vncserver You’ll be prompted to enter and verify a password to access your machine remotely: OutputYou will require a password to access your desktops. Password: Verify: The password must be between six and eight characters long. Passwords more than 8 characters will be truncated automatically. Once you verify the password, you’ll have the option to create a view-only password. Users who log in with the view-only password will not be able to control the VNC instance with their mouse or keyboard. This is a helpful option if you want to demonstrate something to other people using your VNC server, but this isn’t required. The process then creates the necessary default configuration files and connection information for the server. Additionally, it launches a default server instance on port 5901. This port is called a display port, and is referred to by VNC as :1. VNC can launch multiple instances on other display ports, with :2 referring to port 5902, :3 referring to 5903, and so on: OutputWould you like to enter a view-only password (y/n)? n xauth: file /home/sammy/.Xauthority does not exist New 'X' desktop is your_hostname:1 Creating default startup script /home/sammy/.vnc/xstartup Starting applications specified in /home/sammy/.vnc/xstartup Log file is /home/sammy/.vnc/your_hostname:1.log Note that if you ever want to change your password or add a view-only password, you can do so with the vncpasswd command: vncpasswd At this point, the VNC server is installed and running. Now let’s configure it to launch Xfce and give us access to the server through a graphical interface. ##Step 2 — Configuring the VNC Server The VNC server needs to know which commands to execute when it starts up. Specifically, VNC needs to know which graphical desktop environment it should connect to. The commands that the VNC server runs at startup are located in a configuration file called xstartup in the .vnc folder under your home directory. The startup script was created when you ran the vncserver command in the previous step, but you’ll create your own to launch the Xfce desktop. Because you are going to be changing how the VNC server is configured, first stop the VNC server instance that is running on port 5901 with the following command: vncserver -kill :1 The output will look like this, although you’ll see a different PID: OutputKilling Xtightvnc process ID 17648 Before you modify the xstartup fi","date":"2024-02-25","objectID":"/vnc-on-ubuntu-20.04/:2:0","tags":["linux","vnc"],"title":"How to Install and Configure VNC on Ubuntu 20.04","uri":"/vnc-on-ubuntu-20.04/"},{"categories":["linux"],"content":"Step 3 — Connecting to the VNC Desktop Securely VNC itself doesn’t use secure protocols when connecting. To securely connect to your server, you’ll establish an SSH tunnel and then tell your VNC client to connect using that tunnel rather than making a direct connection. Create an SSH connection on your local computer that securely forwards to the localhostconnection for VNC. You can do this via the terminal on Linux or macOS with the following sshcommand: ssh -L 59000:localhost:5901 -C -N -l sammy your_server_ip Here’s what this ssh command’s options mean: -L 59000:localhost:5901: The -L switch specifies that the given port on the local computer (59000) is to be forwarded to the given host and port on the destination server (localhost:5901, meaning port 5901 on the destination server, defined as your_server_ip). Note that the local port you specify is somewhat arbitrary; as long as the port isn’t already bound to another service, you can use it as the forwarding port for your tunnel. -C: This flag enables compression which can help minimize resource consumption and speed things up. -N: This option tells ssh that you don’t want to execute any remote commands. This setting is useful when you just want to forward ports. -l sammy your_server_ip: The -l switch let’s you specify the user you want to log in as once you connect to the server. Make sure to replace sammy and your_server_ip with the name of your non-root user and your server’s IP address. Note: This command establishes an SSH tunnel that forwards information from port 5901 on your VNC server to port 59000 on your local machine via port 22 on each machine, the default port for SSH. Assuming you followed the prerequisite Initial Server Setup guide for Ubuntu 20.04, you will have added a UFW rule to allow connections to your server over OpenSSH. This is more secure than simply opening up your server’s firewall to allow connections to port 5901, as that would allow anyone to access your server over VNC. By connecting over an SSH tunnel, you’re limiting VNC access to machines that already have SSH access to the server. If you are using PuTTY to connect to your server, you can create an SSH tunnel by right-clicking on the top bar of the terminal window, and then clicking the Change Settings… option: Find the Connection branch in the tree menu on the left-hand side of the PuTTY Reconfiguration window. Expand the SSH branch and click on Tunnels. On the Options controlling SSH port forwarding screen, enter 59000 as the Source Port and localhost:5901 as the Destination, like this: Then click the Add button, and then the Apply button to implement the tunnel. Once the tunnel is running, use a VNC client to connect to localhost:59000. You’ll be prompted to authenticate using the password you set in Step 1. Once you are connected, you’ll see the default Xfce desktop. It should look something like this: You can access files in your home directory with the file manager or from the command line, as seen here: Press CTRL+C in your local terminal to stop the SSH tunnel and return to your prompt. This will disconnect your VNC session as well. Now you can configure your VNC server to run as a systemd service. ","date":"2024-02-25","objectID":"/vnc-on-ubuntu-20.04/:3:0","tags":["linux","vnc"],"title":"How to Install and Configure VNC on Ubuntu 20.04","uri":"/vnc-on-ubuntu-20.04/"},{"categories":["linux"],"content":"Step 4 — Running VNC as a System Service By setting up the VNC server to run as a systemd service you can start, stop, and restart it as needed, like any other service. You can also use systemd’s management commands to ensure that VNC starts when your server boots up. First, create a new unit file called /etc/systemd/system/vncserver@.service: sudo nano /etc/systemd/system/vncserver@.service The @ symbol at the end of the name will let us pass in an argument you can use in the service configuration. You’ll use this to specify the VNC display port you want to use when you manage the service. Add the following lines to the file. Be sure to change the value of User, Group, WorkingDirectory, and the username in the value of PIDFILE to match your username: /etc/systemd/system/vncserver@.service [Unit] Description=Start TightVNC server at startup After=syslog.target network.target [Service] Type=forking User=sammy Group=sammy WorkingDirectory=/home/sammy PIDFile=/home/sammy/.vnc/%H:%i.pid ExecStartPre=-/usr/bin/vncserver -kill :%i \u003e /dev/null 2\u003e\u00261 ExecStart=/usr/bin/vncserver -depth 24 -geometry 1280x800 -localhost :%i ExecStop=/usr/bin/vncserver -kill :%i [Install] WantedBy=multi-user.target The ExecStartPre command stops VNC if it’s already running. The ExecStart command starts VNC and sets the color depth to 24-bit color with a resolution of 1280x800. You can modify these startup options as well to meet your needs. Also, note that the ExecStart command again includes the -localhost option. Save and close the file. Next, make the system aware of the new unit file: sudo systemctl daemon-reload Enable the unit file: sudo systemctl enable vncserver@1.service The 1 following the @ sign signifies which display number the service should appear over, in this case the default :1 as was discussed in Step 2. Stop the current instance of the VNC server if it’s still running: vncserver -kill :1 Then start it as you would start any other systemd service: sudo systemctl start vncserver@1 You can verify that it started with this command: sudo systemctl status vncserver@1 If it started correctly, the output should look like this: Output● vncserver@1.service - Start TightVNC server at startup Loaded: loaded (/etc/systemd/system/vncserver@.service; enabled; vendor preset: enabled) Active: active (running) since Thu 2020-05-07 17:23:50 UTC; 6s ago Process: 39768 ExecStartPre=/usr/bin/vncserver -kill :1 \u003e /dev/null 2\u003e\u00261 (code=exited, status=2) Process: 39772 ExecStart=/usr/bin/vncserver -depth 24 -geometry 1280x800 :1 (code=exited, status=0/SUCCESS) Main PID: 39795 (Xtightvnc) ... Your VNC server is now ready to use whenever your server boots up, and you can manage it with systemctl commands like any other systemd service. However, there won’t be any difference on the client side. To reconnect, start your SSH tunnel again: ssh -L 59000:localhost:5901 -C -N -l sammy your_server_ip Then make a new connection using your VNC client software to localhost:59000 to connect to your server. ","date":"2024-02-25","objectID":"/vnc-on-ubuntu-20.04/:4:0","tags":["linux","vnc"],"title":"How to Install and Configure VNC on Ubuntu 20.04","uri":"/vnc-on-ubuntu-20.04/"},{"categories":["linux"],"content":"Conclusion You now have a secured VNC server up and running on your Ubuntu 20.04 server. Now you’ll be able to manage your files, software, and settings with a user-friendly graphical interface, and you’ll be able to run graphical software like web browsers remotely. ","date":"2024-02-25","objectID":"/vnc-on-ubuntu-20.04/:5:0","tags":["linux","vnc"],"title":"How to Install and Configure VNC on Ubuntu 20.04","uri":"/vnc-on-ubuntu-20.04/"},{"categories":["linux"],"content":"解决灰屏问题 vnc连接以后桌面打开是灰的，没有图标和terminal sudo apt-get install gnome-panel 打开并编辑xstartup文件，将如下代码复制到xstartup文件中，替换原代码： #!/bin/sh unset SESSION_MANAGER unset DBUS_SESSION_BUS_ADDRESS export XKL_XMODMAP_DISABLE=1 export XDG_CURRENT_DESKTOP=\"GNOME-Flashback:GNOME\" export XDG_MENU_PREFIX=\"gnome-flashback-\" [ -x /etc/vnc/xstartup ] \u0026\u0026 exec /etc/vnc/xstartup [ -r $HOME/.Xresources ] \u0026\u0026 xrdb $HOME/.Xresources xsetroot -solid grey vncconfig -iconic \u0026 #gnome-terminal \u0026 #nautilus \u0026 gnome-session --session=gnome-flashback-metacity --disable-acceleration-check \u0026 关闭源端口，重新开启vnc端口，即可正常访问 ","date":"2024-02-25","objectID":"/vnc-on-ubuntu-20.04/:5:1","tags":["linux","vnc"],"title":"How to Install and Configure VNC on Ubuntu 20.04","uri":"/vnc-on-ubuntu-20.04/"},{"categories":["linux"],"content":"Ref https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-20-04 ","date":"2024-02-25","objectID":"/vnc-on-ubuntu-20.04/:6:0","tags":["linux","vnc"],"title":"How to Install and Configure VNC on Ubuntu 20.04","uri":"/vnc-on-ubuntu-20.04/"},{"categories":["Papers"],"content":"在知乎上看到生物信息学领域的牛刊投稿顺序，发现一个很有趣的回答，于是转载一下作为参考： 凡人期：这是修仙之路的起点，指的是还未开始修炼或刚刚接触修炼之道的普通研究生。 arXiv，bioRxiv 练气期：这是修仙的基础阶段，研究生修行者开始吸收天地灵气，将其转化为体内的元力。 BMC genomics，BMC bioinformatics，BMC biology，BMC medical genomics 筑基期：这是研究生修仙之路的起点，修行者开始修炼内功，累积内力，打下坚实的基础。 Bioinformatics，PLoS computational biology，PLoS genetics，Briefings in bioinformatics，BMC medicine 金丹期：修行者的内力能够凝聚成金丹，这个金丹象征着高级别的修为和力量。 Nucleic Acids Research，eBiomedicine，Advanced Science，PLoS Biology 元婴期：修行者的金丹形成元婴，元婴是修行者灵魂和修为的化身，跨入更高的境界。 Genome Biology，Genome Medicine，Genome Research，Molecular Systems Biology，Cell systems 化神期：修行者的元婴进一步成长，开始向神灵的境界转变。 Nature Communications，PNAS，Science Advances，Cell Reports 合体期：修行者的身体和灵魂开始与周围的世界融合，接近于自然（Nature）的本源。 Nature Machine Intelligence，Nature Computational Sciences 大乘期：修行者几乎达到了仙道的巅峰，具备了创造或改变世界的能力。 Nature Genetics，Nature Biotechnology，Nature Methods，Nature Medicine，Cell Genomics 飞升期：修行者完成了修仙之路，失去凡体，飞升仙界，无相无形，成为自然（Nature）。 Nature，Science，Cell Acknowledgement: 作者：浪矢Ryan 链接：https://www.zhihu.com/question/21660698/answer/3310893434 来源：知乎 ","date":"2024-02-25","objectID":"/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E9%A2%86%E5%9F%9F%E7%89%9B%E5%88%8A/:0:0","tags":["bioinformatics"],"title":"生物信息领域牛刊修仙版","uri":"/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E9%A2%86%E5%9F%9F%E7%89%9B%E5%88%8A/"},{"categories":["system"],"content":"近期因为工作需求和提高用户友好度的考量需要对软件进行Docker打包，于是总结以下简易流程。 拉取镜像，如果需要预先配置好CUDA等，可以搜索对应镜像： docker pull nvidia/cuda:12.2.2-cudnn8-devel-ubuntu22.04 进入镜像，修改软件配置环境等： docker run --gpus all -it nvidia/cuda:12.2.2-cudnn8-devel-ubuntu22.04 /bin/bash apt-get update \u0026\u0026 apt-get install -y wget nano vim curl less 安装Conda环境以及其它需要的软件 curl -O https://repo.anaconda.com/archive/Anaconda3-2023.09-0-Linux-x86_64.sh bash Anaconda3-2023.09-0-Linux-x86_64.sh 新建repository https://hub.docker.com/repository/ 用docker commit从容器打包镜像 sudo docker ps -a sudo docker commit -m \"AutoBA\" -a \"juexiao_zhou (www.joshuachou.ink)\" 12748b01449a joshuachou666/autoba:cuda12.2.2-cudnn8-devel-ubuntu22.04-autoba0.0.3 然后docker images就能在本地找到打包好的镜像 上传镜像 # sudo docker login --username=用户名 sudo docker login --username=admin # sudo docker push 镜像tag sudo docker push joshuachou666/autoba:cuda12.2.2-cudnn8-devel-ubuntu22.04-autoba0.0.3 重新拉取镜像测试 docker pull joshuachou666/autoba:cuda12.2.2-cudnn8-devel-ubuntu22.04-autoba0.0.3 docker run --rm --gpus all -it joshuachou666/autoba:cuda12.2.2-cudnn8-devel-ubuntu22.04-autoba0.0.3 /bin/bash FQA –gpu all参数不能使用，错误：could not select device driver \"\" with capabilities: [[gpu]] curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \\ sudo apt-key add - distribution=$(. /etc/os-release;echo $ID$VERSION_ID) curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \\ sudo tee /etc/apt/sources.list.d/nvidia-docker.list sudo apt-get update sudo apt install -y nvidia-docker2 sudo systemctl daemon-reload sudo systemctl restart docker 运行上述代码后，重新docker run –gpus all即可 安装完Conda环境之后，在当前的shell中不能使用conda命令和激活环境，但是又不想exit export PATH=\"/root/anaconda3/bin:$PATH\" . \"/root/anaconda3/etc/profile.d/conda.sh\" invalid reference format error when using docker commit This is because image names can only consist of lowercase (a-z) characters [REPOSITORY[:TAG]] ","date":"2023-12-21","objectID":"/docker%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F%E4%BF%AE%E6%94%B9%E6%89%93%E5%8C%85%E6%95%99%E7%A8%8B/:0:0","tags":["linux","system"],"title":"docker拉取镜像修改打包教程","uri":"/docker%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F%E4%BF%AE%E6%94%B9%E6%89%93%E5%8C%85%E6%95%99%E7%A8%8B/"},{"categories":["system"],"content":" 获取IP地址 sudo apt install net-tools ifconfig 安装openssh，这样可以远程ssh连接服务器 sudo apt install openssh-server 安装gcc sudo apt install gcc g++ make 安装NVIDIA驱动 在https://www.nvidia.com/Download/index.aspx?lang=cn下载对应型号驱动 wget https://cn.download.nvidia.com/XFree86/Linux-x86_64/535.104.05/NVIDIA-Linux-x86_64-535.104.05.run 禁用nouveau sudo nano /etc/modprobe.d/blacklist.conf # 最后一行加入 blacklist nouveau sudo update-initramfs -u sudo reboot 检查nouveau是否不在运行 lsmod | grep nouveau # 没输出代表禁用生效 sudo telinit 3 安装驱动 sudo chmod a+x NVIDIA-Linux-x86_64-535.104.05.run sudo sh ./NVIDIA-Linux-x86_64-535.104.05.run --no-opengl-files –no-opengl-files 参数必须加否则会循环登录，也就是loop login 安装CUDA 11.1 wget https://developer.download.nvidia.com/compute/cuda/11.1.0/local_installers/cuda_11.1.0_455.23.05_linux.run sudo chmod a+x cuda_11.1.0_455.23.05_linux.run # 勾选的时候不要再安装NVIDIA驱动 弹出xorg.conf时选择NO sudo sh cuda_11.1.0_455.23.05_linux.run nano ~/.bashrc # 添加以下两行 export PATH=/usr/local/cuda-11.1/bin:$PATH export LD_LIBRARY_PATH=/usr/local/cuda-11.1/lib64:$LD_LIBRARY_PATH source ~/.bashrc # 测试cuda nvcc -V 安装anaconda wget https://repo.anaconda.com/archive/Anaconda3-2023.07-2-Linux-x86_64.sh bash Anaconda3-2023.07-2-Linux-x86_64.sh # Do you wish the installer to initialize Anaconda3 by running conda init? [yes|no] yes 到这一步就已经完成了，Cheers！ ","date":"2023-09-10","objectID":"/%E5%85%A8%E6%96%B0ubuntu18.04%E9%85%8D%E7%BD%AEdl%E7%8E%AF%E5%A2%83/:0:0","tags":["linux","system"],"title":"全新Ubuntu18.04配置DL环境，保姆级教程","uri":"/%E5%85%A8%E6%96%B0ubuntu18.04%E9%85%8D%E7%BD%AEdl%E7%8E%AF%E5%A2%83/"},{"categories":["news"],"content":"We are happy to announce the SkinGPT-4: An Interactive Dermatology Diagnostic System with Visual Large Language Model Skin and subcutaneous diseases rank high among the leading contributors to the global burden of nonfatal diseases, impacting a considerable portion of the population. Nonetheless, the field of dermatology diagnosis faces three significant hurdles. Firstly, there is a shortage of dermatologists accessible to diagnose patients, particularly in rural regions. Secondly, accurately interpreting skin disease images poses a considerable challenge. Lastly, generating patient-friendly diagnostic reports is usually a time-consuming and labor-intensive task for dermatologists. To tackle these challenges, we present SkinGPT-4, which is the world’s first interactive dermatology diagnostic system powered by an advanced visual large language model. SkinGPT-4 leverages a fine-tuned version of MiniGPT-4, trained on an extensive collection of skin disease images (comprising 52,929 publicly available and proprietary images) along with clinical concepts and doctors’ notes. We designed a two-step training process to allow SkinGPT-4 to express medical features in skin disease images with natural language and make accurate diagnoses of the types of skin diseases. With SkinGPT-4, users could upload their own skin photos for diagnosis, and the system could autonomously evaluate the images, identifies the characteristics and categories of the skin conditions, performs in-depth analysis, and provides interactive treatment recommendations. Meanwhile, SkinGPT-4’s local deployment capability and commitment to user privacy also render it an appealing choice for patients in search of a dependable and precise diagnosis of their skin ailments. To demonstrate the robustness of SkinGPT-4, we conducted quantitative evaluations on 150 real-life cases, which were independently reviewed by certified dermatologists, and showed that SkinGPT-4 could provide accurate diagnoses of skin diseases. Though SkinGPT-4 is not a substitute for doctors, it could enhance users’ comprehension of their medical conditions, facilitate improve communication between patients and doctors, expedite the diagnostic process for dermatologists, and potentially promote human-centred care and healthcare equity in underdeveloped areas. For manuscript, please check: https://arxiv.org/abs/2304.10691 Fig 1: Illustration of SkinGPT-4. SkinGPT-4 incorporates a fine-tuned version of MiniGPT-4 on a vast collection (52,929) of both public and in-house skin disease images, accompanied by clinical concepts and doctors’ notes. With SkinGPT-4, users could upload their own skin photos for diagnosis, and SkinGPT-4 could autonomously determine the characteristics and categories of skin conditions, perform analysis, provide treatment recommendations, and allow interactive diagnosis. On the right is an example of interactive diagnosis. Fig2: Illustration of our datasets for two-step training of SkinGPT-4. The notes below each image indicate clinical concepts and types of skin diseases. In addition, we have detailed descriptions from the certified dermatologists for images in the step 2 dataset. To avoid causing discomfort, we used a translucent grey box to obscure the displayed skin disease images. Fig 3: Diagnosis generated by SkinGPT-4, SkinGPT-4 (step 1 only), SkinGPT-4 (step 2 only), MiniGPT-4 and Dermatologists. Fig 4: Clinical evaluation of SkinGPT-4 by certified offline and online dermatologists. ","date":"2023-06-12","objectID":"/news-skingpt-4/:0:0","tags":["news"],"title":"[NEWS] A recent project: SkinGPT-4: An Interactive Dermatology Diagnostic System with Visual Large Language Model","uri":"/news-skingpt-4/"},{"categories":["system"],"content":"**问题描述：**近期在Gradio开发的时候，发现自己服务器搭建的http无法在Chrome下开启麦克风和摄像头 解决方案： 在浏览器地址栏中输入“chrome://flags/#unsafely-treat-insecure-origin-as-secure”，回车 该选项置为Enabled 在输入框中输入需要访问的地址，多个地址使用“,”隔开 然后点击右下角弹出的Relaunch按钮 重启浏览器之后就可以在添加的http地址下调用摄像头和麦克风了 ","date":"2023-06-12","objectID":"/chrome-%E8%A7%A3%E5%86%B3%E5%9C%A8http%E5%8D%8F%E8%AE%AE%E4%B8%8B%E6%97%A0%E6%B3%95%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E5%92%8C%E9%BA%A6%E5%85%8B%E9%A3%8E%E7%9A%84%E9%97%AE%E9%A2%98/:0:0","tags":["system"],"title":"chrome 解决在http协议下无法调用摄像头和麦克风的问题","uri":"/chrome-%E8%A7%A3%E5%86%B3%E5%9C%A8http%E5%8D%8F%E8%AE%AE%E4%B8%8B%E6%97%A0%E6%B3%95%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E5%92%8C%E9%BA%A6%E5%85%8B%E9%A3%8E%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["system"],"content":"问题描述 Mac更新后无法使用任何Apple服务，比如无法退出Apple ID，无法进入Apple Store，但是其它网络连接均正常。 ","date":"2023-05-04","objectID":"/mac%E6%9B%B4%E6%96%B0%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5apple%E6%89%80%E6%9C%89%E6%9C%8D%E5%8A%A1/:0:1","tags":["system","macOS","internet"],"title":"Mac更新后无法连接Apple所有服务","uri":"/mac%E6%9B%B4%E6%96%B0%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5apple%E6%89%80%E6%9C%89%E6%9C%8D%E5%8A%A1/"},{"categories":["system"],"content":"解决方案 打开/Library/Preferences/SystemConfiguration 这个文件夹 删除除了com.apple.Boot.plist 之外的其他文件，然后重新启动 ","date":"2023-05-04","objectID":"/mac%E6%9B%B4%E6%96%B0%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5apple%E6%89%80%E6%9C%89%E6%9C%8D%E5%8A%A1/:0:2","tags":["system","macOS","internet"],"title":"Mac更新后无法连接Apple所有服务","uri":"/mac%E6%9B%B4%E6%96%B0%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5apple%E6%89%80%E6%9C%89%E6%9C%8D%E5%8A%A1/"},{"categories":["system"],"content":"参考 https://blog.csdn.net/weixin_51524504/article/details/119487457 ","date":"2023-03-07","objectID":"/ubuntu18.04%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E7%99%BB%E9%99%86%E9%97%AE%E9%A2%98%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98%E5%8F%8A%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:0:0","tags":["system","linux","internet"],"title":"ubuntu18.04安装后的登陆问题、卡顿问题及基本环境配置","uri":"/ubuntu18.04%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E7%99%BB%E9%99%86%E9%97%AE%E9%A2%98%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98%E5%8F%8A%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":["system"],"content":"今天Cisco Anyconnect莫名奇妙用不了，重新安装却提示安装器错误，于是找到了Openconnect这个替代品 下面说下Openconnect安装方法： 命令行模式: brew install openconnect GUI模式: brew install openconnect-gui --cask 安装完之后, 发现GUI打不开, 提示来自不被信任的开发者, 这个时候需要我们开启权限允许所有来源的软件: sudo spctl --master-disable ","date":"2023-01-03","objectID":"/macos%E4%B8%8A%E4%BD%BF%E7%94%A8openconnect%E4%BB%A3%E6%9B%BFcisco-anyconnect/:0:0","tags":["system","linux","internet"],"title":"macOS上使用Openconnect代替Cisco Anyconnect","uri":"/macos%E4%B8%8A%E4%BD%BF%E7%94%A8openconnect%E4%BB%A3%E6%9B%BFcisco-anyconnect/"},{"categories":["system"],"content":"之前使用命令行安装： brew install cmake 安装的是最新版，安装速度也很快，但是这个cmake是不带 GUI的，用着不习惯，就又一个命令行给卸载了。 brew uninstall cmake 然后手动安装cmake，去官网下载。 网址：https://cmake.org/download/ 下载框线这个，可能因为时间段问题，晚上下载只有几kb/s，然后就放弃了，早上下载几MB/s。 下载完成后直接双击安装。双击会出现这个界面，直接将cmake图标拖到右边Application文件夹中，这样就可以在launcher中找到cmake了。 这个样可以从laucher中找到cmake并使用，但是命令行还是查不到cmake,也不能使用cmake。 安装完成之后，使用以下指令创建/usr/local/bin下 CMake 的软链接。 sudo \"/Applications/CMake.app/Contents/bin/cmake-gui\" --install 查看版本： cmake --version Ref: https://www.cnblogs.com/juluwangshier/p/12987258.html ","date":"2022-12-30","objectID":"/macos-cmake-gui/:0:0","tags":["system","linux","conda","python"],"title":"macos cmake-gui","uri":"/macos-cmake-gui/"},{"categories":["system"],"content":"1，Help -\u003e Find Action -\u003e (输入 “VM”) -\u003e (点击)“Edit Custom VM options” 2，Pycharm会在编辑器中打开适当的vmoptions文件（pycharm.vmoptions或pycharm64.options）。 3，将**-Xms**属性的值修改为你想要的结果，然后保存 -Xmx750m 增加到 -Xmx1024m 4，重启Pycharm ","date":"2022-12-21","objectID":"/pycharm%E5%A2%9E%E5%8A%A0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/:0:0","tags":["system","linux","conda","python"],"title":"pycharm增加运行时内存","uri":"/pycharm%E5%A2%9E%E5%8A%A0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/"},{"categories":["system"],"content":" conda create -n p37 python==3.7 wget https://github.com/TylerGubala/blenderpy/releases/download/v2.91a0/bpy-2.91a0-cp37-cp37m-manylinux2014_x86_64.whl pip install bpy-2.91a0-cp37-cp37m-manylinux2014_x86_64.whl \u0026\u0026 bpy_post_install ","date":"2022-10-06","objectID":"/blender-python/:0:0","tags":["system","linux","conda","python"],"title":"python安装blender包bpy","uri":"/blender-python/"},{"categories":["system"],"content":"When setting jupyter interpreter in pycharm, it may throw the error: jupyter URL is invalid Solution: Even without a token, use the url: http://url:port?token= Then it works ","date":"2022-10-03","objectID":"/pycharm-jupyter/:0:0","tags":["system","linux","conda","python"],"title":"jupyter in pycharm","uri":"/pycharm-jupyter/"},{"categories":["python"],"content":" 相信大家对numpy, Tensorflow, Pytorch已经极其熟悉，不过，你知道JAX吗？ JAX发布之后，有网友进行了测试，发现，使用JAX，Numpy运算可以快三十多倍！ 下面是使用Numpy的运行情况： import numpy as np # 使用标准numpy，运算将在CPU上执行。 x = np.random.random([5000, 5000]).astype(np.float32) %timeit np.matmul(x, x) 运行结果： 1 loop, best of 3: 3.9 s per loop 而下面是使用JAX的Numpy的情况： import jax.numpy as np # 使用\"JAX版\"的numpy from jax import random # 注意JAX下随机数API有所不同 x = random.uniform(random.PRNGKey(0), [5000, 5000]) %timeit np.matmul(x, x) 运行情况： 1 loop, best of 3: 109 ms per loop 我们可以发现，使用原始numpy，运行时间大概为3.9s，而使用JAX的numpy，运行时间仅仅只有0.109s，速度上直接提升了三十多倍！ 是不是很神奇？ 那JAX到底是什么？ JAX是谷歌开源的、可以在CPU、GPU和TPU上运行的numpy，是针对机器学习研究的高性能自微分计算框架。 简单来说，就是GPU和TPU加速、支持自动微分(autodiff)的numpy。 快速入门链接：https://jax.readthedocs.io/en/latest/notebooks/quickstart.html 我们都知道，numpy是Python下的基础数值运算库，应用非常广泛，如果要用Python进行科学计算或者机器学习，没人能够离得了它。 但是，numpy并不支持GPU或者其他硬件加速器，也缺少对backpropagation的内置支持，此外，Python自身也有速度限制， 因此，在生产环境下使用numpy训练或者部署深度学习模型的人很少。 不过numpy也有它独特的魅力：底层、灵活、调试方便、API稳定且为大家所熟悉，从而深受研究者的喜爱。 而JAX的主要出发点就是将numpy的以上优势与硬件加速结合，与依赖于预编译核和快速C++代码的Pytorch相比，JAX可以让我们能够在高级接口使用自己最喜欢的加速器进行编写。 在最高层，JAX结合了XLA\u0026Autograd，来加速用户开发的基于线性代数的项目。 Github项目地址：https://github.com/google/jax 此外，入门JAX的过程非常自然简单——许多人每天都在处理numpy的语法和规定，而JAX则大大减少了用户的这些烦恼。 目前，JAX支持在Linux (Ubuntu 16.04或更高版本)和macOS(10.12或更高版本)平台上安装或构建，Windows用户可以通过Windows的Linux子系统在CPU和GPU上使用JAX。 参考链接： https://roberttlange.github.io/posts/2021/02/cma-es-jax/ https://roberttlange.github.io/posts/2020/03/blog-post-10/ https://jax.readthedocs.io/en/latest/notebooks/quickstart.html https://www.zhihu.com/question/306496943/answer/1041519580 转载自https://developer.aliyun.com/article/853693 ","date":"2022-09-29","objectID":"/%E8%BD%AC%E8%BD%BD-%E8%B0%B7%E6%AD%8C%E5%BC%80%E6%BA%90%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6jax/:0:0","tags":["numpy"],"title":"[转载] 谷歌开源计算框架JAX”","uri":"/%E8%BD%AC%E8%BD%BD-%E8%B0%B7%E6%AD%8C%E5%BC%80%E6%BA%90%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6jax/"},{"categories":["privacy"],"content":" 同态加密是密码学领域自1978年以来的经典难题，也是实现数据隐私计算的关键技术，在云计算、区块链、隐私计算等领域均存在着广泛的应用需求和一些可行的应用方案。 本文首先介绍同态加密的基本概念、研究进展以及标准化进展，然后对主流的乘法/加法半同态加密算法和全同态加密算法及其工程实现情况进行概述，最后对同态加密在各领域的应用场景进行分析。 ","date":"2022-09-20","objectID":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/:0:0","tags":["privacy","encryption"],"title":"[转载] 同态加密：实现数据的“可算不可见”","uri":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/"},{"categories":["privacy"],"content":"一、同态加密概述 ","date":"2022-09-20","objectID":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/:1:0","tags":["privacy","encryption"],"title":"[转载] 同态加密：实现数据的“可算不可见”","uri":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/"},{"categories":["privacy"],"content":"1、基本概念 同态加密（Homomorphic Encryption, HE）是指满足密文同态运算性质的加密算法，即数据经过同态加密之后，对密文进行特定的计算，得到的密文计算结果在进行对应的同态解密后的明文等同于对明文数据直接进行相同的计算，实现数据的“可算不可见”。同态加密的实现效果如图1所示。 图1：同态加密原理 如果一种同态加密算法支持对密文进行任意形式的计算，则称其为全同态加密（Fully Homomorphic Encryption, FHE）；如果支持对密文进行部分形式的计算，例如仅支持加法、仅支持乘法或支持有限次加法和乘法，则称其为半同态加密或部分同态加密，英文简称为SWHE（Somewhat Homomorphic Encryption）或PHE（Partially Homomorphic Encryption）。一般而言，由于任意计算均可通过加法和乘法构造，若加密算法同时满足加法同态性和乘法同态性，则可称其满足全同态性。 目前，同态加密算法已在区块链、联邦学习等存在数据隐私计算需求的场景实现了落地应用。由于全同态加密仍处于方案探索阶段，现有算法存在运行效率低、密钥过大和密文爆炸等性能问题，在性能方面距离可行工程应用还存在一定的距离。因此，实际应用中的同态加密算法多选取半同态加密（如加法同态），用于在特定应用场景中实现有限的同态计算功能。 ","date":"2022-09-20","objectID":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/:1:1","tags":["privacy","encryption"],"title":"[转载] 同态加密：实现数据的“可算不可见”","uri":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/"},{"categories":["privacy"],"content":"2、研究进展 1978年，Rivest、Adleman（“RSA”中的“R”和“A”）和Dertouzos提出了全同态加密的构想[1]，自此成为了密码学研究领域的一个公开难题。目前，同态加密算法主要分为半同态加密和全同态加密两大类。半同态加密主要包括以RSA算法[2]和ElGamal算法[3]为代表的乘法同态加密、以Paillier算法[4]为代表的加法同态加密以及以Boneh-Goh-Nissim方案[5]为代表的有限次数全同态加密；全同态加密算法主要包括以Gentry方案[6][7]为代表的第一代方案、以BGV方案[8]和BFV方案[9][10]为代表的第二代方案、以GSW方案[11]为代表的第三代方案以及支持浮点数近似计算的CKKS方案[12]等等。上述方案及其基本特性和应用情况总览如表1所示。 表1：各类同态加密算法 *类型* *算法* *时间* *说明* *实际应用* 半同态加密 乘法同态 RSA算法 1977 非随机化加密，具有乘法同态性的原始算法面临选择明文攻击 在非同态场景中应用广泛 ElGamal算法 1985 随机化加密 DSS数字签名标准基于ElGamal数字签名算法的变体 加法同态 Paillier算法 1999 应用最为成熟 联邦学习 有限次数全同态 Boneh-Goh-Nissim方案 2005 仅支持1次乘法同态运算 / 全同态加密 Gentry方案 2009 第一代全同态加密，性能较差 / BGV方案 2012 第二代全同态加密，性能相对较好 IBM HElib开源库 BFV方案 2012 第二代全同态加密，与BGV类似 微软SEAL开源库 GSW方案 2013 第三代全同态加密，基于近似特征向量 TFHE开源库 CKKS方案 2017 可实现浮点数近似计算，适合机器学习建模场景 HElib和SEAL ","date":"2022-09-20","objectID":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/:1:2","tags":["privacy","encryption"],"title":"[转载] 同态加密：实现数据的“可算不可见”","uri":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/"},{"categories":["privacy"],"content":"3、标准化进展 （1）半同态加密标准化 2019年5月，国际标准化组织ISO发布了同态加密标准（ISO/IEC 18033-6:2019）。该标准仅涉及半同态加密，具体包含两种较为成熟的半同态加密机制：ElGamal乘法同态加密和Paillier加法同态加密，并规定了参与实体的参数和密钥生成、数据加密、密文数据解密、密文数据同态运算等步骤的具体过程。 （2）全同态加密标准化 2017年7月，来自学术界、工业界和政界的相关领域研究人员组成了全同态加密标准化开放联盟HomomorphicEncryption.org，在微软研究院举办了首届全同态加密标准化研讨会，开始共同推进全同态加密标准草案的编写工作，并发布了全同态加密安全标准、API标准、应用标准三份白皮书。迄今为止，HomomorphicEncryption.org在三年内已举办五届全同态加密标准化会议，参与成员包括微软、三星SDS、英特尔、IBM、谷歌、万事达卡等企业，以及NIST、ITU等机构的代表和各大高校的学者。在标准化进展方面，HomomorphicEncryption.org已分别于2018年3月和11月发布和更新了全同态加密标准草案。 ","date":"2022-09-20","objectID":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/:1:3","tags":["privacy","encryption"],"title":"[转载] 同态加密：实现数据的“可算不可见”","uri":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/"},{"categories":["privacy"],"content":"二、主流同态加密算法原理 ","date":"2022-09-20","objectID":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/:2:0","tags":["privacy","encryption"],"title":"[转载] 同态加密：实现数据的“可算不可见”","uri":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/"},{"categories":["privacy"],"content":"1、半同态加密算法 满足有限运算同态性而不满足任意运算同态性的加密算法称为半同态加密。典型的半同态加密特性包括乘法同态、加法同态、有限次数全同态等。 （1）乘法同态加密算法 在实际应用中，密文乘法同态性的需求场景不多，因此乘法同态性通常偶然存在于已有的经典加密算法中。满足乘法同态特性的典型加密算法包括1977年提出的RSA公钥加密算法和1985年提出的ElGamal公钥加密算法等。 ① RSA算法 RSA算法是最为经典的公钥加密算法，至今已有40余年的历史，其安全性基于大整数分解困难问题。在实际应用中，RSA算法可采用RSA_PKCS1_PADDING、RSA_PKCS1_OAEP_PADDING等填充模式，根据密钥长度（常用1024位或2048位）对明文分组进行填充，而只有不对明文进行填充的原始RSA算法才能满足乘法同态特性。由于原始的RSA不是随机化加密算法，即加密过程中没有使用随机因子，每次用相同密钥加密相同明文的结果是固定的。因此，利用RSA的乘法同态性实现同态加密运算会存在安全弱点，攻击者可能通过选择明文攻击得到原始数据。 ② ElGamal算法 ElGamal算法是一种基于Diffie-Hellman离散对数困难问题的公钥密码算法，可实现公钥加密和数字签名功能，同时满足乘法同态特性。ElGamal是一种随机化加密算法，即使每次用相同密钥加密相同明文得到的密文结果也不相同，因此不存在与RSA算法类似的选择明文攻击问题，是ISO同态加密国际标准中唯一指定的乘法同态加密算法。 （2）加法同态加密算法 Paillier算法是1999年提出的一种基于合数剩余类问题的公钥加密算法，也是目前最为常用且最具实用性的加法同态加密算法，已在众多具有同态加密需求的应用场景中实现了落地应用，同时也是ISO同态加密国际标准中唯一指定的加法同态加密算法。此外，由于支持加法同态，所以Paillier算法还可支持数乘同态，即支持密文与明文相乘。 （3）有限全同态加密算法 2005年提出的Boneh-Goh-Nissim方案是一种基于双线性映射的公钥密码方案，支持任意次加法同态和一次乘法同态运算。方案中的加法同态基于类似Paillier算法的思想，而一次乘法同态基于双线性映射的运算性质。由于双线性映射运算会使得密文所在的群发生变化，因此仅能支持一次乘法同态运算，但仍支持对乘法后的密文进一步作加法同态运算。 ","date":"2022-09-20","objectID":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/:2:1","tags":["privacy","encryption"],"title":"[转载] 同态加密：实现数据的“可算不可见”","uri":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/"},{"categories":["privacy"],"content":"2、全同态加密算法 满足任意运算同态性的加密算法称为全同态加密。由于任何计算都可以通过加法和乘法门电路构造，所以加密算法只要同时满足乘法同态和加法同态特性就称其满足全同态特性。 （1）主流算法 全同态加密算法的发展起源于2009年Gentry提出的方案，后续方案大多基于格代数结构构造。目前已在主流同态加密开源库中得到实现的全同态加密算法包括BGV方案、BFV方案、CKKS方案等。 ① 第一代全同态加密方案——Gentry方案 Gentry方案是一种基于电路模型的全同态加密算法，支持对每个比特进行加法和乘法同态运算。Gentry方案的基本思想是构造支持有限次同态运算的同态加密算法并引入“Bootstrapping”方法控制运算过程中的噪音增长，这也是第一代全同态加密方案的主流模型。 “Bootstrapping”方法通过将解密过程本身转化为同态运算电路，并生成新的公私钥对对原私钥和含有噪音的原密文进行加密，然后用原私钥的密文对原密文的密文进行解密过程的同态运算，即可得到不含噪音的新密文。但是，由于解密过程本身的运算十分复杂，运算过程中也会产生大量噪音，为了给必要的同态运算需求至少预留足够进行一次乘法运算的噪音增长空间，需要对预先解密电路进行压缩简化，即将解密过程的一些操作尽量提前到加密时完成。 ② 第二代全同态加密方案——BGV/BFV方案 Gentry方案之后的第二代全同态加密方案通常基于LWE/RLWE假设，其安全性基于代数格上的困难问题，典型方案包括BGV方案和BFV方案等。 BGV（Brakerski-Gentry-Vaikuntanathan）方案是目前主流的全同态加密算法中效率最高的方案。在BGV方案中，密文和密钥均以向量表示，而密文的乘积和对应的密钥乘积则为张量，因此密文乘法运算会造成密文维数的爆炸式增长，导致方案只能进行常数次的乘法运算。BGV方案采用密钥交换技术控制密文向量的维数膨胀，在进行密文计算后通过密钥交换将膨胀的密文维数恢复为原密文的维数。同时，BGV方案可采用模交换技术替代Gentry方案中的“Bootstrapping”过程，用于控制密文同态运算产生的噪声增长，而不需要通过复杂的解密电路实现。因此，在每次进行密文乘法运算后，首先需要通过密钥交换技术降低密文的维数，然后通过模交换技术降低密文的噪声，从而能够继续进行下一次计算。 BFV（Brakerski/Fan-Vercauteren）方案是与BGV方案类似的另一种第二代全同态加密方案，同样可基于LWE和RLWE构造。BFV方案不需要通过模交换进行密文噪声控制，但同样需要通过密钥交换解决密文乘法带来的密文维数膨胀问题。 目前，最为主流的两个全同态加密开源库HElib和SEAL分别实现了BGV方案和BFV方案。 ③ 第三代全同态加密方案——GSW方案 GSW（Gentry-Sahai-Waters）方案是一种基于近似特征向量的全同态加密方案。该方案基于LWE并可推广至RLWE，但其的性能不如BGV方案等其他基于RLWE的方案。GSW方案的密文为矩阵的形式，而矩阵相乘并不会导致矩阵维数的改变，因此GSW方案解决了以往方案中密文向量相乘导致的密文维数膨胀问题，无需进行用于降低密文维数的密钥交换过程。 ④ 浮点数全同态加密方案——CKKS方案 CKKS（Cheon-Kim-Kim-Song）方案是2017年提出的一种新方案，支持针对实数或复数的浮点数加法和乘法同态运算，得到的计算结果为近似值，适用于机器学习模型训练等不需要精确结果的场景。由于浮点数同态运算在特定场景的必要性，HElib和SEAL两个全同态加密开源库均支持了CKKS方案。 （2）工程实现 虽然现有的全同态加密算法在工程实现性能方面存在一定的局限性，但仍有世界顶尖的科技公司对全同态加密进行了开源实现。目前，最为主流的全同态加密算法开源工具包括IBM主导的HElib库和微软主导的SEAL库。 ① HElib HElib是一个基于C++语言的同态加密开源软件库，底层依赖于NTL数论运算库和GMP多精度运算库实现，主要开发者为IBM的Halevi，目前最新版本为1.0.2，实现了支持“Bootstrapping”的BGV方案和基于近似数的CKKS方案。同时，HElib在上述原始方案中引入了许多优化以加速同态运算，包括Smart-Vercauteren密文打包技术[13]和Gentry-Halevi-Smart优化[14]，提升了算法的整体运行效率。HElib提供了一种“同态加密汇编语言”，支持“set”、“add”、“multiply”、“shift”等基本操作指令，此外还提供了自动噪声管理、改进的“Bootstrapping”方法、多线程等功能。目前，HElib支持在Ubuntu、CentOS、macOS等操作系统平台上进行安装部署。 2020年5月，IBM在GitHub上开源了基于HElib开发的面向macOS和iOS操作系统的全同态加密工具包，提供了基于Xcode的全同态加密SDK，近期还将发布面向Linux和Android操作系统的工具包。 ② SEAL SEAL（Simple Encrypted Arithmetic Library，简单加密运算库）是微软密码学与隐私研究组开发的开源同态加密库，目前最新版本为3.5，支持BFV方案和CKKS方案，项目的参与人员包括CKKS的作者之一Song。SEAL基于C++实现，不需要其他依赖库，但一些可选功能需要微软GSL、ZLIB和Google Test等第三方库的支持。SEAL支持Windows、Linux、macOS、FreeBSD、Android等操作系统平台，同时支持.NET开发。与HElib类似，SEAL同样支持了基于整数的精确同态运算和基于浮点数的近似同态运算两类方案，但SEAL依靠微软的天生优势能够在Windows系统中进行部署。 在噪声管理方面，与HElib支持自动噪声管理不同，在SEAL中每个密文拥有一个特定的噪声预算量，需要在程序编写过程中通过重线性化操作自行控制乘法运算产生的噪声。基于SEAL实现同态加密运算的性能在很大程度上取决于程序编写的优劣，且存在着不同的优化方法，因此总体而言，SEAL的学习和使用难度较大。 由于现有的全同态加密算法在实际场景中的实用性不高，目前已落地的同态加密应用中采用的多为Paillier算法等性能较好的加法同态加密等半同态加密算法，通过将复杂计算需求以一定方式转化为纯加法的形式实现加法同态加密算法的有效应用。 ","date":"2022-09-20","objectID":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/:2:2","tags":["privacy","encryption"],"title":"[转载] 同态加密：实现数据的“可算不可见”","uri":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/"},{"categories":["privacy"],"content":"三、同态加密应用场景 同态加密的概念最初提出用于解决云计算等外包计算中的数据机密性保护问题，防止云计算服务提供商获取敏感明文数据，实现“先计算后解密”等价于传统的“先解密后计算”。随着区块链、隐私计算等新兴领域的发展及其对隐私保护的更高要求，同态加密的应用边界拓展到了更为丰富的领域。 ","date":"2022-09-20","objectID":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/:3:0","tags":["privacy","encryption"],"title":"[转载] 同态加密：实现数据的“可算不可见”","uri":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/"},{"categories":["privacy"],"content":"1、经典应用场景——云计算 在云计算或外包计算中，用户为了节约自身的软硬件成本，可将计算和存储需求外包给云服务提供商，利用云服务提供商强大的算力资源实现数据的托管存储和处理。但是，将明文数据直接交给云服务器具有一定的安全风险，而传统的加密存储方式则无法实现对密文数据的直接计算，因此如何同时实现数据的机密性和可计算性成为了学术界的一个难题。同态加密的出现为这一场景的实现提供了可能性。 在传统的云存储与计算解决方案中，用户需要信任云服务提供商不会窃取甚至泄露用户数据，而基于同态加密的云计算模型可在根本上解决这一矛盾。首先，用户使用同态加密算法和加密密钥对数据进行加密，并将密文发送给云服务器；云服务器在无法获知数据明文的情况下按照用户给定的程序对密文进行计算，并将密文计算结果返回给用户；用户使用同态加密算法和解密密钥对密文计算结果进行解密，所得结果与直接对明文进行相同计算的结果等价。 ","date":"2022-09-20","objectID":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/:3:1","tags":["privacy","encryption"],"title":"[转载] 同态加密：实现数据的“可算不可见”","uri":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/"},{"categories":["privacy"],"content":"2、在区块链中的应用 区块链应用的基本逻辑是将需要存证的信息上链，并通过众多区块链节点的验证和存储，确保上链数据的有效性和不可篡改性。例如，在比特币中，用户将转账信息进行广播，区块链节点在进行验证后将其打包上链，保证交易的合法性；在以太坊中，需要依赖区块链节点对智能合约的正确执行，以实现链上信息的统一性和正确性。但是，无论是公有链还是联盟链，直接基于明文信息进行区块链发布通常会在泄露一定的敏感数据。 基于同态加密的区块链应用理论模型如图2所示。为了保护链上信息的隐私性，同时又能实现区块链节点对相关信息的可计算性，可对数据进行同态加密，并将计算过程转化为同态运算过程，节点即可在无需获知明文数据的情况下实现密文计算。例如，区块链底层应用平台特别是公有链平台大多基于交易模型，可考虑采用加法同态加密进行支持隐私保护的交易金额计算等操作。 图2：基于同态加密的区块链应用模型 在一般的区块链隐私保护应用需求中，通常需要同时实现链上数据的保密性和可验证性，而同态加密仅能解决链上的密文计算问题。由于私钥不能公开，且随机化加密使得密文之间无法比较对应明文值是否相等，单独依靠同态加密技术难以在链上实现明文计算结果的验证。例如，加法同态加密虽然可以在保护交易金额和账户余额隐私的情况下实现金额的密文计算，但区块链节点无法对相关金额的有效性进行验证。因此，同态加密在区块链场景中的应用需求和应用能力有限，理论上更适合云计算等算力外包场景以及存在多个参与方之间交互计算需求的隐私计算应用。 ","date":"2022-09-20","objectID":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/:3:2","tags":["privacy","encryption"],"title":"[转载] 同态加密：实现数据的“可算不可见”","uri":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/"},{"categories":["privacy"],"content":"3、在联邦学习中的应用 联邦学习的概念最早由谷歌提出，多个参与方可在保证各自数据隐私的同时实现联合机器学习建模，即在不获取对方原始数据的情况下利用对方数据提升自身模型的效果。根据数据融合维度的不同，联邦学习主要可分为横向联邦学习和纵向联邦学习，分别对应样本维度的融合和特征维度的融合。目前，联邦学习方案可采用同态加密、秘密分享、不经意传输等密码学手段解决不同阶段的安全计算问题。其中，同态加密主要用于联合建模过程中的参数交互计算过程，实现预测模型的联合确立。目前，在联邦学习场景中使用较多同态加密算法为Paillier加法半同态加密算法。 在该类方案中，一般包含参与方A、参与方B、协作方C三种角色，参与方A和参与方B为数据提供方，而参与方C负责进行密钥分发和汇总计算，有时协作方C也可由两个参与方之一扮演。由于加法同态加密无法实现任意形式的计算，在进行联合建模时需要事先将拟联合计算的计算式近似转换为加法形式，并确定协议的具体流程。例如，通过泰勒展开将乘法运算转化为多项式相加的形式。联合模型的加密训练过程一般包含以下步骤： 协作方C生成同态加密公私钥对，并向参与方A和B分发公钥； A和B以同态密文的形式交互用于计算的中间结果； A和B将各自的计算结果汇总给C，C进行汇总计算，并对结果进行解密； C将解密后的结果返回给A和B，双方根据结果更新各自的模型参数。 在一些基于半同态加密的联邦学习特定方案中，也可无需协作方C进行模型汇总，参与双方各自形成一个子模型，在后续的联合预测的过程中需要进行参数交互。 除以上使用单一密钥的方法外，目前还存在无需协作者C的联合建模方案，参与计算的两方各掌握一对公私钥，但该方案的复杂程度较大，在性能方面不如上述方案。此外，学术界还提出了多密钥全同态加密方案，支持在多方使用不同密钥加密的密文之间进行同态计算，但该类方法目前还处于理论阶段。 目前，同态加密在联邦学习场景中的应用大多用于联合建模过程中的参数交互过程，避免泄露原始数据和直接传输明文参数，可在一定程度上同时解决数据融合计算和数据隐私保护问题。但是，目前基于加法半同态加密的解决方案仍存在一定的局限性，包括精度损失、交互开销大、公平性不足等问题。 ","date":"2022-09-20","objectID":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/:3:3","tags":["privacy","encryption"],"title":"[转载] 同态加密：实现数据的“可算不可见”","uri":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/"},{"categories":["privacy"],"content":"四、总结与建议 目前，全同态加密算法仍处于以学术界研究为主的发展阶段，现有方案均存在计算和存储开销大等无法规避的性能问题，距离高效的工程应用还有着难以跨越的鸿沟，同时面临国际和国内相关标准的缺失。因此，在尝试同态加密落地应用时，可考虑利用Paillier加法同态加密算法等较为成熟且性能较好的半同态加密算法，解决只存在加法或数乘同态运算需求的应用场景，或通过将复杂计算需求转化为只存在加法或数乘运算的形式实现全同态场景的近似替代。 ","date":"2022-09-20","objectID":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/:4:0","tags":["privacy","encryption"],"title":"[转载] 同态加密：实现数据的“可算不可见”","uri":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/"},{"categories":["privacy"],"content":"参考文献 Rivest R L, Adleman L, Dertouzos M L. On data banks and privacy homomorphisms[J]. Foundations of secure computation, 1978, 4(11): 169-180. Rivest R L, Shamir A, Adleman L. A method for obtaining digital signatures and public-key cryptosystems[J]. Communications of the ACM, 1978, 21(2): 120-126. ElGamal T. A public key cryptosystem and a signature scheme based on discrete logarithms[J]. IEEE transactions on information theory, 1985, 31(4): 469-472. Paillier P. Public-key cryptosystems based on composite degree residuosity classes[C]//International conference on the theory and applications of cryptographic techniques. Springer, Berlin, Heidelberg, 1999: 223-238. Boneh D, Goh E J, Nissim K. Evaluating 2-DNF formulas on ciphertexts[C]//Theory of Cryptography Conference. Springer, Berlin, Heidelberg, 2005: 325-341. Gentry C. Fully homomorphic encryption using ideal lattices[C]//Proceedings of the forty-first annual ACM symposium on Theory of computing. 2009: 169-178. Gentry C, Halevi S. Implementing gentry’s fully-homomorphic encryption scheme[C]//Annual international conference on the theory and applications of cryptographic techniques. Springer, Berlin, Heidelberg, 2011: 129-148. Brakerski Z, Gentry C, Vaikuntanathan V. (Leveled) fully homomorphic encryption without bootstrapping[J]. ACM Transactions on Computation Theory (TOCT), 2014, 6(3): 1-36. Brakerski Z. Fully homomorphic encryption without modulus switching from classical GapSVP[C]//Annual Cryptology Conference. Springer, Berlin, Heidelberg, 2012: 868-886. Fan J, Vercauteren F. Somewhat Practical Fully Homomorphic Encryption[J]. IACR Cryptology ePrint Archive, 2012, 2012: 144. Gentry C, Sahai A, Waters B. Homomorphic encryption from learning with errors: Conceptually-simpler, asymptotically-faster, attribute-based[C]//Annual Cryptology Conference. Springer, Berlin, Heidelberg, 2013: 75-92. Cheon J H, Kim A, Kim M, et al. Homomorphic encryption for arithmetic of approximate numbers[C]//International Conference on the Theory and Application of Cryptology and Information Security. Springer, Cham, 2017: 409-437. Smart N P, Vercauteren F. Fully homomorphic SIMD operations[J]. Designs, codes and cryptography, 2014, 71(1): 57-81. Gentry C, Halevi S, Smart N P. Homomorphic evaluation of the AES circuit[C]//Annual Cryptology Conference. Springer, Berlin, Heidelberg, 2012: 850-867. 转载自FreeBuf.COM ","date":"2022-09-20","objectID":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/:5:0","tags":["privacy","encryption"],"title":"[转载] 同态加密：实现数据的“可算不可见”","uri":"/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/"},{"categories":["privacy"],"content":"Outsourcing computation, privately Homomorphic evaluation function: Eval: f, Enc(x) -\u003e Enc(f(x)) ","date":"2022-09-20","objectID":"/homomorphic-encryption/:1:0","tags":["privacy","encryption"],"title":"Homomorphic Encryption","uri":"/homomorphic-encryption/"},{"categories":["privacy"],"content":"Fully homomorphic encryption Fully homomorphic = correctness for any efficient f = correctness for universal set ","date":"2022-09-20","objectID":"/homomorphic-encryption/:2:0","tags":["privacy","encryption"],"title":"Homomorphic Encryption","uri":"/homomorphic-encryption/"},{"categories":["privacy"],"content":"Approximate eigenvector method 基于GSW13的特征向量的构造，我们可以在ciphertext上计算加法和乘法，然后可以通过secret key恢复出message的计算结果。但是这个方法不安全，因为特征向量很容易被找到。 **idea：**使用approximate eigenvectors，在secret key右乘cipher text ","date":"2022-09-20","objectID":"/homomorphic-encryption/:2:1","tags":["privacy","encryption"],"title":"Homomorphic Encryption","uri":"/homomorphic-encryption/"},{"categories":["privacy"],"content":"Learning with errors (LWE) R05 ","date":"2022-09-20","objectID":"/homomorphic-encryption/:2:2","tags":["privacy","encryption"],"title":"Homomorphic Encryption","uri":"/homomorphic-encryption/"},{"categories":["privacy"],"content":"Rearranging notation **basic idea: ** we have a matrix A, we can generate a matrix s, such that sA=$\\eta$ ","date":"2022-09-20","objectID":"/homomorphic-encryption/:2:3","tags":["privacy","encryption"],"title":"Homomorphic Encryption","uri":"/homomorphic-encryption/"},{"categories":["privacy"],"content":"Encryption scheme from LWE Encryption Decryption it can be generalized to matrices. On matrices ","date":"2022-09-20","objectID":"/homomorphic-encryption/:2:4","tags":["privacy","encryption"],"title":"Homomorphic Encryption","uri":"/homomorphic-encryption/"},{"categories":["privacy"],"content":"Ref https://www.youtube.com/watch?v=O8IvJAIvGJo ","date":"2022-09-20","objectID":"/homomorphic-encryption/:3:0","tags":["privacy","encryption"],"title":"Homomorphic Encryption","uri":"/homomorphic-encryption/"},{"categories":["privacy"],"content":"Microsoft SEAL ","date":"2022-09-19","objectID":"/ms-seal/:1:0","tags":["privacy","encryption"],"title":"SEAL","uri":"/ms-seal/"},{"categories":["privacy"],"content":"Ref https://www.youtube.com/watch?v=XaYEHnaAg8M ","date":"2022-09-19","objectID":"/ms-seal/:2:0","tags":["privacy","encryption"],"title":"SEAL","uri":"/ms-seal/"},{"categories":["privacy"],"content":"What’s is CKKS Plain Computation Encrypted Computation bool, int (uint 64), modulo p BGV, BFV, TFHE double (float) CKKS ","date":"2022-09-18","objectID":"/ckks/:1:0","tags":["privacy","encryption"],"title":"CKKS","uri":"/ckks/"},{"categories":["privacy"],"content":"Approximate arithmetic For floating-point arithmetic, we keep the bits of significand to be the same. For fixed-point arithmetic, we keep the scaling factor to be the same. ","date":"2022-09-18","objectID":"/ckks/:2:0","tags":["privacy","encryption"],"title":"CKKS","uri":"/ckks/"},{"categories":["privacy"],"content":"Algorithms in CKKS ","date":"2022-09-18","objectID":"/ckks/:3:0","tags":["privacy","encryption"],"title":"CKKS","uri":"/ckks/"},{"categories":["privacy"],"content":"Encoding and decoding 在编码过程中需要使用比较大的scaling factor，这样可以保证更大的精度。 ","date":"2022-09-18","objectID":"/ckks/:4:0","tags":["privacy","encryption"],"title":"CKKS","uri":"/ckks/"},{"categories":["privacy"],"content":"Encrypt and decrypt ","date":"2022-09-18","objectID":"/ckks/:5:0","tags":["privacy","encryption"],"title":"CKKS","uri":"/ckks/"},{"categories":["privacy"],"content":"Ref https://www.youtube.com/watch?v=iQlgeL64vfo ","date":"2022-09-18","objectID":"/ckks/:6:0","tags":["privacy","encryption"],"title":"CKKS","uri":"/ckks/"},{"categories":["system"],"content":"Run Ubuntu Linux in Docker with Desktop Environment and VNC ","date":"2022-08-21","objectID":"/run-ubuntu-in-docker/:0:0","tags":["ubuntu","docker"],"title":"Run Ubuntu Linux in Docker with Desktop Environment and VNC","uri":"/run-ubuntu-in-docker/"},{"categories":["system"],"content":"Step 1 – Install Docker on your System sudo systemctl start docker \u0026\u0026 sudo systemctl enable docker Add your system user to the Docker group to be able to execute Docker commands without *sudo*. sudo usermod -aG docker $USER newgrp docker Verify the installed Docker version. $ docker version Client: Docker Engine - Community Version: 20.10.12 API version: 1.41 Go version: go1.16.12 Git commit: e91ed57 Built: Mon Dec 13 11:45:48 2021 OS/Arch: linux/amd64 Context: default Experimental: true .... ","date":"2022-08-21","objectID":"/run-ubuntu-in-docker/:1:0","tags":["ubuntu","docker"],"title":"Run Ubuntu Linux in Docker with Desktop Environment and VNC","uri":"/run-ubuntu-in-docker/"},{"categories":["system"],"content":"Step 2 – Pull the Ubuntu Docker Image As said earlier, there are several images for Ubuntu that can be pulled. These images are available on the Docker page and can be pulled using Docker as shown. ##For Ubuntu 20.04 (latest) docker pull dorowu/ubuntu-desktop-lxde-vnc:latest ##For Focal with LXDE docker pull dorowu/ubuntu-desktop-lxde-vnc:focal ##For Focal with LXQt docker pull dorowu/ubuntu-desktop-lxde-vnc:focal-lxqt ##For Bionic with LXDE docker pull dorowu/ubuntu-desktop-lxde-vnc:bionic ##For Bionic with LXQt docker pull dorowu/ubuntu-desktop-lxde-vnc:bionic-lxqt ##For Trusty docker pull dorowu/ubuntu-desktop-lxde-vnc:trusty ##For Xenial docker pull dorowu/ubuntu-desktop-lxde-vnc:xenial Once the desired Ubuntu image has been pulled, check if it is available in the local registry. $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE dorowu/ubuntu-desktop-lxde-vnc latest 1a89db715923 10 months ago 1.32GB ","date":"2022-08-21","objectID":"/run-ubuntu-in-docker/:2:0","tags":["ubuntu","docker"],"title":"Run Ubuntu Linux in Docker with Desktop Environment and VNC","uri":"/run-ubuntu-in-docker/"},{"categories":["system"],"content":"Step 3 – Run the Ubuntu Container with Desktop Environment Here, we will go through several methods with configuration on how you can run the Ubuntu container to give you an intuitive experience. ","date":"2022-08-21","objectID":"/run-ubuntu-in-docker/:3:0","tags":["ubuntu","docker"],"title":"Run Ubuntu Linux in Docker with Desktop Environment and VNC","uri":"/run-ubuntu-in-docker/"},{"categories":["system"],"content":"Quick Start. You can simply run the container and access it via port 6080 using the command below. docker run -d \\ --name ubuntu_desktop \\ -v /dev/shm:/dev/shm \\ -p 6080:80 \\ dorowu/ubuntu-desktop-lxde-vnc In the above command, we have set the container name to *ubuntu_desktop* and a persistent volume at */dev/shm* Remember to replace ubuntu-desktop-lxde-vnc with the appropriate image pulled. Check if the container is running with the port exposed. $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f8fd69e3865e dorowu/ubuntu-desktop-lxde-vnc \"/startup.sh\" 17 seconds ago Up 15 seconds (health: starting) 0.0.0.0:6080-\u003e80/tcp, :::6080-\u003e80/tcp ubuntu_desktop As seen from the output, we have port 6080 exposed. Allow it through the firewall and proceed to access the Ubuntu Desktop using the URL http://IP_Address:6080/. ","date":"2022-08-21","objectID":"/run-ubuntu-in-docker/:3:1","tags":["ubuntu","docker"],"title":"Run Ubuntu Linux in Docker with Desktop Environment and VNC","uri":"/run-ubuntu-in-docker/"},{"categories":["system"],"content":"Set HTTP Base Authentication You can also set a password to be used when accessing the HTTP page on port 6080 by adding the HTTP_PASSWORD variable to the above command: docker run -d \\ --name ubuntu_desktop \\ -e HTTP_PASSWORD=Passw0rd \\ -v /dev/shm:/dev/shm \\ -p 6080:80 \\ dorowu/ubuntu-desktop-lxde-vnc Now accessing the page, you will be required to provide a password. ","date":"2022-08-21","objectID":"/run-ubuntu-in-docker/:3:2","tags":["ubuntu","docker"],"title":"Run Ubuntu Linux in Docker with Desktop Environment and VNC","uri":"/run-ubuntu-in-docker/"},{"categories":["system"],"content":"Enable VNC Viewer The VNC viewer is accessed via a separate port 5900 that needs to be exposed in order to access it. The VNC Viewer port can be exposed as below. docker run -d \\ --name ubuntu_desktop \\ -v /dev/shm:/dev/shm \\ -p 6080:80 \\ -p 5900:5900 \\ dorowu/ubuntu-desktop-lxde-vnc Here, the VNC viewer should be available on port *5900*. You can as well set a password for the viewer by adding the VNC_PASSWORD variable to the above command: docker run -d \\ --name ubuntu_desktop \\ -e VNC_PASSWORD=StrongPassword \\ -v /dev/shm:/dev/shm \\ -p 6080:80 \\ -p 5900:5900 \\ dorowu/ubuntu-desktop-lxde-vnc ","date":"2022-08-21","objectID":"/run-ubuntu-in-docker/:3:3","tags":["ubuntu","docker"],"title":"Run Ubuntu Linux in Docker with Desktop Environment and VNC","uri":"/run-ubuntu-in-docker/"},{"categories":["system"],"content":"Encrypt with SSL. You can generate SSL certificates for encryption. In this guide, we will generate self-signed certificates as below. Ensure that OpenSSL is installed on your system before you proceed: mkdir -p ssl openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ssl/nginx.key -out ssl/nginx.crt Now when running the container, you need to specify the SSL_PORT and the path to the generated certificate as below. docker run -d \\ --name ubuntu_desktop \\ -v /dev/shm:/dev/shm \\ -p 6081:443 \\ -e SSL_PORT=443 \\ -v ${PWD}/ssl:/etc/nginx/ssl \\ dorowu/ubuntu-desktop-lxde-vnc Here, you can access the Ubuntu Desktop using the URL https://IP_address:6081. Ref https://computingforgeeks.com/run-ubuntu-linux-in-docker-with-desktop-environment-and-vnc/https://www.youtube.com/watch?v=umqz7kKWxyw) ","date":"2022-08-21","objectID":"/run-ubuntu-in-docker/:3:4","tags":["ubuntu","docker"],"title":"Run Ubuntu Linux in Docker with Desktop Environment and VNC","uri":"/run-ubuntu-in-docker/"},{"categories":["privacy"],"content":"全同态加密 Fully homomorphic encryption (FHE) ","date":"2022-08-10","objectID":"/fhe/:0:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"What’s is FHE 第一种形式：同时使用secret key加密和解密，public key用于第三方加密进行同态计算 第二种形式：asymmetric FHE，只使用public key进行加密，secret key用于解密 Efficient FHE is a giant leap towards httpz:// ? what’s httpz? ","date":"2022-08-10","objectID":"/fhe/:1:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"History Major task: find a new scheme to combine both addition and multiplication together. ","date":"2022-08-10","objectID":"/fhe/:2:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"1. First generation Plain text: single bit 这个方法的主要问题是noise，随着计算的叠加，there is a notion of noise in ciphertexts，noise accumulates Defining noise budget thourgh defining parameters noise growth is exponential bootstrapping to rescure (decrease the noise) Somewhat homomorphic encyption (SHE) 初代的FHE目标是每一步同态计算，都进行一次bootstrapping，来抑制噪音增加。但是bootstrapping的计算消耗太大，所以SHE的目标是控制在output时的噪音水平，保证是可以接受的。 ","date":"2022-08-10","objectID":"/fhe/:3:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"2. Second generation targeting the exponential growing noise ","date":"2022-08-10","objectID":"/fhe/:4:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"3. Third generation: GSW 只是概念上的简化，但是无法实用。 ","date":"2022-08-10","objectID":"/fhe/:5:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"4. 4th generation: Torus FHE, TFHE ","date":"2022-08-10","objectID":"/fhe/:6:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"Open-source FHE librabies FV-NFLlib SEAL HEAAN TFHE HElib nuFHE Palisade ","date":"2022-08-10","objectID":"/fhe/:7:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"Two encryption ","date":"2022-08-10","objectID":"/fhe/:8:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"Plaintext encoding 但是在计算的时候，noise会在右侧累积。 通过bootstrapping，可以减少右侧的noise LWE ciphertexts are homomorphic Ref Complete talk: Introduction to Homomorphic Encryption (by Pascal Paillier) - YouTube ","date":"2022-08-10","objectID":"/fhe/:9:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["system"],"content":"After installing PyG, here is the error: libc10_cuda.so: cannot open shared object file: No such file or directory Solution conda install pytorch==1.11.0 cudatoolkit=11.3 -c pytorch conda install pyg -c pyg ","date":"2022-08-06","objectID":"/libc10_cuda.so-error-for-installing-pyg/:0:0","tags":["system","linux"],"title":"libc10_cuda.so error for installing pyG","uri":"/libc10_cuda.so-error-for-installing-pyg/"},{"categories":["system"],"content":"在运行任务时，往linux的同一个文件夹中写入超过500万个文件，导致在硬盘还有空间的情况下，在该文件夹下无法继续写入文件，也无法使用ls、rm等命令。记录处理过程。 Background: physical server, about two years old, 7200-RPM SATA drives connected to a 3Ware RAID card, ext3 FS mounted noatime and data=ordered, not under crazy load, kernel 2.6.18-92.1.22.el5, uptime 545 days. Directory doesn’t contain any subdirectories, just millions of small (~100 byte) files, with some larger (a few KB) ones. We have a server that has gone a bit cuckoo over the course of the last few months, but we only noticed it the other day when it started being unable to write to a directory due to it containing too many files. Specifically, it started throwing this error in /var/log/messages: ext3_dx_add_entry: Directory index full! The disk in question has plenty of inodes remaining: Filesystem Inodes IUsed IFree IUse% Mounted on /dev/sda3 60719104 3465660 57253444 6% / So I’m guessing that means we hit the limit of how many entries can be in the directory file itself. No idea how many files that would be, but it can’t be more, as you can see, than three million or so. Not that that’s good, mind you! But that’s part one of my question: exactly what is that upper limit? Is it tunable? Before I get yelled at—I want to tune it down; this enormous directory caused all sorts of issues. Anyway, we tracked down the issue in the code that was generating all of those files, and we’ve corrected it. Now I’m stuck with deleting the directory. A few options here: rm -rf (dir) I tried this first. I gave up and killed it after it had run for a day and a half without any discernible impact. unlink(2) on the directory: Definitely worth consideration, but the question is whether it’d be faster to delete the files inside the directory via fsck than to delete via unlink(2). That is, one way or another, I’ve got to mark those inodes as unused. This assumes, of course, that I can tell fsck not to drop entries to the files in /lost+found; otherwise, I’ve just moved my problem. In addition to all the other concerns, after reading about this a bit more, it turns out I’d probably have to call some internal FS functions, as none of the unlink(2) variants I can find would allow me to just blithely delete a directory with entries in it. Pooh. while [ true ]; do ls -Uf | head -n 10000 | xargs rm -f 2\u003e/dev/null; done ) This is actually the shortened version; the real one I’m running, which just adds some progress-reporting and a clean stop when we run out of files to delete, is: export i=0; time ( while [ true ]; do ls -Uf | head -n 3 | grep -qF ‘.png’ || break; ls -Uf | head -n 10000 | xargs rm -f 2\u003e/dev/null; export i=$(($i+10000)); echo “$i…”; done ) This seems to be working rather well. As I write this, it has deleted 260,000 files in the past thirty minutes or so. Now, for the questions: As mentioned above, is the per-directory entry limit tunable? Why did it take “real 7m9.561s / user 0m0.001s / sys 0m0.001s” to delete a single file which was the first one in the list returned by ls -U, and it took perhaps ten minutes to delete the first 10,000 entries with the command in #3, but now it’s hauling along quite happily? For that matter, it deleted 260,000 in about thirty minutes, but it’s now taken another fifteen minutes to delete 60,000 more. Why the huge swings in speed? Is there a better way to do this sort of thing? Not store millions of files in a directory; I know that’s silly, and it wouldn’t have happened on my watch. Googling the problem and looking through SF and SO offers a lot of variations on find that are not going to be significantly faster than my approach for several self-evident reasons. But does the delete-via-fsck idea have any legs? Or something else entirely? I’m eager to hear out-of-the-box (or inside-the-not-well-known-box) thinking. Thanks for reading the small novel; feel free to ask questions and I’ll be sure to respond. I’ll also update the question with the final number of files and how long the delete script ran once I have that.","date":"2022-08-05","objectID":"/linux%E5%88%A0%E9%99%A4%E7%99%BE%E4%B8%87%E7%BA%A7%E5%88%AB%E6%96%87%E4%BB%B6/:0:0","tags":["system","linux"],"title":"linux删除百万级别文件","uri":"/linux%E5%88%A0%E9%99%A4%E7%99%BE%E4%B8%87%E7%BA%A7%E5%88%AB%E6%96%87%E4%BB%B6/"},{"categories":["system"],"content":"Automatically Sort Data in Google Sheets Extension -\u003e Apps script function autoSort(e) { const ss = SpreadsheetApp.getActiveSpreadsheet() const ws = ss.getSheetByName(\"Sheet1\") const range = ws.getRange(2,1,ws.getLastRow()-1,2) range.sort({column: 2, ascending: false}) } function onEdit(e){ autoSort(e) } ","date":"2022-07-01","objectID":"/googlesheetautomaticsort/:0:0","tags":["system","linux"],"title":"Automatically Sort Data in Google Sheets","uri":"/googlesheetautomaticsort/"},{"categories":["system"],"content":" Check SWAP used by differnt PID for i in $(cd /proc;ls | grep \"^[0-9]\" | awk '$0\u003e100'); do awk '/Swap:/{a=a+$2}END{print '\"$i\"',a/1024\"M\"}' /proc/$i/smaps;done| sort -k2nr | head Get the information about the PID ps aux | grep ${pid} ","date":"2022-06-09","objectID":"/check-swap/:0:0","tags":["system","linux"],"title":"Check SWAP","uri":"/check-swap/"},{"categories":["system"],"content":"显示“未能找到金属编译器安装的Xcode。请安装Xcode并运行Xcode.app来接受协议，或确保激活的开发者目录设为当前的Xcode安装（使用xcode-select） 解决方案： sudo xcode-select -s /Applications/Xcode.app/Contents/Developer ","date":"2022-06-09","objectID":"/xcode-select/:0:0","tags":["system","linux"],"title":"xcode-select","uri":"/xcode-select/"},{"categories":["leetcode"],"content":"给定两个稀疏向量，计算它们的点积（数量积）。 实现类 SparseVector： SparseVector(nums) 以向量 nums 初始化对象。 dotProduct(vec) 计算此向量与 vec 的点积。 稀疏向量 是指绝大多数分量为 0 的向量。你需要 高效 地存储这个向量，并计算两个稀疏向量的点积。 进阶：当其中只有一个向量是稀疏向量时，你该如何解决此问题？ 示例 1： 输入：nums1 = [1,0,0,2,3], nums2 = [0,3,0,4,0] 输出：8 解释：v1 = SparseVector(nums1) , v2 = SparseVector(nums2) v1.dotProduct(v2) = 10 + 03 + 00 + 24 + 3*0 = 8 示例 2： 输入：nums1 = [0,1,0,0,0], nums2 = [0,0,0,0,2] 输出：0 解释：v1 = SparseVector(nums1) , v2 = SparseVector(nums2) v1.dotProduct(v2) = 00 + 10 + 00 + 00 + 0*2 = 0 示例 3： 输入：nums1 = [0,1,0,0,2,0,0], nums2 = [1,0,0,0,3,0,4] 输出：6 提示： n == nums1.length == nums2.length 1 \u003c= n \u003c= 10^5 0 \u003c= nums1[i], nums2[i] \u003c= 100 解题思路 这个题的关键点在于用什么数据形式来存储稀疏向量。因为稀疏向量大部分地方都是0，所以使用list来存储是非常低效的。所以我们可以考虑用hash的形式来存储不为0的位置的数据。两个向量点乘的时候，只有两个vector中都不为0，才能对最后的结果产生影响。 因此，这个题目换个思路就是把hash化后的两个vector，有对应key的位置乘起来。 Answer class SparseVector: def __init__(self, nums): \"\"\" :type nums: List[int] \"\"\" self.h=self.hashit(nums) def hashit(self,l): h={} for i in range(len(l)): if l[i]!=0: h[i]=l[i] return h # Return the dotProduct of two sparse vectors def dotProduct(self, vec): \"\"\" :type vec: 'SparseVector' :rtype: int \"\"\" hv=vec.h ans=0 for key in self.h.keys(): try: ans+=self.h[key]*hv[key] except: pass return ans ","date":"2022-03-01","objectID":"/lc1570.-dot-product-of-two-sparse-vectors/:0:0","tags":["leetcode"],"title":"lc1570. Dot Product of Two Sparse Vectors","uri":"/lc1570.-dot-product-of-two-sparse-vectors/"},{"categories":["leetcode"],"content":"Implement pow(x, n), which calculates x raised to the power n (i.e., xn). Example 1: Input: x = 2.00000, n = 10 Output: 1024.00000 Example 2: Input: x = 2.10000, n = 3 Output: 9.26100 Example 3: Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Constraints: -100.0 \u003c x \u003c 100.0 -231 \u003c= n \u003c= 231-1 -104 \u003c= xn \u003c= 104 思路 ","date":"2022-03-01","objectID":"/lc50.-powx-n/:0:0","tags":["leetcode"],"title":"lc50. Pow(x, n)","uri":"/lc50.-powx-n/"},{"categories":["leetcode"],"content":"Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\". The testcases will be generated such that the answer is unique. A substring is a contiguous sequence of characters within the string. Example 1: Input: s = \"ADOBECODEBANC\", t = \"ABC\" Output: \"BANC\" Explanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t. Example 2: Input: s = \"a\", t = \"a\" Output: \"a\" Explanation: The entire string s is the minimum window. Example 3: Input: s = \"a\", t = \"aa\" Output: \"\" Explanation: Both 'a's from t must be included in the window. Since the largest window of s only has one 'a', return empty string. Constraints: m == s.length n == t.length 1 \u003c= m, n \u003c= 105 s and t consist of uppercase and lowercase English letters. 解题思路 这道题要求我们返回字符串 s中包含字符串 t 的全部字符的最小窗口，我们利用滑动窗口的思想解决这个问题。因此我们需要两个哈希表，hs哈希表维护的是s字符串中滑动窗口中各个字符出现多少次，ht哈希表维护的是t字符串各个字符出现多少次。如果hs哈希表中包含ht哈希表中的所有字符，并且对应的个数都不小于ht哈希表中各个字符的个数，那么说明当前的窗口是可行的，可行中的长度最短的滑动窗口就是答案。 过程如下： 1、遍历t字符串，用ht哈希表记录t字符串各个字符出现的次数。 2、定义两个指针j和i，j指针用于收缩窗口，i指针用于延伸窗口，则区间[j,i]表示当前滑动窗口。首先让i和j指针都指向字符串s开头，然后枚举整个字符串s ，枚举过程中，不断增加i使滑动窗口增大，相当于向右扩展滑动窗口。 3、每次向右扩展滑动窗口一步，将s[i]加入滑动窗口中，而新加入了s[i]，相当于滑动窗口维护的字符数加一，即hs[s[i]]++。 4、对于新加入的字符s[i],如果hs[s[i]] \u003c= ht[s[i]]，说明当前新加入的字符s[i]是必需的，且还未到达字符串t所要求的数量。我们还需要事先定义一个cnt变量， cnt维护的是s字符串[j,i]区间中满足t字符串的元素的个数，记录相对应字符的总数。新加入的字符s[i]必需，则cnt++。 5、我们向右扩展滑动窗口的同时也不能忘记收缩滑动窗口。因此当hs[s[j]] \u003e ht[s[j]时，说明hs哈希表中s[j]的数量多于ht哈希表中s[j]的数量，此时我们就需要向右收缩滑动窗口，j++并使hs[s[j]]–，即hs[s[j ++ ]] –。 6、当cnt == t.size时，说明此时滑动窗口包含符串 t 的全部字符。我们重复上述过程找到最小窗口即为答案。 时间复杂度分析： 两个指针都严格递增，最多移动 n 次，所以总时间复杂度是 O(n)。 作者：lin-shen-shi-jian-lu-k 链接：https://leetcode-cn.com/problems/minimum-window-substring/solution/leetcode-76-zui-xiao-fu-gai-zi-chuan-cja-lmqz/ Answer from collections import defaultdict class Solution: def minWindow(self, s, t): if len(s)\u003clen(t): return \"\" hs, ht = defaultdict(int), defaultdict(int) for chr in t: ht[chr] += 1 res = \"\" left, right = 0, 0 cnt = 0 while right\u003clen(s): hs[s[right]] += 1 if hs[s[right]] \u003c= ht[s[right]]: cnt += 1 while left\u003c=right and hs[s[left]] \u003e ht[s[left]]: hs[s[left]] -= 1 left += 1 if cnt == len(t): if not res or right-left+1\u003clen(res): res = s[left:right+1] right += 1 return res ","date":"2022-03-01","objectID":"/lc76.-minimum-window-substring/:0:0","tags":["leetcode"],"title":"lc76. Minimum Window Substring","uri":"/lc76.-minimum-window-substring/"},{"categories":["leetcode"],"content":"You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. Example 1: Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. Example 2: Input: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1]. Example 3: Input: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1. Constraints: nums1.length == m + n nums2.length == n 0 \u003c= m, n \u003c= 200 1 \u003c= m + n \u003c= 200 -109 \u003c= nums1[i], nums2[j] \u003c= 109 Follow up: Can you come up with an algorithm that runs in O(m + n) time? 思路 由于nums1的后序数字全为0，并且nums1和nums2都是以升序排列，所以我们可以把两个数组从大到小依次比较，然后插入num1。因为num1和num2中的数字只会遍历一次，因此最终的时间复杂度是O(m+n)。 Answer class Solution(object): def merge(self, nums1, m, nums2, n): \"\"\" :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: None Do not return anything, modify nums1 in-place instead. \"\"\" insert=-1 m,n=m-1,n-1 while m\u003e=0 and n\u003e=0: if nums1[m]\u003enums2[n]: nums1[m],nums1[insert]=nums1[insert],nums1[m] m-=1 elif nums1[m]\u003c=nums2[n]: nums1[insert]=nums2[n] n-=1 insert-=1 while n\u003e=0: nums1[insert]=nums2[n] n-=1 insert-=1 ","date":"2022-03-01","objectID":"/lc88.-merge-sorted-array/:0:0","tags":["leetcode"],"title":"lc88. Merge Sorted Array","uri":"/lc88.-merge-sorted-array/"},{"categories":["leetcode"],"content":"Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle. However, there is a non-negative integer n that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least n units of time between any two same tasks. Return the least number of units of times that the CPU will take to finish all the given tasks. Example 1: Input: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2 Output: 8 Explanation: A -\u003e B -\u003e idle -\u003e A -\u003e B -\u003e idle -\u003e A -\u003e B There is at least 2 units of time between any two same tasks. Example 2: Input: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0 Output: 6 Explanation: On this case any permutation of size 6 would work since n = 0. [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"] [\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"] [\"B\",\"B\",\"B\",\"A\",\"A\",\"A\"] ... And so on. Example 3: Input: tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2 Output: 16 Explanation: One possible solution is A -\u003e B -\u003e C -\u003e A -\u003e D -\u003e E -\u003e A -\u003e F -\u003e G -\u003e A -\u003e idle -\u003e idle -\u003e A -\u003e idle -\u003e idle -\u003e A Constraints: 1 \u003c= task.length \u003c= 104 tasks[i] is upper-case English letter. The integer n is in the range [0, 100]. 解题思路 第一思路是先根据数目最多的task来排位置，确保每两个之间隔的距离是n。这个时候留出来的idel之间也有符合距离为n的位点，然后再考虑其它task的位置。 建立大小为 n+1 的桶子，个数为任务数量最多的那个任务，比如下图，等待时间 n=2，A 任务个数 6 个，我们建立 6 桶子，每个容量为 3： 我们可以把一个桶子看作一轮任务 先从最简单的情况看起，现在就算没有其他任务，我们完成任务 A 所需的时间应该是 (6-1)*3+1=16，因为最后一个桶子，不存在等待时间。 接下来我们添加些其他任务 可以看到 C 其实并没有对总体时间产生影响，因为它被安排在了其他任务的冷却期间；而 B 和 A 数量相同，这会导致最后一个桶子中，我们需要多执行一次 B 任务，现在我们需要的时间是 (6-1)*3+2=17 前面两种情况，总结起来：总排队时间 = (桶个数 - 1) * (n + 1) + 最后一桶的任务数 当冷却时间短，任务种类很多时 比如上图，我们刚好排满了任务，此时所需时间还是 17，如果现在我还要执行两次任务 F，该怎么安排呢？ 此时我们可以临时扩充某些桶子的大小，插进任务 F，对比一下插入前后的任务执行情况： 插入前：ABC | ABC | ABD | ABD | ABD | AB 插入后：ABCF | ABCF | ABD | ABD | ABD | AB 我们在第一个、第二个桶子里插入了任务F，不难发现无论再继续插入多少任务，我们都可以类似处理，而且新插入元素肯定满足冷却要求 继续思考一下，这种情况下其实每个任务之间都不存在空余时间，冷却时间已经被完全填满了。 也就是说，我们执行任务所需的时间，就是任务的数量 这样剩下就很好处理了，我们只需要算两个数： 记录最大任务数量 N，看一下任务数量并列最多的任务有多少个，即最后一个桶子的任务数 X， 计算 NUM1=(N-1)*(n+1)+x NUM2=tasks.size() 输出其中较大值即可因为存在空闲时间时肯定是 NUM1 大，不存在空闲时间时肯定是 NUM2\u003e=NUM1 引用解析作者：popopop 引用解析链接：https://leetcode-cn.com/problems/task-scheduler/solution/tong-zi-by-popopop/ Answer from collections import Counter class Solution(object): def leastInterval(self, tasks, n): \"\"\" :type tasks: List[str] :type n: int :rtype: int \"\"\" F=Counter(tasks).values() max_F=max(F) count_max_F=0 for x in F: if x==max_F: count_max_F+=1 ans1=(max_F-1)*(n+1)+count_max_F ans2=len(tasks) return max(ans1,ans2) ","date":"2022-02-16","objectID":"/lc621.-task-scheduler/:0:0","tags":["leetcode"],"title":"lc621. Task Scheduler","uri":"/lc621.-task-scheduler/"},{"categories":["leetcode"],"content":"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets. Example 1: Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Example 2: Input: nums = [] Output: [] Example 3: Input: nums = [0] Output: [] Constraints: 0 \u003c= nums.length \u003c= 3000 -105 \u003c= nums[i] \u003c= 105 解题思路 class Solution(object): def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" nums=sorted(nums) ans=set() i=0 total_len=len(nums) while i\u003c=total_len-3: if nums[i]\u003e0: break val=nums[i] head=i+1 tail=total_len-1 while head\u003ctail: _sum=val+nums[head]+nums[tail] if _sum==0: ans.add((val,nums[head],nums[tail])) head+=1 tail-=1 elif _sum\u003c0: head+=1 elif _sum\u003e0: tail-=1 i+=1 return [list(x) for x in ans] ","date":"2022-02-14","objectID":"/lc15.-3sum/:0:0","tags":["leetcode"],"title":"lc15. 3Sum","uri":"/lc15.-3sum/"},{"categories":["leetcode"],"content":"Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Example 1: Input: root = [1,2,3,null,null,4,5] Output: [1,2,3,null,null,4,5] Example 2: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 104]. -1000 \u003c= Node.val \u003c= 1000 解题思路 二叉树的序列化本质上是对其值进行编码，更重要的是对其结构进行编码。可以遍历树来完成上述任务。众所周知，我们一般有两个策略：广度优先搜索和深度优先搜索。 广度优先搜索可以按照层次的顺序从上到下遍历所有的节点 深度优先搜索可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将深度优先搜索策略区分为： 1. 先序遍历 2. 中序遍历 3. 后序遍历 如Example 1的树，采用先序遍历我们可以得到字符串: 1, 2, None, None, 3, 4, 5 None表示子节点不存在，因此该字符串就保留了树的结构。 该序列化方法的时间复杂度为O(N)，因为我们只会访问每个节点一次。空间复杂度也为O(N). 反序列化的过程我们先把字符串根据“,”拆分，然后从左往右遍历元素。 序列化函数和反序列化函数都可以用递归思想。 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Codec: def serialize(self, root): \"\"\"Encodes a tree to a single string. :type root: TreeNode :rtype: str \"\"\" if root==None: return '#,' left=self.serialize(root.left) right=self.serialize(root.right) return str(root.val)+','+left+right def deserialize(self, data): \"\"\"Decodes your encoded data to tree. :type data: str :rtype: TreeNode \"\"\" return self.buildTree(data.split(',')) def buildTree(self,data): val=data.pop(0) if val=='#': return None node=TreeNode(val) node.left=self.buildTree(data) node.right=self.buildTree(data) return node # Your Codec object will be instantiated and called as such: # ser = Codec() # deser = Codec() # ans = deser.deserialize(ser.serialize(root)) ","date":"2022-02-14","objectID":"/lc297.-serialize-and-deserialize-binary-tree/:0:0","tags":["leetcode"],"title":"lc297. Serialize and Deserialize Binary Tree","uri":"/lc297.-serialize-and-deserialize-binary-tree/"},{"categories":["leetcode"],"content":"Given the root of a binary tree, return the vertical order traversal of its nodes’ values. (i.e., from top to bottom, column by column). If two nodes are in the same row and column, the order should be from left to right. Example 1: Input: root = [3,9,20,null,null,15,7] Output: [[9],[3,15],[20],[7]] Example 2: Input: root = [3,9,8,4,0,1,7] Output: [[4],[9],[3,0,1],[8],[7]] Example 3: Input: root = [3,9,8,4,0,1,7,null,null,null,2,5] Output: [[4],[9,5],[3,0,1],[8,2],[7]] Constraints: The number of nodes in the tree is in the range [0, 100]. -100 \u003c= Node.val \u003c= 100 解题思路 我们可以在使用BFS遍历的时候给每一个元素带上vertical的位置信息。 使用BFS确保在每个column内的顺序是正确的。 带上vertical信息确保我们知道每一个元素属于哪一列。 使用hashmap来模拟即可。 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def verticalOrder(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" if root: stack=[[root,0]] hashmap={} while stack!=[]: current_node=stack[0][0] current_idx=stack[0][1] stack=stack[1:] try: hashmap[current_idx].append(current_node) except: hashmap[current_idx]=[current_node] if current_node.left: stack.append([current_node.left,current_idx-1]) if current_node.right: stack.append([current_node.right,current_idx+1]) res=[[node.val for node in hashmap[key]] for key in sorted(hashmap.keys())] else: res=[] return res 注意题目有边界条件，如果输入是null需要返回[]。 ","date":"2022-02-08","objectID":"/lc314.binary-tree-vertical-order-traversal/:0:0","tags":["leetcode"],"title":"lc314. Binary Tree Vertical Order Traversal","uri":"/lc314.binary-tree-vertical-order-traversal/"},{"categories":["papers"],"content":"Title: Personalized Federated Learning: A Meta-Learning Approach INFO: 34th Conference on Neural Information Processing Systems (NeurIPS 2020) 研究背景 目前的联邦学习框架是基于所有users的数据，整合训练出一个最优的server模型。 However, this scheme only develops a common output for all the users, and, therefore, it does not adapt the model to each user. 但是，这样训练处来的server模型不一定适用于每一个user，尤其在不同的users所独有的数据差异比较大的时候。 This is an important missing feature, especially given the heterogeneity of the underlying data distribution for various users. 在heterogeneous的情景下，使用federated averaging方法训练出来的模型可能在每个独立user上的表现会比较差。 In particular, in the heterogeneous settings where the underlying data distribution of users are not identical, the resulted global model obtained by minimizing the average loss could perform arbitrarily poorly once applied to the local dataset of each user. 所以，参照Model-Agnostic Meta-Learning (MAML)的思路，这篇文章中，作者试图在联邦学习的思路上，训练一个最优的initial shared model，使得这个模型在每一个user上只需要非常少的几步finetune就可以适应本地的任务。 In this paper, we study a personalized variant of the federated learning in which our goal is to find aninitial shared model that current or new users can easily adapt to their local dataset by performing one or a few steps of gradient descent with respect to their own data. This approach keeps all the benefits ofthe federated learning architecture, and, by structure, leads to a more personalized model foreach user. Problem formulation Building on the Model-AgnosticMeta-Learning (MAML) problem formulation, the goal of this new formulationis to find an initial point shared between all users which performs well after each user updates it with respect to its own loss function, potentially by performing a few steps of a gradient-based method. This way, while the initial model is derived in a distributed manner over all users, thefinal model implemented by each user differs from other ones based on her or his own data. Westudy a Personalized variant of the FedAvg algorithm, called Per-FedAvg. Per-FedAvg ","date":"2022-02-05","objectID":"/neurips-personalized-federated-learning-a-meta-learning-approach/:0:0","tags":["NeurIPS","Machine learning","privacy","federated learning"],"title":"[NeurIPS] Personalized Federated Learning: A Meta-Learning Approach解读","uri":"/neurips-personalized-federated-learning-a-meta-learning-approach/"},{"categories":["papers"],"content":"Title: Personalized Federated Learning With Differential Privacy DOI: 10.1109/JIOT.2020.2991416 INFO: IEEE INTERNET OF THINGS JOURNAL, VOL. 7, NO. 10, OCTOBER 2020 发表周期: Manuscript received December 15, 2019; revised March 20, 2020; accepted April 13, 2020. Date of publication April 30, 2020; ","date":"2022-02-04","objectID":"/ieee-personalized-federated-learning-with-differential-privacy/:0:0","tags":["IEEE","Machine learning","privacy","federated learning"],"title":"[IEEE] Personalized Federated Learning WithDifferential Privacy解读","uri":"/ieee-personalized-federated-learning-with-differential-privacy/"},{"categories":["paper"],"content":"并列递进 moreover, in addition, furthermore, besides, likewise, also, then, additionally 转折 not, yet, however, nevertheless, nonetheless, meanwhile, on the other hand, on the contrary, conversely, paradoxically, by contrast, in spite of，rather than, instead of, unfortunately 解释 in other words, in fact, as a matter of fact, that is, namely, in simpler terms 对比比较 Likewise, Similarly, In parallel to, while, whereas, 原因 because, because of, as, since, owing to, due to, thanks to, for this reason 结果 therefore, as a result, then, consequently, thus, hence, so, therefore, accordingly, consequently, as a consequence 举例 for example, for instance, as such, such as, take …for example, to illustrate, to name a few 总结 overall, eventually, consequently, in summary, in a word, as a result, together, collectively, thus, hence, consequently, on the whole, in conclusion, to sum up, in brief, to conclude, to summarize, in short, briefly 强调 surprisingly, interestingly, intriguingly, strikingly, unexpectedly, clearly, obviously, apparently, in fact, indeed, actually, as a matter of fact, undoubtedly, notably, specifically, particularly, especially firstly, … secondly, … finally …; first, … then … etc. 让步 although, after all, in spite of…, despite, even if, even though, though, admittedly, given that 可能 presumably, probably, perhaps 1、大家在文章中肯定有这样一句，虽然这个科学问题很重要，然而有哪个具体的细节关键我们还不知道。“不知道”有哪些表述方式呢？ virtually/largely unknown, elusive, unclear, much less explored, surprisingly limited, less understood, unsolved, scarcely understood 2、如果是研究某些新材料、新技术等，我们在文章中又该从哪几个方面来夸我们的成果呢？ reliability and validity, robust and fundamental, efficiency and specificity, cost-effectiveness(price), the simplicity of the protocols, the amount of labor required, equipment requirement，necessary or sufficient 3、在引用别人文献中的论点论据时，我们该如何表述“别人说”呢？ clearly/obviously demonstrate, reveal, illustrate, prove, show, report, implicate, confirm, describe 4、“执行动词”的第N种表示方法。在引述别人工作的时，别人都如何“做”呢？ examine, perform, carry out, observe, compare, investigate, indicate, show, manipulate, test, establish, identify, detect, stimulate, analyse, assess, suggest, propose, speculate, determine, find, apply, purify, construct a model, devised a protocol, calculate, categorize, conduct, imply, measure 5、关于“方式方法”的“效应”评价，你真的可以玩转吗？ plays a central/ pivotal/ vital key/essential role a powerful regulator/ a key molecular determinant, a well-accepted model influence, affect, rescue, reverse, lead to, contribute to, attribute to, ascribe to, drop, reduce, increasing, attenuate, ameliorate, improve, mount, accumulate 6、写文章免不了溯古叙今，“时间表述词”，你掌握了吗？ recently, most recently, at the same time/period, since then, for several decades 7、重大影响的描述，教你如何夸“成果” pushing the boundariesrecent/enormous advance, progress, knowledge, historic, perspectives, new/novel insights, seminal discovery, an emerging theme, major/important findings, a better understanding ","date":"2022-02-04","objectID":"/sci%E9%AB%98%E9%A2%91%E8%AF%8D%E6%B1%87/:0:0","tags":["paper"],"title":"SCI高频词汇","uri":"/sci%E9%AB%98%E9%A2%91%E8%AF%8D%E6%B1%87/"},{"categories":["leetcode"],"content":"给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，返回 所需会议室的最小数量 。 示例 1： 输入：intervals = [[0,30],[5,10],[15,20]] 输出：2 示例 2： 输入：intervals = [[7,10],[2,4]] 输出：1 提示： 1 \u003c= intervals.length \u003c= 104 0 \u003c= starti \u003c endi \u003c= 106 解题思路 我们可以想象把这些interval给叠起来，所需要会议室的最小数量就等于最大重叠的interval的数目。 转化为上下车问题，每个interval的开始时间+1，每个interval的结束时间-1，然后我们统计counter的最大数值。 换个思路就是我们以时间为单位，我们可以知道每个单位时间车上的总人数是增加多少还是减少多少，这样我们可以直接求和从开始扫描到结束，获取当前车上最大的人数就可以。 class Solution(object): def minMeetingRooms(self, intervals): \"\"\" :type intervals: List[List[int]] :rtype: int \"\"\" dic={} for interval in intervals: try: dic[interval[0]]+=1 except: dic[interval[0]]=1 try: dic[interval[1]]-=1 except: dic[interval[1]]=-1 max_=0 count=0 for key in sorted(dic.keys()): count+=dic[key] if count\u003emax_: max_=count return max_ ","date":"2022-02-03","objectID":"/lc253.%E4%BC%9A%E8%AE%AE%E5%AE%A4ii/:0:0","tags":["leetcode"],"title":"lc253. 会议室 II","uri":"/lc253.%E4%BC%9A%E8%AE%AE%E5%AE%A4ii/"},{"categories":["leetcode"],"content":"Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high]. Example 1: Input: root = [10,5,15,3,7,null,18], low = 7, high = 15 Output: 32 Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32. Example 2: Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10 Output: 23 Explanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23. Constraints: The number of nodes in the tree is in the range [1, 2 * 104]. 1 \u003c= Node.val \u003c= 105 1 \u003c= low \u003c= high \u003c= 105 All Node.val are unique. 解题思路 因为题中树结构的每个父节点，其左孩子都更小，右孩子都更大，所以直接用树搜索获取所有在区间内的值即可。 二叉搜索树 BST 的 value 具有 左值 \u003c 根值 \u003c 右值 的特点。所以我们可以用递归算法累积求和。 class Solution(object): def rangeSumBST(self, root, low, high): \"\"\" :type root: TreeNode :type low: int :type high: int :rtype: int \"\"\" global res res = 0 def traverse(root): global res if root: traverse(root.left) if low \u003c= root.val \u003c= high: res += root.val traverse(root.right) traverse(root) return res ","date":"2022-02-03","objectID":"/lc938.range_sum_of_bst/:0:0","tags":["leetcode"],"title":"lc938. Range Sum of BST","uri":"/lc938.range_sum_of_bst/"},{"categories":["system"],"content":"本文转载自：https://zhuanlan.zhihu.com/p/31088141 本文的内容分为： Time Machine 是什么？ 自建Time Machine 服务器的理由 硬件的选择 软件的部署 Mac 备份到Time Machine 服务器 从Time Machine 服务器恢复Mac ","date":"2022-01-29","objectID":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/:0:0","tags":["system","linux"],"title":"搭建Time Machine 服务器 （转载）","uri":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/"},{"categories":["system"],"content":"Time Machine 是什么？ Time Machine是macOS中一个非常强大的功能，Time Machine能够保留： 本地快照（只要空间允许） 过去24小时的每小时备份 过去一个月的每日备份 过去所有月份的每周备份 Time Machine的备份是增量备份，只会备份自上次备份以来有变动的文件，因此备份速度很快，占用的空间也不多。如果Time Machine 占满了磁盘空间，最早的备份会被自动删除。 引用知友 @Xing 在OS X 中的 Time Machine 真的有用吗？中的回答： 只要使用Time Machine备份过，即使原来的Mac在Windows双系统下渲染片子时突然蓝屏被你一气之下砸坏或者在麦当劳吃晚饭时被人连电脑包顺走，你也只需走进Apple Store，买一台新Mac，回家连上Time Capsule或者插上含有备份的硬盘，按住option开机进入recovery分区，选择从Time Machine中恢复。开机后打开迁移助手Migration Assistant，选择从Time Machine备份中恢复。等你小憩醒来，将会看到一台和之前一模一样的Mac，不仅是图库音乐库昨晚看过的美剧进度，包括所有设置、开机启动项浏览器历史都是完全一致的。 当然上面只是Time Machine顺滑体验的一部分，Time Machine可以带你回到每一个有记录的节点，例如你有一个project几个月前 从零开始做，在Time Machine中可以演绎整个project文件夹内的变化，同时可以把某个时间任何文件揪出来。这感觉就像你有一麻袋后悔药，想怎么来就怎么来。 使用Time Machine，你既可以回到过去某个时刻，提取某个文件在当时的版本；也可以在电脑异常崩溃后直接全盘恢复到过去某个时刻的状态。 ","date":"2022-01-29","objectID":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/:1:0","tags":["system","linux"],"title":"搭建Time Machine 服务器 （转载）","uri":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/"},{"categories":["system"],"content":"自建Time Machine 服务器的理由 Time Machine的使用方法有三种： 使用一块外置的USB移动硬盘，要求文件系统是HFS+。 使用苹果的AirPort网络设备，通过有线网络/无线网络的方式备份到Airport的硬盘上。 使用Mac mini，安装「macOS Server」使之成为AFP协议传输的文件服务器，Time Machine备份到文件服务器上。 方法1. 外置的USB移动硬盘需要总是挂在Mac上占用一个USB接口，对于有移动需求的MacBook要经常插拔，我经常会忘记弹出直接拔，或者忘记去停下备份中的Time Machine直接拔，长此以往容易造成硬盘的损坏。 方法2. 中可选的Airport设备有两款，分别是AirPort Extreme和AirPort Time Capsule (2TB/3TB)，除了售价高昂之外，性能孱弱，功能单一，最新款发布于2013年，产品线已经多年没有更新。 方法3. 如果不考虑价格，是事实上的最优解，但是对于一般用户如果只是想要单纯的作「Time Machine服务器」似乎费效比太高。 因此，我的目标是自建一台低成本低功耗长期运行的服务器，在服务器上部署Time Machine server服务，并且具有性能/功能的冗余，以应对日后产生的需求。 ","date":"2022-01-29","objectID":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/:2:0","tags":["system","linux"],"title":"搭建Time Machine 服务器 （转载）","uri":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/"},{"categories":["system"],"content":"硬件选择 我购买了一个X86的准系统： 尺寸：16012037，重量：600g，功耗：6-12W，全铝设计无风扇被动散热。 CPU：14nm Intel® Celeron® N3150 四核心 1.6GHz, 最高2.08GHz, 内建Intel HD Graphics 4K 显示核心。 前置面板：4个原生USB3.0，2个USB2.0。 后置面板：12V-19V宽幅电压外接直流供电，2个HDMI，2个千兆有线网口，3.5mm音频输入/输出，2个SMA天线座。 板载：SATA3 6Gb/s机械硬盘插槽（蓝色），MSATA3 6Gb/s固态硬盘插槽（橙色），mini PCIe无线网卡插槽（红色），DDR3L-1600内存插槽（黄色）。 另外购买了相关硬件： 内存：威刚(ADATA) DDR3L 1G 1600 笔记本内存； 固态硬盘：闪迪(SanDisk) i100 32G MSATA3 MLC SSD； 无线网卡：博通(Broadcom) BCM94352hmb 802.11ac + 蓝牙4.0； 机械硬盘：昱科(HGST) 500G SATA3 7200转32M 笔记本硬盘。 组装好之后，与MacBook Pro 13大小比较。总计开销1180=准系统550+内存80+固态硬盘80+无线网卡200+机械硬盘270。 ","date":"2022-01-29","objectID":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/:3:0","tags":["system","linux"],"title":"搭建Time Machine 服务器 （转载）","uri":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/"},{"categories":["system"],"content":"软件的部署 安装Linux，我选择的是Ubuntu Server 16.04.3 LTS，以下以此为例，我的账户名为tmback，密码为tmback，主机名为TMBack-Server。 SSH登陆： ssh tmback@tmback-server.local 首先，查看识别到的硬盘： ~$ sudo fdisk -l sda是系统所在的SSD，sdb就是我要用来作Time Machine备份的硬盘，把这个硬盘格式化为Linux的EXT4文件格式： ~$ sudo mkfs.ext4 /dev/sdb1 把格式化好的分区起个名字就叫TMBack： ~$ sudo e2label /dev/sdb1 TMBack 在/media创建一个目录，把sdb1挂载上去： ~$ sudo mkdir /media/TMBack ~$ sudo mount /dev/sdb1 /media/TMBack 把/media/TMBack目录所有者修改为tmback:tmback ~$ sudo chown -R tmback:tmback /media/TMBack 安装Netatalk服务，项目主页Netatalk。 Netatalk is an OpenSource software package, that can be used to turn a *NIX machine into an extremely high-performance and reliable file server for Macintosh computers. Using Netatalk’s AFP 3.3 compliant file-server leads to significantly higher transmission speeds compared with Macs accessing a server via SaMBa/NFS while providing clients with the best possible user experience (full support for Macintosh metadata, flawlessly supporting mixed environments of classic Mac OS and OS X clients) 用来把Linux/Unix伪装成AFP协议传输的文件服务器： ~$ sudo apt-get install netatalk 修改Netatalk的配置文件： ~$ sudo nano /etc/netatalk/AppleVolumes.default 在末尾加上这么一句：「/media/TMBack “TMback” options:tm」 重启Netatalk服务： ~$ sudo service netatalk restart 这时在网络上就能发现一台新的，主机名为「tmback-server」的Mac主机。 用刚刚设的账户名tmback密码tmback登陆。 能看到挂载的硬盘TMBack目录。 安装avahi-daemon，项目主页avahi - mDNS/DNS-SD。 Avahi is a system which facilitates service discovery on a local network via the mDNS/DNS-SD protocol suite. This enables you to plug your laptop or computer into a network and instantly be able to view other people who you can chat with, find printers to print to or find files being shared. Compatible technology is found in Apple MacOS X (branded “Bonjour” and sometimes “Zeroconf”). Avahi is primarily targetted at Linux systems and ships by default in most distributions. It is not ported to Windows at this stage, but will run on many other BSD-like systems. The primary API is D-Bus and is required for usage of most of Avahi, however services can be published using an XML service definition placed in /etc/avahi/services. 用来在Linux/Unix中开启类似的Bonjour的服务： ~$ sudo apt-get install avahi-daemon 然后我们新建一个它的服务： ~$ sudo nano /etc/avahi/services/afpd.service 输入以下内容： \u003c?xml version=\"1.0\" standalone='no'?\u003e\u003c!--*-nxml-*--\u003e \u003c!DOCTYPE service-group SYSTEM \"avahi-service.dtd\"\u003e \u003cservice-group\u003e \u003cname replace-wildcards=\"yes\"\u003e%h\u003c/name\u003e \u003cservice\u003e \u003ctype\u003e_afpovertcp._tcp\u003c/type\u003e \u003cport\u003e548\u003c/port\u003e \u003c/service\u003e \u003cservice\u003e \u003ctype\u003e_device-info._tcp\u003c/type\u003e \u003cport\u003e0\u003c/port\u003e \u003ctxt-record\u003emodel=Xserve\u003c/txt-record\u003e \u003c/service\u003e \u003c/service-group\u003e 重启avahi-daemon服务： ~$ sudo service avahi-daemon restart 这时「tmback-server」变成了一台Mac文件服务器。 如果关闭ubuntu，你还会在Mac上收到通知。 安装nss-mdns，项目主页nss-mdns 0.10。 nss-mdns is a plugin for the GNU Name Service Switch (NSS) functionality of the GNU C Library (glibc) providing host name resolution via Multicast DNS (aka Zeroconf, aka Apple Rendezvous, aka Apple Bonjour), effectively allowing name resolution by common Unix/Linux programs in the ad-hoc mDNS domain .local. nss-mdns provides client functionality only, which means that you have to run a mDNS responder daemon seperately from nss-mdns if you want to register the local host name via mDNS. I recommend Avahi. nss-mdns is very lightweight (9 KByte stripped binary .so compiled with -DNDEBUG=1 -Os on i386, gcc 4.0), has no dependencies besides the glibc and requires only minimal configuration. By default nss-mdns tries to contact a running avahi-daemon for resolving host names and addresses and making use of its superior record cacheing. Optionally nss-mdns can be compiled with a mini mDNS stack that can be used to resolve host names without a local Avahi installation. Both Avahi support and this mini mDNS stack are optional, however at least one of them needs to be enabled. If both are enabled a connection to Avahi is tried first, and if that fails the mini mDNS stack is used. 用来配合刚刚设置好的avahi-daemon： ~$ sudo apt-get install libnss-mdns 修改nss-mdns配置文件： ~$ sudo nano /etc/nssw","date":"2022-01-29","objectID":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/:4:0","tags":["system","linux"],"title":"搭建Time Machine 服务器 （转载）","uri":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/"},{"categories":["system"],"content":"Mac 备份到Time Machine 服务器 系统偏好设置–\u003eTime Machine–\u003e选择备份磁盘 会发现一个名为「TMBack」的网络共享磁盘，选择它。 用我们之前设的账户名tmback密码tmback登陆。 耐心等待首次备份完成，嫌慢的话，把ubuntu和Mac都插上千兆网线，备份速度不输给外置USB硬盘备份。 此后，只要Mac与ubuntu处在同一个网络内，就会自动进行备份，Mac脱离网络则备份会自动停止，一切都是无感的。 ","date":"2022-01-29","objectID":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/:5:0","tags":["system","linux"],"title":"搭建Time Machine 服务器 （转载）","uri":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/"},{"categories":["system"],"content":"从Time Machine 服务器恢复Mac 按住「command+R」启动Mac，直到进入「Recovery」模式。 选择「从Time Machine 备份进行恢复」。 选择网络上的分区，输入账号密码连接即可。 ","date":"2022-01-29","objectID":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/:6:0","tags":["system","linux"],"title":"搭建Time Machine 服务器 （转载）","uri":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/"},{"categories":["leetcode"],"content":"Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where: '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Example 1: Input: s = \"aa\", p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\". Example 2: Input: s = \"aa\", p = \"a*\" Output: true Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\". Example 3: Input: s = \"ab\", p = \".*\" Output: true Explanation: \".*\" means \"zero or more (*) of any character (.)\". Constraints: 1 \u003c= s.length \u003c= 20 1 \u003c= p.length \u003c= 30 s contains only lowercase English letters. p contains only lowercase English letters, '.', and '*'. It is guaranteed for each appearance of the character '*', there will be a previous valid character to match. 解题思路 手写最简单的正则表达式函数，判断s是否符合p的正则规则。 初始思路 用两个指针分别读取s和p的头，按照规则依次匹配。确保两个指针可以在满足规则的前提下都移动到s和p的尾端。 进阶思路 动态规划。类似于两个序列做比对，只要可以完全alignment上就OK。 class Solution: def isMatch(self, s, p): m = len(s) + 1 n = len(p) + 1 dp = [[False for _ in range(n)] for _ in range(m)] dp[0][0] = True for j in range(2, n): if p[j-1] == '*': dp[0][j] = dp[0][j - 2] for r in range(1, m): i = r - 1 for c in range(1, n): j = c - 1 if s[i] == p[j] or p[j] == '.': dp[r][c] = dp[r - 1][c - 1] elif p[j] == '*': if p[j - 1] == s[i] or p[j - 1] == '.': dp[r][c] = dp[r - 1][c] or dp[r][c - 2] else: dp[r][c] = dp[r][c - 2] else: dp[r][c] = False return dp[m - 1][n - 1] ","date":"2022-01-27","objectID":"/lc10.regular_expression_matching/:0:0","tags":["leetcode"],"title":"lc10. Regular Expression Matching","uri":"/lc10.regular_expression_matching/"},{"categories":["leetcode"],"content":"A permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for arr = [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1]. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). For example, the next permutation of arr = [1,2,3] is [1,3,2]. Similarly, the next permutation of arr = [2,3,1] is [3,1,2]. While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement. Given an array of integers nums, find the next permutation of nums. The replacement must be in place and use only constant extra memory. Example 1: Input: nums = [1,2,3] Output: [1,3,2] Example 2: Input: nums = [3,2,1] Output: [1,2,3] Example 3: Input: nums = [1,1,5] Output: [1,5,1] Constraints: 1 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 100 解题思路 首先我们要知道，什么情况下是没有下一个（除了回到正序第一个）：当nums所有的数字都是严格降序排列。所以我们首先需要判断num是否严格降序，如果是则返回严格升序排列。 那么如何判断存在下一个刚刚好更大的数呢？只要nums中存在nums[i-1]\u003cnums[i]的情况就存在。既然如此，我们只要把nums[i-1]和nums[i:~]中恰好大于nums[i-1]的数交换位置即可。但是这样一来nums[i: ~]中也可能继续存在有恰好更大的排列。因此，我们注意到，最终我们需要把nums[i: ~]的数字全部严格降序排列。 所以最终的解题思路是： 对nums，从右边往左边扫，寻找nums[i-1]\u003cnums[i]的情况 如果无法找到（严格降序），那么返回严格升序序列 如果可以找到，那么把num[i-1]和num[i: ~]中最小的数字交换，然后把num[i: ~]全部严格升序排列 class Solution(object): def nextPermutation(self, nums): \"\"\" :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. \"\"\" for i in range(2,len(nums)+1): if nums[-i]\u003cnums[-i+1]: min_value=None for j in range(1,i): if min_value==None and nums[-j]\u003enums[-i]: min_value=nums[-j] if nums[-j]\u003c=min_value: min_idx=-j min_value=nums[-j] nums[-i],nums[min_idx]=nums[min_idx],nums[-i] nums[-i+1:]=sorted(nums[-i+1:],reverse=False) return nums[:]=sorted(nums,reverse=False) 这里有几个坑需要注意： 题目中强调不需要return，而是直接在nums上修改，因此如果是新建内存空间再赋值给nums，有可能无法通过。 记得最后如果是严格降序，需要返回严格升序。 在剩下序列中找的最小值，一定要大于nums[i-1] ","date":"2022-01-27","objectID":"/lc31.next_permutation/:0:0","tags":["leetcode"],"title":"lc31. Next Permutation","uri":"/lc31.next_permutation/"},{"categories":["leetcode"],"content":"Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. Example 1: Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. Constraints: 1 \u003c= intervals.length \u003c= 10^4 intervals[i].length == 2 0 \u003c= starti \u003c= endi \u003c= 10^4 解题思路 非常简单的思路是我们使用一个辅助list，首先遍历所有的input区间来记录有覆盖的位置，然后我们在遍历辅助list输出最终的interval。但是这种解法需要的内存会非常大，因此空间复杂度高。 另一种思路是先把input的区间按照区间头从小到大排序，然后再依次合并区间。 class Solution(object): def merge(self, intervals): \"\"\" :type intervals: List[List[int]] :rtype: List[List[int]] \"\"\" def partition(lists,low,high): i=low-1 pivot=lists[high][0] for j in range(low,high): if lists[j][0]\u003c=pivot: i+=1 lists[i],lists[j]=lists[j],lists[i] lists[i+1],lists[high]=lists[high],lists[i+1] return i+1 def quickSort(lists,low,high): if len(lists)==1: return lists if low\u003chigh: pi=partition(lists,low,high) quickSort(lists,low,pi-1) quickSort(lists,pi+1,high) return lists def overlap(intv1,intv2): if intv2[0]\u003c=intv1[1]: if intv2[1]\u003c=intv1[1]: return True,intv1 else: return True,[intv1[0],intv2[1]] else: return False,[intv1,intv2] _intervals=quickSort(intervals,0,len(intervals)-1) ans=[] tmp=_intervals[0] for _ in _intervals: isoverlapped,res=overlap(tmp,_) if isoverlapped==True: tmp=res else: ans.append(tmp) tmp=res[1] ans.append(tmp) return ans ","date":"2022-01-27","objectID":"/lc56.merge_intervals/:0:0","tags":["leetcode"],"title":"lc56. Merge Intervals","uri":"/lc56.merge_intervals/"},{"categories":["leetcode"],"content":"A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true if it is a palindrome, or false otherwise. Example 1: Input: s = \"A man, a plan, a canal: Panama\" Output: true Explanation: \"amanaplanacanalpanama\" is a palindrome. Example 2: Input: s = \"race a car\" Output: false Explanation: \"raceacar\" is not a palindrome. Example 3: Input: s = \" \" Output: true Explanation: s is an empty string \"\" after removing non-alphanumeric characters. Since an empty string reads the same forward and backward, it is a palindrome. Constraints: 1 \u003c= s.length \u003c= 2 * 105 s consists only of printable ASCII characters. 解题思路 把字符串转成小写 首先第一个循环只保留字符串中的字母和数字 利用指针双头判断。 class Solution(object): def isPalindrome(self, s): \"\"\" :type s: str :rtype: bool \"\"\" valid='abcdefghijklmnopqrstuvwxyz0123456789' s=s.lower() s=''.join([x for x in s if x in valid]) while len(s)\u003e1: if s[0]!=s[-1]: return False else: s=s[1:-1] return True 这道题注意一下valid字符串别漏写就行。因为我们只需要遍历一遍字符串，所以时间复杂度为O(N)，同时空间复杂度也为O(N) ","date":"2022-01-26","objectID":"/lc125.valid_palindrome/:0:0","tags":["leetcode"],"title":"lc125. Valid Palindrome","uri":"/lc125.valid_palindrome/"},{"categories":["leetcode"],"content":"Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] Constraints: 2 \u003c= nums.length \u003c= 105 -30 \u003c= nums[i] \u003c= 30 The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.) 解题思路: 题目非常鸡贼。最简单的想法是第一遍遍历把所有数字乘起来，然后第二遍遍历把乘积除以对应位置的数，如果是0则不除。结果发现题目中进一步要求 without using the division operation. 左右乘积 用两次遍历，第一次遍历维护一个左乘积，第二遍维护一个右乘积。 第三次遍历，把左乘积和右乘积乘起来，就是每个位置（exclude）之后其它部分的乘积。 class Solution(object): def productExceptSelf(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" left=[] right=[] _mul=1 for i in range(len(nums)): left.append(_mul) _mul*=nums[i] _nums=nums[::-1] _mul=1 for i in range(len(_nums)): right.append(_mul) _mul*=_nums[i] right=right[::-1] return [left[i]*right[i] for i in range(len(left))] 在这个算法下，因为我们有一个循环，所以时间复杂度是O(N)，同时我们需要维护和nums同长的一个list，所以空间复杂度是O(N) 进阶，空间复杂度O(1) 如果需要实现空间复杂度O(1)，意味着除了最终的输出答案，我们中间不能使用任何和nums等长的list存储中间答案。 所以最简单的方案是我们只维护一个final result list，然后通过两次遍历来更新final。 class Solution(object): def productExceptSelf(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" res=[1 for i in range(len(nums))] _mul=1 for i in range(len(nums)): res[i]*=_mul _mul*=nums[i] _mul=1 for i in range(len(nums)): res[-i-1]*=_mul _mul*=nums[-i-1] return res 这里需要注意在计算右乘积时使用的index，因为我们使用的是-i，所以i=0的时候会出现问题，我们需要在idx上减去1. ","date":"2022-01-26","objectID":"/lc238._product_of_array_except_self/:0:0","tags":["leetcode"],"title":"lc238. Product of Array Except Self","uri":"/lc238._product_of_array_except_self/"},{"categories":["leetcode"],"content":"Given two non-negative integers, num1 and num2 represented as string, return the sum of num1and num2 as a string. You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly. Example 1: Input: num1 = \"11\", num2 = \"123\" Output: \"134\" Example 2: Input: num1 = \"456\", num2 = \"77\" Output: \"533\" Example 3: Input: num1 = \"0\", num2 = \"0\" Output: \"0\" Constraints: 1 \u003c= num1.length, num2.length \u003c= 104 num1 and num2 consist of only digits. num1 and num2 don’t have any leading zeros except for the zero itself. 解题思路： 这道题限制not convert the inputs to integers directly，所以我们只能按照每一步来模拟进位计算。 把两个字符串反向。 把每一位变成数字，模拟进位计算 class Solution(object): def addStrings(self, num1, num2): \"\"\" :type num1: str :type num2: str :rtype: str \"\"\" ans='' _up=0 while len(num1)\u003e0 and len(num2)\u003e0: _1=int(num1[-1]) _2=int(num2[-1]) num1=num1[:-1] num2=num2[:-1] _sum=_1+_2+_up if _sum\u003e9: _up=1 else: _up=0 ans+=str(_sum%10) num='' if len(num1)\u003e0: num=num1 elif len(num2)\u003e0: num=num2 while len(num)\u003e0: _1=int(num[-1]) num=num[:-1] _sum=_1+_up if _sum\u003e9: _up=1 else: _up=0 ans+=str(_sum%10) if _up==1: ans+='1' return ans[::-1] 注意如果最后_up还是1，那么记得在最终答案上补上1. 执行用时：36 ms, 在所有 Python 提交中击败了41.44%的用户 内存消耗：13.3 MB, 在所有 Python 提交中击败了43.47%的用户 ","date":"2022-01-26","objectID":"/lc415.add_strings/:0:0","tags":["leetcode"],"title":"lc415. Add Strings","uri":"/lc415.add_strings/"},{"categories":["leetcode"],"content":"Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k. Example 1: Input: nums = [1,1,1], k = 2 Output: 2 Example 2: Input: nums = [1,2,3], k = 3 Output: 2 Constraints: 1 \u003c= nums.length \u003c= 2 * 104 -1000 \u003c= nums[i] \u003c= 1000 -107 \u003c= k \u003c= 107 解题思路： 累积和（使用数组） 首先使用一个cumulative数组，保存nums中从0开始到每个元素的累积求和。 然后，cumulative数组中两两数之间的差，对应nums中这两个位置之间的累积求和。 通过计算两两差之后，我们就可以知道有多少continuous subarrays whose sum equals to k class Solution(object): def subarraySum(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: int \"\"\" cumulative=[0] base=0 for num in nums: base+=num cumulative.append(base) ans=0 for i in range(len(cumulative)-1): for j in range(i+1,len(cumulative)): res=cumulative[j]-cumulative[i] if res==k: ans+=1 return ans 这个方法因为我们需要在cumulative上进行两次循环，所以时间复杂度为O(N^2)，同时因为需要cumulative来存储，所以空间复杂度是O(N). 累积和（不使用数组） class Solution(object): def subarraySum(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: int \"\"\" ans=0 for i in range(len(nums)-1): sum=0 for j in range(i,len(nums)): sum+=nums[j] if sum==k: ans+=1 return ans 这个方法因为我们依旧需要在cumulative上进行两次循环，所以时间复杂度为O(N^2)，但是我们不需要使用数组来存储答案，所以空间复杂度是O(1). 哈希表 接下来我们希望可以把时间复杂度降到O(N)，所以我们需要抛弃两层循环。这里的思路是，我们只需要遍历nums一遍，然后用一个dict保存出现的和。空间换时间的算法，这题使用哈希表省去的是遍历开头的时间，因为我们已知结尾的话，需要什么开头很容易知道，就是B[j]-k，就是查看之前的前缀和元素里有没有B[j]-k这个元素。与遍历不同的是，遍历寻找开头的话还能知道是哪一段子数组，哈希表的话我们并不知道子数组是哪一段，只需要知道有没有就可以了，这题就是只需要我们给出有没有，有多少个的结果就可以了。 class Solution(object): def subarraySum(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: int \"\"\" _sum, res, cul = 0, 0, {0:1} for _ in nums: _sum+=_ if _sum-k in cul: res+=cul[_sum-k] try: cul[_sum]+=1 except: cul[_sum]=1 return res ","date":"2022-01-25","objectID":"/lc560.subarray_sum_equals_k/:0:0","tags":["leetcode"],"title":"lc560. Subarray Sum Equals K","uri":"/lc560.subarray_sum_equals_k/"},{"categories":["leetcode"],"content":"Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid. Return all the possible results. You may return the answer in any order. Example 1: Input: s = \"()())()\" Output: [\"(())()\",\"()()()\"] Example 2: Input: s = \"(a)())()\" Output: [\"(a())()\",\"(a)()()\"] Example 3: Input: s = \")(\" Output: [\"\"] Constraints: 1 \u003c= s.length \u003c= 25 s consists of lowercase English letters and parentheses '(' and ')'. There will be at most 20 parentheses in s. 难点：本题和1249. 移除无效的括号非常相似，但是这里最难的点是如何找到所有的可能解。 解题思路： 由于我们需要找到的是最小Removal，同时需要找到在当前最小Removal下的所有解，我们可以采用BFS搜索方法。对于BFS的tree中每一层可以认为是在上一层的字符串中删除一个括号之后的所有可能字符串，然后我们对所有节点判断是否为有效括号。使用BFS，有2个好处： 如果父节点已经是合法字符串，则无需再考虑任何子节点。 如果有一个节点已经是合法字符串，则其它所有结果都只可能出现在和这个节点同一层（为了确保minimal removal）。 class Solution(object): def removeInvalidParentheses(self, s): \"\"\" :type s: str :rtype: List[str] \"\"\" def delOne(string): out=set() for i in range(len(string)): tmp=list(string) tmp.pop(i) out.add(''.join(tmp)) return out def getNextLevel(level): \"\"\" :type level: set \"\"\" nextlevel=set() for _ in level: for __ in delOne(_): nextlevel.add(__) return nextlevel def isValid(string): count=0 for _ in string: if _=='(': count+=1 elif _==')': count-=1 if count\u003c0: return False if count==0: return True else: return False level=[s] length=len(s) while True: current_ans=[] #print(current_ans,level) for _ in level: if isValid(_)==True: current_ans.append(_) else: pass if len(current_ans)!=0: break else: if length\u003e1: level=getNextLevel(level) length-=1 else: current_ans=[\"\"] break return current_ans 但是使用BFS的时间复杂度比较高， 执行用时：668 ms, 在所有 Python 提交中击败了13.99%的用户 内存消耗：13.9 MB, 在所有 Python 提交中击败了5.12%的用户 ","date":"2022-01-20","objectID":"/lc301.remove_invalid_parentheses/:0:0","tags":["leetcode"],"title":"lc301. Remove Invalid Parentheses","uri":"/lc301.remove_invalid_parentheses/"},{"categories":["leetcode"],"content":"Given two binary strings a and b, return their sum as a binary string. Example 1: Input: a = \"11\", b = \"1\" Output: \"100\" Example 2: Input: a = \"1010\", b = \"1011\" Output: \"10101\" Constraints: 1 \u003c= a.length, b.length \u003c= 104 a and b consist only of '0' or '1' characters. Each string does not contain leading zeros except for the zero itself. 解题思路 直接按照进位处理即可。 朴素解法 class Solution(object): def addBinary(self, a, b): \"\"\" :type a: str :type b: str :rtype: str \"\"\" _up=0 ans=[] a,b=list(a),list(b) while len(a)!=0 and len(b)!=0: _a=int(a.pop(-1)) _b=int(b.pop(-1)) _sum=_a+_b+_up if _sum\u003e=2: ans.append(_sum%2) _up=1 else: ans.append(_sum) _up=0 if len(a)!=0: while len(a)!=0: _a=int(a.pop(-1)) _sum=_a+_up if _sum\u003e=2: ans.append(_sum%2) _up=1 else: ans.append(_sum) _up=0 elif len(b)!=0: while len(b)!=0: _b=int(b.pop(-1)) _sum=_b+_up if _sum\u003e=2: ans.append(_sum%2) _up=1 else: ans.append(_sum) _up=0 if _up!=0: ans.append(_up) return ''.join([str(x) for x in ans[::-1]]) 性能分析： Runtime: 32 ms, faster than 40.49% of Python online submissions for Add Binary. Memory Usage: 13.7 MB, less than 6.13% of Python online submissions for Add Binary. 调包解法： 直接把二进制转为10进制求和再转回二进制 res = int(a, 2) + int(b, 2) res_str = str(bin(res)) res_len = len(res_str) return res_str[2:res_len] ","date":"2022-01-20","objectID":"/lc67.add_binary/:0:0","tags":["leetcode"],"title":"lc67. Add Binary","uri":"/lc67.add_binary/"},{"categories":["leetcode"],"content":"Convert a non-negative integer num to its English words representation. Example 1: Input: num = 123 Output: \"One Hundred Twenty Three\" Example 2: Input: num = 12345 Output: \"Twelve Thousand Three Hundred Forty Five\" Example 3: Input: num = 1234567 Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\" Constraints: 0 \u003c= num \u003c= 2^31 - 1 解题思路： 根据数字长度分成不同的翻译位: 亿，百万，千，百，Billion, Million, Thousand, Hundred 90-20的整10读法: Ninety, Eighty, Seventy, Sixty, Fifty, Fourty, Thirty, Twenty 19-11的读法：Nienteen, Eighteen, Seventeen, Sixteen, Fifteen, Fourteen, Thirteen, Twelve, Eleven 10-0的读法：Ten, Nine, Eight, Seven, Six, Five, Four, Three, Two, One, Zero 难点：把数字根据位数拆开。 **两种解法：**递归和迭代。 递归解法： class Solution(object): def numberToWords(self, num): \"\"\" :type num: int :rtype: str \"\"\" from0to19=['','One','Two','Three','Four','Five','Six','Seven','Eight','Nine','Ten','Eleven','Twelve','Thirteen','Fourteen','Fifteen','Sixteen','Seventeen','Eighteen','Nineteen'] from20to90=['','','Twenty','Thirty','Forty','Fifty','Sixty','Seventy','Eighty','Ninety'] def recursive(num): if num\u003e=1000000000: # larger than 1 billion ans='{}Billion'.format(from0to19[num//1000000000])+recursive(num%1000000000) return ans elif num\u003e=1000000: ans='{}Million'.format(recursive(num//1000000))+recursive(num%1000000) return ans elif num\u003e=1000: ans='{}Thousand'.format(recursive(num//1000))+recursive(num%1000) return ans elif num\u003e=100: ans='{}Hundred'.format(from0to19[num//100])+recursive(num%100) return ans elif num\u003e=20: ans='{}'.format(from20to90[num//10])+recursive(num%10) return ans else: return '{}'.format(from0to19[num]) def addBlank(s): _s='' for _ in s: if _.isupper(): _s+=' {}'.format(_) else: _s+=_ return _s if num==0: return 'Zero' else: ans=recursive(num) return addBlank(ans)[1:] Runtime: 24 ms, faster than 54.38% of Python online submissions for Integer to English Words. Memory Usage: 13.6 MB, less than 13.33% of Python online submissions for Integer to English Words. 踩坑： 空格问题 数字区间分割 Billion位忘记转英文 英文拼写错误，eg: forteen ","date":"2022-01-17","objectID":"/lc273.integer_to_english_words/:0:0","tags":["leetcode"],"title":"lc273. Integer to English Words","uri":"/lc273.integer_to_english_words/"},{"categories":["leetcode"],"content":"Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2). You may return the answer in any order. The answer is guaranteed to be unique(except for the order that it is in). Example 1: Input: points = [[1,3],[-2,2]], k = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10). The distance between (-2, 2) and the origin is sqrt(8). Since sqrt(8) \u003c sqrt(10), (-2, 2) is closer to the origin. We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]]. Example 2: Input: points = [[3,3],[5,-1],[-2,4]], k = 2 Output: [[3,3],[-2,4]] Explanation: The answer [[-2,4],[3,3]] would also be accepted. Constraints: 1 \u003c= k \u003c= points.length \u003c= 104 -104 \u003c xi, yi \u003c 104 解题思路： 最直接的解法就是把每个点的距离计算出来之后，然后根据大小排序取前k。 难点：如何在排序算法中采用最快的方式。 可以考虑使用快速排序方法： class Solution(object): def kClosest(self, points, k): \"\"\" :type points: List[List[int]] :type k: int :rtype: List[List[int]] \"\"\" def calDist(points): return [(x,x[0]*x[0]+x[1]*x[1]) for x in points] def quickSort(lists,i,j): if i \u003e= j: return list pivot = lists[i] low = i high = j while i \u003c j: while i \u003c j and lists[j][1] \u003e= pivot[1]: j -= 1 lists[i]=lists[j] while i \u003c j and lists[i][1] \u003c=pivot[1]: i += 1 lists[j]=lists[i] lists[j] = pivot quickSort(lists,low,i-1) quickSort(lists,i+1,high) return lists _points=calDist(points) _points=quickSort(_points,0,len(_points)-1) return [_points[idx][0] for idx in range(k)] 但是快速排序性能不稳定，性能取决于pivot的选择。因为这个题有限制条件为topK，所以我们可以进一步考虑使用堆排序，通过维护一个大小为K的堆来遍历数据。 这里为了简化代码，我们调用python自带的heapq模块。由于heapq模块默认的保留K最大，所以为了获得k距离最近的点，我们需要把距离取负值。 import heapq class Solution(object): def kClosest(self, points, k): \"\"\" :type points: List[List[int]] :type k: int :rtype: List[List[int]] \"\"\" def dist(point): return (-(point[0]**2+point[1]**2),point) h=[] for point in points: if len(h)\u003ck: heapq.heappush(h,dist(point)) else: _new=dist(point) if h[0][0]\u003c_new[0]: heapq.heappop(h) heapq.heappush(h,_new) return [x[1] for x in h] 执行用时：148 ms, 在所有 Python 提交中击败了37.37%的用户 内存消耗：18.1 MB, 在所有 Python 提交中击败了53.54%的用户 使用堆在性能上显著优于使用快排。 ","date":"2022-01-16","objectID":"/lc973.k_closest_points_to_origin/:0:0","tags":["leetcode"],"title":"lc973. K Closest Points to Origin","uri":"/lc973.k_closest_points_to_origin/"},{"categories":["leetcode"],"content":"Given a string s, return true if the s can be palindrome after deleting at most one character from it. Example 1: Input: s = \"aba\" Output: true Example 2: Input: s = \"abca\" Output: true Explanation: You could delete the character 'c'. Example 3: Input: s = \"abc\" Output: false Constraints: 1 \u003c= s.length \u003c= 105 s consists of lowercase English letters. 解题思路： 如果最多删除一个字母可以使字符串满足回文序列即返回true。 我们可以从字符串两端开始依次比较，如果遇到不同，我们有一次机会删除其中一个字母继续比较，一个简单的while循环就可以完成任务。 代码： class Solution(object): def validPalindrome(self, s): \"\"\" :type s: str :rtype: bool \"\"\" def isPalindrome(_s): _left=0 _right=len(_s)-1 while _left\u003c_right: if _s[_left]!=_s[_right]: return False else: _left+=1 _right-=1 return True delcount=0 left=0 right=len(s)-1 while left\u003cright: if s[left]==s[right]: left+=1 right-=1 else: if delcount==0: delcount+=1 if isPalindrome(s[left+1:right+1])==True: left+=1 elif isPalindrome(s[left:right])==True: right-=1 else: return False else: return False return True 性能： 执行用时：140 ms, 在所有 Python 提交中击败了17.65%的用户 内存消耗：13.6 MB, 在所有 Python 提交中击败了47.06%的用户 ","date":"2022-01-13","objectID":"/lc680.valid_palindrome_ii/:0:0","tags":["leetcode"],"title":"lc680. Valid Palindrome II","uri":"/lc680.valid_palindrome_ii/"},{"categories":["leetcode"],"content":"In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language. Example 1: Input: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\" Output: true Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted. Example 2: Input: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\" Output: false Explanation: As 'd' comes after 'l' in this language, then words[0] \u003e words[1], hence the sequence is unsorted. Example 3: Input: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\" Output: false Explanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" \u003e \"app\", because 'l' \u003e '∅', where '∅' is defined as the blank character which is less than any other character (More info). Constraints: 1 \u003c= words.length \u003c= 100 1 \u003c= words[i].length \u003c= 20 order.length == 26 All characters in words[i] and order are English lowercase letters. 解题思路： 对于每一个单词的每一个字母我们都可以用其在字典中的位置来编码，比如说： hello=[0,6,1,1,14]，对于字典order = “hlabcdefgijkmnopqrstuvwxyz” 给定一组词汇如：words = [“hello”,“leetcode”] 我们可以把其中的单词全部翻译成index，然后依次比较。 代码： class Solution(object): def isAlienSorted(self, words, order): \"\"\" :type words: List[str] :type order: str :rtype: bool \"\"\" def word2idx(word,order): out=[] for _ in word: out.append(order.index(_)) return out A_idx=None # to record the left one B_idx=None # to record the right one for i in range(len(words)-1): A_idx=word2idx(words[i],order) B_idx=word2idx(words[i+1],order) flag=True while len(A_idx)!=0 and len(B_idx)!=0 and flag==True: A=A_idx[0] A_idx=A_idx[1:] B=B_idx[0] B_idx=B_idx[1:] if A\u003cB: flag=False elif A\u003eB: return False elif A==B: pass if flag==True: if len(A_idx)!=0: return False else: pass return True 性能： 执行用时：20 ms, 在所有 Python 提交中击败了69.01%的用户 内存消耗：13 MB, 在所有 Python 提交中击败了87.32%的用户 优化： 原始代码中定义了一些不必要的操作步骤，导致拉满速度和时间，以下代码采用了一样的思路，但运行速度更快： class Solution: def isAlienSorted(self, words: List[str], order: str) -\u003e bool: di = dict() # storing the alphabet order of language via hashmap for i in range(len(order)): di[order[i]] = i+1 # helper function comparing two words def compareWords(w1, w2): i = 0 # looping depends on smaller word while i\u003cmin(len(w1), len(w2)): # getting order/rank of words rank1, rank2 = di.get(w1[i]), di.get(w2[i]) # correct order if w2's rank is greater if rank1 \u003c rank2: return True # continue if letters are same elif rank1 == rank2: i += 1 continue # incorrect order if w1's rank is greater else: return False # w1 should be smaller if all letters are equal if len(w1)\u003elen(w2): return False else: return True for i in range(len(words)-1): w1, w2 = words[i], words[i+1] # comparing with the immediate next word if not compareWords(w1, w2): return False return True ","date":"2022-01-12","objectID":"/lc953.verifying_an_alien_dictionary/:0:0","tags":["leetcode"],"title":"lc953. Verifying an Alien Dictionary","uri":"/lc953.verifying_an_alien_dictionary/"},{"categories":["leetcode"],"content":"Given a string s of '(' , ')' and lowercase English characters. Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string. Formally, a parentheses string is valid if and only if: It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. Example 1: Input: s = \"lee(t(c)o)de)\" Output: \"lee(t(c)o)de\" Explanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted. Example 2: Input: s = \"a)b(c)d\" Output: \"ab(c)d\" Example 3: Input: s = \"))((\" Output: \"\" Explanation: An empty string is also valid. Constraints: 1 \u003c= s.length \u003c= 105 s[i] is either'(' , ')', or lowercase English letter. 解题思路： 有效字符串的意味着其中的左括号和右括号一对一匹配的（paired），最终序列中没有多余的括号，所以使用栈或者计数器来统计括号出现是比较好的解法。 题中的Minimum remove非常的让人困惑怀疑题目是否存在某些边界条件，比如说字符串存在多种remove方式都可以获得有效字符串（不考虑同时remove paired括号），其中有一种需要移除的括号数目是最少的。仔细思考后会发现这种情况是不存在的，字符串可能存在多种移除方式，但是这些移除方式所移除的数目都是相同的。 class Solution: def minRemoveToMakeValid(self, s): left, right, output = 0, s.count(')'),'' for _chr in s: if _chr=='(': if right\u003e0: # 有效左括号 left+=1 right-=1 output+=_chr elif _chr==')': if left==0: # 无效右括号 right-=1 else: left-=1 output+=_chr else: # 非括号字符 output+=_chr return output 性能： 执行用时：1456 ms, 在所有 Python 提交中击败了29.47%的用户 内存消耗：14.8 MB, 在所有 Python 提交中击败了94.74%的用户 ","date":"2022-01-11","objectID":"/lc1249.minimum_remove_to_make_valid_parentheses/:0:0","tags":["linux","leetcode"],"title":"lc1249. Minimum Remove to Make Valid Parentheses","uri":"/lc1249.minimum_remove_to_make_valid_parentheses/"},{"categories":["leetcode"],"content":"Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class: MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. Example 1: Input [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 Constraints: -231 \u003c= val \u003c= 231 - 1 Methods pop, top and getMinoperations will always be called on non-empty stacks. At most 3 * 104 calls will be made to push, pop, top, and getMin. 解题思路 Stack进行push和pop操作都非常简单，困难的是如何操作getMin。 getMin即拿到stack中所有未出栈数据中的最小值，因此我们在push和pop时可以给每个数据附加上一个属性，即当前的最小值。 each element is (x,x), the first value if the real value and the second value if the current min value 有几个注意点： 考虑边界条件，比如说stack中的最后一个数据被pop 每次pop之后需要把当前最小值变为top数据的最小值。 class MinStack(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.data=[] self.current_min=None # each element is (x,x), the first value if the real value and the second value if the current min value def push(self, x): \"\"\" :type x: int :rtype: None \"\"\" if self.current_min==None: self.current_min=x self.data.append((x,self.current_min)) elif x\u003e=self.current_min: self.data.append((x,self.current_min)) elif x\u003cself.current_min: self.current_min=x self.data.append((x,self.current_min)) return None def pop(self): \"\"\" :rtype: None \"\"\" self.data.pop(-1) if len(self.data)==0: self.current_min=None else: self.current_min=self.data[-1][1] return None def top(self): \"\"\" :rtype: int \"\"\" return self.data[-1][0] def min(self): \"\"\" :rtype: int \"\"\" return self.data[-1][1] # Your MinStack object will be instantiated and called as such: # obj = MinStack() # obj.push(x) # obj.pop() # param_3 = obj.top() # param_4 = obj.min() 性能： 执行用时：108 ms, 在所有 Python 提交中击败了85.47%的用户 内存消耗：17 MB, 在所有 Python 提交中击败了5.14%的用户 其它可能解法： 辅助栈 取巧的方法可以直接使用min函数 ","date":"2022-01-08","objectID":"/lc155.min_stack/:0:0","tags":["linux","leetcode"],"title":"lc155.Min Stack","uri":"/lc155.min_stack/"},{"categories":["leetcode"],"content":"用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 输入： [\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2： 输入： [\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示： 1 \u003c= values \u003c= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 输入为两个栈， 第一个栈对应的是操作： [“CQueue”,“appendTail”,“deleteHead”,“deleteHead”] CQueue表示init一个CQueue object appendTail表示调用appendTail函数 deleteHead表示调用deleteHead函数 第二个栈对应的是操作的值。 栈（Stack）的特点是先入后出，但是我们需要实现直接操作Head的功能。因此使用两个Stack可以实现列表倒序。 class CQueue: def __init__(self): self.A, self.B = [], [] def appendTail(self, value: int) -\u003e None: self.A.append(value) def deleteHead(self) -\u003e int: if self.B: return self.B.pop() if not self.A: return -1 while self.A: self.B.append(self.A.pop()) return self.B.pop() 时间复杂度： appendTail()为O(1), deleteHead()为O(N) 空间复杂度：O(N) ","date":"2022-01-08","objectID":"/jz09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/:0:0","tags":["linux","leetcode"],"title":"剑指 Offer 09. 用两个栈实现队列","uri":"/jz09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"categories":["papers"],"content":"Title: A geometric deep learning approach to predict binding conformations of bioactive molecules DOI: https://doi.org/10.1038/s42256-021-00409-9 INFO: NATURE MACHINE INTELLIGENCE | VOL 3 | DECEMBER 2021 发表周期: Received: 18 May 2021; Accepted: 28 September 2021; Published online: 2 December 2021 药物设计是近年来AI应用的极火领域之一，其中一个最有挑战的问题就是空间结构设计。 One of the difficulties arises from the fact that only a small portion of the large chemical space will bind to a specific biological target and result in a therapeutic effect. 这篇文章中作者应用深度学习模型DeepDock捕获protein-ligand complex中的原子级微环境特征学习其中的结合构象。 数据集制备 The model reported in this study was trained using the general set of the PDBbind database (v.2019)30, which contains a collection of 17,679 protein–ligand structures with their respective potency (half-maximum inhibitory concentration, dissociation constant and so on). From these, we removed those complexes that are included in the CASF-2016 benchmark and those that failed during the preprocessing step, leaving a total of 16,367 protein–ligand complexes, which were randomly divided in a training set containing 15,000 complexes and a test set with 1,367. PDBbind数据库（http://www.pdbbind.org.cn）是基于PDB数据库，整合了大量实验统计所得的蛋白亲和力数据。 The PDBbind database is a comprehensive collection of experimentally measured binding affinity data (Kd, Ki, and IC50) for the protein-ligand complexes deposited in the Protein Data Bank (PDB).[1][2] It thus provides a link between energetic and structural information of protein-ligand complexes, which is of great value to various studies on molecular recognition occurred in biological systems. 作者使用图结构表示蛋白空间结构，node表示原子，edge表示bond。 Every node is represented by a one-hot vector that indicates the atom type among 28 possibilities (Be, B, C, N, O, F, Mg, Si, P, S, Cl, V, Fe, Co, Cu, Zn, As, Se, Br, Ru, Rh, Sb, I, Re, Os, Ir, Pt and Hg). 目标蛋白表面使用MSMS建模。 As in MaSIF, protein surfaces were triangulated using MSMS37 with a density of 3.0 nodes per Å^2 and a probe radius of 1.5 Å. The resulting meshes were downsampled to a resolution of 1 Å and processed using PyMesh. 只有具备结合位点性质的node才用于模型训练。 网络训练 如Fig1c，平行的图卷积网络被用来分别提取ligand和target结构中的表征以及特征编码。 Our approach directly uses the molecular surface of the binding site in the form of a polygon mesh. Both the target mesh and the ligand graph are processed by independent residual GNNs. Through this procedure, the processed node fea- tures not only contain information of an individual atom or point in the molecular surface, but also have information about the other nodes around them. In other words, the processed atom features encode all the atomic environment around a specific atom, whereas the target features encode a patch of the molecular surface around a specific point. GNN从ligand和target中分别提取出来的特征在特征向量上简单拼接后被送入mixture density network (MDN)。 by using this probability density function we can estimate the likelihood of finding ligand node i separated from a target node j by any distance $d_{ij}$. 模型评估 作者通过在CASF-2016 benchmark预测 Docking power Forward screening power Reverse screening power 来评估模型性能。 Docking power The evaluation of docking power measures the ability of a scor- ing function to identify native ligand binding poses among a set of decoys. Screening power The evaluation of screening power in CASF-2016 is designed to measure the ability of a scoring function to identify true binders of a specific target from a pool of random compounds. 模型细节 模型可分为3部分： 特征提取 特征融合 MDN First, the node and edge features are projected to a 128D embedding using a linear layer. We then use a sequence of three GNNs to update each node and edge based on their neighbouring nodes and the type of edges connecting them. After the initial processing by the GNNs, the node and edge features were processed by 10 residual GNN blocks. The MDN uses an MLP to create a hidden representation $h_{r,s}$ that combines the concatenated target and ligand node information. All MLPs used are composed of a linear layer followed by batch n","date":"2022-01-02","objectID":"/nmi-a-geometric-deep-learning-approach-to-predict-binding-conformations-of-bioactive-molecules/:0:0","tags":["NMI","Machine learning","proteins"],"title":"[NMI] A geometric deep learning approach to predict binding conformations of bioactive molecules 解读","uri":"/nmi-a-geometric-deep-learning-approach-to-predict-binding-conformations-of-bioactive-molecules/"},{"categories":["database"],"content":"ER diagram Notation: Chen Notation Crow’s Foot Notation UML Class Diagram Notation ","date":"2022-01-02","objectID":"/er_diagram_notation/:0:0","tags":["SQL","database"],"title":"ER Diagram Notation","uri":"/er_diagram_notation/"},{"categories":["system"],"content":"Example MD ","date":"2022-01-01","objectID":"/example/:0:0","tags":["linux"],"title":"Example","uri":"/example/"},{"categories":["system"],"content":"Problem Description Fors some unknow reason, the user is unable to click the text boxes or type anything into the publish window after running the Build \u0026 Publish. When the user clicks the main window in Unity, the cursor disappears and the user can not select the text boxes or anything else. This problem happens under my settings, macOS Catalina 10.15.7, Unity 2019.4.31f1, VRChat SDK3. Solution The reason of this problem is that when you click the temp scene created by the SDK3, the cursor will be invisible and locked. Find this file: VRCSDK/Dependencies/VRChat/ Scripts/RuntimeWorldCreation.cs Find this content, marked function Start(). new void Start() { if (!Application.isEditor || !Application.isPlaying) return; base.Start(); IsCurrentWorldInCommunityLabs = false; IsCurrentWorldUploaded = false; IsCurrentWorldPubliclyPublished = false; var desc = pipelineManager.GetComponent\u003cVRC.SDKBase.VRC_SceneDescriptor\u003e(); desc.PositionPortraitCamera(imageCapture.shotCamera.transform); Application.runInBackground = true; UnityEngine.XR.XRSettings.enabled = false; uploadButton.onClick.AddListener(SetupUpload); openCommunityLabsDocsButton.onClick.AddListener(OpenCommunityLabsDocumentation); shouldUpdateImageToggle.onValueChanged.AddListener(ToggleUpdateImage); releasePublic.gameObject.SetActive(false); System.Action\u003cstring\u003e onError = (err) =\u003e { VRC.Core.Logger.LogError(\"Could not authenticate - \" + err, DebugLevel.Always); blueprintPanel.SetActive(false); errorPanel.SetActive(true); }; Add 2 lines. Cursor.visible=true; Cursor.lockState=0; Now the final content will be new void Start() { Cursor.visible=true; Cursor.lockState=0; if (!Application.isEditor || !Application.isPlaying) return; base.Start(); IsCurrentWorldInCommunityLabs = false; IsCurrentWorldUploaded = false; IsCurrentWorldPubliclyPublished = false; var desc = pipelineManager.GetComponent\u003cVRC.SDKBase.VRC_SceneDescriptor\u003e(); desc.PositionPortraitCamera(imageCapture.shotCamera.transform); Application.runInBackground = true; UnityEngine.XR.XRSettings.enabled = false; uploadButton.onClick.AddListener(SetupUpload); openCommunityLabsDocsButton.onClick.AddListener(OpenCommunityLabsDocumentation); shouldUpdateImageToggle.onValueChanged.AddListener(ToggleUpdateImage); releasePublic.gameObject.SetActive(false); System.Action\u003cstring\u003e onError = (err) =\u003e { VRC.Core.Logger.LogError(\"Could not authenticate - \" + err, DebugLevel.Always); blueprintPanel.SetActive(false); errorPanel.SetActive(true); }; if (!ApiCredentials.Load()) onError(\"Not logged in\"); else APIUser.InitialFetchCurrentUser( delegate (ApiModelContainer\u003cAPIUser\u003e c) { UserLoggedInCallback(c.Model as APIUser); }, delegate (ApiModelContainer\u003cAPIUser\u003e c) { onError(c.Error); } ); Now rebuild, you find you can edit the texts now. ","date":"2021-12-17","objectID":"/vrcsdk_can_not_edit_text/:0:0","tags":["linux"],"title":"Unable to interact with text boxes during Build \u0026 Publish for VRChat SDK3","uri":"/vrcsdk_can_not_edit_text/"},{"categories":["system"],"content":" Avticate your environment，check for package ipykernel python -m ipykernel --version If it’s not installed： python -m pip install ipykernel Add kernel to Jupyter notebook python -m ipykernel install --user --name 'kernelname' Check Jupyter notebook kernel jupyter kernelspec list Delet jupyter kernel jupyter kernelspec remove kernelname Update 2022.09.25: If you encounter the error: ImportError: cannot import name ‘AsyncGenerator’ The reason is that the version of prompt_toolkit does not match Python 3.6 The solution is to reduce the version pip install --upgrade prompt-toolkit==2.0.1 Then you can add the kernel to notebook. ","date":"2021-11-28","objectID":"/install-jupyter-kernel/:0:0","tags":["system","linux","conda","python"],"title":"Install kernel for jupyter notebook","uri":"/install-jupyter-kernel/"},{"categories":["leetcode"],"content":"Given a string s, find the length of the longest substring without repeating characters. Example 1: Input: s = \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: s = \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: s = \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring. Example 4: Input: s = \"\" Output: 0 Constraints: 0 \u003c= s.length \u003c= 5 * 104 s consists of English letters, digits, symbols and spaces. Thinking The simplest method to do is the brute force searching. Given a substring, we check whether it contains repeated characters. Then for all substrings of a given string, we do such a test and the total number of substrings of a given string with length $n$ is $n*(n+1)/2$. For example, For each substring str[i, j] i.e. starting from index i and ending at index j, we use a function areUnique(str, i, j) to check if all the characters in the substring are unique or not. It will return true if all the characters are unique, otherwise false. The time complexity of areUnque(str,i,j) is $O(j-i+1)$. So the overall time compelxity is $n*(n+1)/2*O(j-i+1)=O(n^2)*O(j-i+1)$. In the worst-case, $O(j-i+1)=O(n)$, so the worst-case overall time complexity is $O(n^3)$. We are using few extra variables and a constant size set visited[]. So space complexity = O(1). To optimize, here is an optimization insight: In the brute force idea, we repeatedly check a substring starting from the character str[i] to see if it has a duplicate character or not. We can optimize it further because, during the loop, if a substring str[i, j-1] is already checked to have no duplicate characters, then for the substring str[i, j], we only need to check if str[j] is already present in the substring str[i, j-1] or not. Partially cited from: https://www.enjoyalgorithms.com/blog/longest-substring-without-repeating-characters 暴力解法： class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" _max=0 for i in range(len(s)): sub=[s[i]] for j in range(i+1,len(s)): if s[j] not in sub: sub.append(s[j]) else: break if len(sub)\u003e_max: _max=len(sub) return _max 时间复杂度为O(N^2) 滑动窗口解法： class Solution: def lengthOfLongestSubstring(self, s): if not s:return 0 left = 0 lookup = set() n = len(s) max_len = 0 cur_len = 0 for i in range(n): cur_len += 1 while s[i] in lookup: lookup.remove(s[left]) left += 1 cur_len -= 1 if cur_len \u003e max_len:max_len = cur_len lookup.add(s[i]) return max_len 时间复杂度为O(N) ","date":"2021-11-18","objectID":"/lc3.longest_substring_without_repeating_characters/:0:0","tags":["coding"],"title":"lc3.Longest Substring Without Repeating Characters","uri":"/lc3.longest_substring_without_repeating_characters/"},{"categories":["interview"],"content":"Q. What are genetic algorithm and evolutionary algorithm? Genetic algorithm (GA) is a sub-class of evolutionary algorithm (EA). There are 3 implementation of EAs: GA, evolution strategies (ES), and evolutionary programming (EP). Among these, GAs have proved to be the most popular of the 3 EAs. These algorithms are similar in general, yet there are big differences among them: GA: They were developed by Holland and thoroughly reviewed by Goldberg; ES: They were developed by Rechenberg and Schwefe; and EP: It was developed by L.J. Fogel and D.B. Fogel. Similarity and Differences: All 3 operate on fixed length strings, which contain real values in ESs and EP and binary numbers in the canonical GA. All 3 incorporate a mutation operator: for ESs and EP mutation is the driving force. GAs and ESs also use a recombination operator, which is the primary operator for the GA. All 3 use a selection operator which applies evolutionary pressure, either instinctive (in ESs and EP, the operator determines which individuals will be excluded from the new population) or preservative (in the GA the operator selects individuals for breeding).. In GAs and EP selection is probabilistic, while ESs use a deterministic selection. ESs and meta-EP allow self-adaptation, where parameters controlling mutation are allowed to evolve along with object variables. Finally, it is worth noting that the implementer is free to modify these algorithms. For example, the GA can be run using an integer alphabet. From: https://www.researchgate.net/post/Are_Genetic_Algorithms_GA_and_Evolutionary_Algorithms_EA_the_same_or_different ","date":"2021-11-14","objectID":"/i4.gaea/:0:0","tags":["interview","machine learning"],"title":"i4.genetic algorithm and evolutionary algorithm","uri":"/i4.gaea/"},{"categories":["system"],"content":"Install sudo apt install slurm-wlm slurm-wlm-doc -y Modify config rm /etc/slurm-llnl/slurm.conf vi /etc/slurm-llnl/slurm.conf Example of config # slurm.conf file generated by configurator easy.html. # Put this file on all nodes of your cluster. # See the slurm.conf man page for more information. # ControlMachine=girl #ControlAddr= # #MailProg=/bin/mail MpiDefault=none #MpiParams=ports=#-# ProctrackType=proctrack/pgid ReturnToService=1 SlurmctldPidFile=/var/run/slurm-llnl/slurmctld.pid #SlurmctldPort=6817 SlurmdPidFile=/var/run/slurm-llnl/slurmd.pid #SlurmdPort=6818 SlurmdSpoolDir=/var/spool/slurmd SlurmUser=slurm #SlurmdUser=root StateSaveLocation=/var/spool/slurm-llnl SwitchType=switch/none TaskPlugin=task/none # # # TIMERS #KillWait=30 #MinJobAge=300 #SlurmctldTimeout=120 #SlurmdTimeout=300 # # # SCHEDULING FastSchedule=1 SchedulerType=sched/backfill SelectType=select/linear #SelectTypeParameters= # # # LOGGING AND ACCOUNTING AccountingStorageType=accounting_storage/none ClusterName=cluster #JobAcctGatherFrequency=30 JobAcctGatherType=jobacct_gather/none #SlurmctldDebug=3 #SlurmctldLogFile= #SlurmdDebug=3 #SlurmdLogFile= # # # COMPUTE NODES NodeName=girl CPUs=4 State=UNKNOWN PartitionName=debug Nodes=girl Default=YES MaxTime=INFINITE State=UP Mkdir and Chown rm -rf /var/spool/slurm-llnl mkdir /var/spool/slurm-llnl chown -R slurm.slurm /var/spool/slurm-llnl rm -rf /var/run/slurm-llnl/ mkdir /var/run/slurm-llnl/ chown -R slurm.slurm /var/run/slurm-llnl/ Start slurmd and enable on boot systemctl start slurmd systemctl enable slurmd systemctl start slurmctld systemctl enable slurmctld Start service systemctl restart slurmctld systemctl restart slurmd ","date":"2021-11-14","objectID":"/install-slurm/:0:0","tags":["system","linux"],"title":"Install Slurm in Ubuntu","uri":"/install-slurm/"},{"categories":["system"],"content":"问题在于VNCServer使用Python编写，所以受到系统Python版本影响。 解决方案： $ cd $HOME $ vim .bashrc 找到如下语句： export PATH=\"/home/user/anaconda2/bin:$PATH\" 并修改为，并保存退出。 export PATH=\"$PATH:/home/user/anaconda2/bin\" $ vncserver -kill :id $ source .bashrc $ conda config --set auto_activate_base false #取消conda自动启动base ","date":"2021-11-14","objectID":"/%E5%AE%89%E8%A3%85python%E5%AF%BC%E8%87%B4vnc%E7%95%8C%E9%9D%A2%E9%BB%91%E5%B1%8F/:0:0","tags":["system","linux"],"title":"安装Python导致VNC黑屏解决方案","uri":"/%E5%AE%89%E8%A3%85python%E5%AF%BC%E8%87%B4vnc%E7%95%8C%E9%9D%A2%E9%BB%91%E5%B1%8F/"},{"categories":["interview"],"content":"Q. What Are the Different Types of Machine Learning? Supervised learning A model makes predictions or decisions based on past or labeled data. Labeled data refers to sets of data that are given tags or labels, and thus made more meaningful. Unsupervised learning In this case, we don’t have labeled data, a model can identify patterns, anomalies, and relationships in the input data. Reinforcement learning The model learn based on the rewards received from the previous action. ","date":"2021-11-08","objectID":"/i3.different-types-of-machine-learning/:0:0","tags":["interview","machine learning"],"title":"i3.different types of machine learning","uri":"/i3.different-types-of-machine-learning/"},{"categories":["leetcode"],"content":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 1: Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. Example 2: Input: l1 = [0], l2 = [0] Output: [0] Example 3: Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1] Constraints: The number of nodes in each linked list is in the range [1, 100]. 0 \u003c= Node.val \u003c= 9 It is guaranteed that the list represents a number that does not have leading zeros. Thinking To understand the question, we need to specify: 2-\u003e4-\u003e3 stands for the number 342 5-\u003e6-\u003e4 stands for the number 465 So, the sum should be 807, which can be represented as 7-\u003e0-\u003e8 Then the process goes easily. Firstly we add 2 and 5, which is the first element of both lists, if the sum is smaller than 10, then we simply output the sum to the corresponding element in the output list. Let’s say 2+5-\u003e7. If sum is \u003e=10, we leave the mode to the corresponding position in the output list and add 1 to the follow position as we know the sum \u003c=19 (9+9+?1), here ?1 depends on whether there is a 1 from the previous position. Solution class Solution: def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -\u003e Optional[ListNode]: _add2next=0 initialNode=ListNode() currentNode=initialNode while True: try: _l1=l1.val except: _l1=0 try: _l2=l2.val except: _l2=0 _sum=_l1+_l2+_add2next currentNode.val=_sum%10 _add2next=_sum//10 try: l1=l1.next except: l1=None try: l2=l2.next except: l2=None if l1==l2==None and _add2next==0: break elif l1==l2==None and _add2next==1: currentNode.next=ListNode(val=1) break else: nextNode=ListNode() currentNode.next=nextNode currentNode=nextNode return initialNode Runtime: 68ms Memory: 14.4MB ","date":"2021-11-07","objectID":"/lc2.add2numbers/:0:0","tags":["coding"],"title":"lc2.Add Two Numbers","uri":"/lc2.add2numbers/"},{"categories":["system"],"content":"MacOS install uPic brew install uPic Set uPic Set uPic host to Github The default host is SMMS Set Typora uploading to uPic ","date":"2021-11-07","objectID":"/typora-upic-github-image-hosting-service/:0:0","tags":["linux"],"title":"typora \u0026 uPic \u0026 Github image hosting service","uri":"/typora-upic-github-image-hosting-service/"},{"categories":["system"],"content":"Mofidy .inputrc sudo vi ~/.inputrc Add this line set completion-ignore-case on Restart your terminal Now you can ignore the upper and lower case when you use Tab in terminal ","date":"2021-11-05","objectID":"/how-to-ignore-upperlower-case-with-tab-in-ubuntu/:0:0","tags":["linux"],"title":"How to ignore upper and lower case when using Tab in Ubuntu","uri":"/how-to-ignore-upperlower-case-with-tab-in-ubuntu/"},{"categories":["system"],"content":"Mofidy bash.bashrc sudo vi /etc/bash.bashrc Find those code in the file #enable bash completion in interactive shells #if ! shopt -oq posix; then # if [-f /usr/share/bash-completion/bash_completion ]; then # . /usr/share/bash-completion/bash_completion # elif [ -f /etc/bash_completion]; then # . /etc/bash_completion # fi #fi Remove # Like below: #enable bash completion in interactive shells if ! shopt -oq posix; then if [-f /usr/share/bash-completion/bash_completion ]; then . /usr/share/bash-completion/bash_completion elif [ -f /etc/bash_completion]; then . /etc/bash_completion fi fi Source it sudo source /etc/bash.bashrc Now you can use Tab to autocomplete your command ","date":"2021-11-04","objectID":"/how-to-set-autocomplete-in-ubuntu/:0:0","tags":["linux"],"title":"How to set autocomplete in Ubuntu","uri":"/how-to-set-autocomplete-in-ubuntu/"},{"categories":["interview"],"content":"Q. How Many Times Do A Clock’s Hands Overlap In A Day? The most important is not the answer but the way to think and work out problems. In total 22, because the clock hands approximately overlap at 12:00, 1:05, 2:10, 3:15, 4:20, 5:25, 6:30, 7:35, 8:40, 9:45 and 10:50 twice a day. Although reaching the wrong answer is fine to an extent, you should avoid these common errors. Don’t just blurt out an answer without thinking it through. If you give the wrong answer, don’t get flustered. Don’t say, “I don’t know.” Don’t sit in silence. If you just sit in your chair quietly, then the interviewer is not going to know how you came to your answer. Talking the answer out gives the hiring manager valuable insight into how you are able to think. cite from: https://www.livecareer.com/resources/interviews/questions/how-many-times-do-a-clocks-hands-overlap-in-a-day ","date":"2021-11-04","objectID":"/i2.clock-hand-overlap/:0:0","tags":["interview","thinking"],"title":"i2.How Many Times Do A Clock’s Hands Overlap In A Day?","uri":"/i2.clock-hand-overlap/"},{"categories":["system"],"content":"Install You can find it at here: https://github.com/svenstaro/miniserve/releases Usage miniserve --help miniserve 0.4.1 Sven-Hendrik Haase \u003csvenstaro@gmail.com\u003e, Boastful Squirrel \u003cboastful.squirrel@gmail.com\u003e For when you really just want to serve some files over HTTP right now! USAGE: miniserve [FLAGS] [OPTIONS] [--] [PATH] FLAGS: -u, --upload-files Enable file uploading -h, --help Prints help information -P, --no-symlinks Do not follow symbolic links -o, --overwrite-files Enable overriding existing files during file upload --random-route Generate a random 6-hexdigit route -V, --version Prints version information -v, --verbose Be verbose, includes emitting access logs OPTIONS: -a, --auth \u003cauth\u003e Set authentication (username:password) -c, --color-scheme \u003ccolor_scheme\u003e Default color scheme [default: Squirrel] [possible values: Archlinux, Zenburn, Monokai, Squirrel] -i, --if \u003cinterfaces\u003e... Interface to listen on -p, --port \u003cport\u003e Port to use [default: 8080] ARGS: \u003cPATH\u003e Which path to serve Serve single folder miniserve share/ -u -o Serve single file miniserve file Start user verification miniserve --auth joe:123 some_dir ","date":"2021-11-04","objectID":"/miniserver/:0:0","tags":["linux"],"title":"Miniserve, an elegant file server","uri":"/miniserver/"},{"categories":["interview"],"content":"Q. What is the most efficient way to sort a million integers? Time Complexity Sorting Algorithm Average Case Best Case Worst Case Bubble Sort O(n^2) O(n) O(n^2) Insertion Sort O(n^2) O(n) O(n^2) Selection Sort O(n^2) O(n^2) O(n^2) Quick Sort O(n.log(n)) O(n.log(n)) O(n^2) Merge Sort O(n.log(n)) O(n.log(n)) O(n.log(n)) Heap Sort O(n.log(n)) O(n.log(n)) O(n.log(n)) Counting Sort O(n+k) O(n+k) O(n+k) Radix Sort O(n*k) O(n*k) O(n*k) Bucket Sort O(n+k) O(n+k) O(n^2) Space Complexity Sorting Algorithm Space Complexity Bubble Sort O(1) Insertion Sort O(1) Selection Sort O(1) Quick Sort O(log(n)) Merge Sort O(n) Heap Sort O(1) Counting Sort O(k) Radix Sort O(n + k) Bucket Sort O(n) Stability Sorting Algorithm Stable Sort? Bubble Sort Yes Insertion Sort Yes Selection Sort No Quick Sort No Merge Sort Yes Heap Sort No Counting Sort Yes Radix Sort Yes Bucket Sort Yes Consider above all, merge sort will be the best choice. ","date":"2021-11-03","objectID":"/i1.sort-1-million/:0:0","tags":["interview","bat","algorithm"],"title":"i1.What is the most efficient way to sort a million integers?","uri":"/i1.sort-1-million/"},{"categories":["coding"],"content":"Install Conda Packaging Tool conda install conda-build anaconda-client ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:0","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"File Structure - home/ - my_package/ - my_package/ - package_lib/ - setup.py - README.md - run_test.py - build.sh - meta.yaml ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:1","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"meta.yaml This file tells conda-build how to package files under my_package/ package: name: my_package version: 1.1.2 source: path: my_package/my_package/ build: number: 0 requirements: build: - python \u003e=3 - setuptools run: - python \u003e=3 - numpy \u003e=1.20 - scipy - pandas - scikit-learn \u003e=0.22 - lightgbm - matplotlib - seaborn - plink \u003e=1.9 test: source_files: - run_test.py about: home: https://github.com/JoshuaChou2018 license: MIT ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:2","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"build.sh The build.sh script contains methods to compile and install. So we use setuptools to complete the compilation and installation process. Content of build.sh # Install my_package $PYTHON setup.py install ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:3","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"setup.py # -*- coding: utf-8 -*- from setuptools import setup, find_packages setup( name='my_package', version='1.0.3', description=( 'my_package' ), author='my_package', author_email='my_package', maintainer='my_package', maintainer_email='my_package', license='MIT License', url='https://github.com/JoshuaChou2018/my_package', packages=find_packages(), entry_points={ 'console_scripts': [ 'run = my_package.entry:main', ] }, classifiers=[ 'Operating System :: OS Independent', 'License :: OSI Approved :: MIT License', 'Programming Language :: Python :: 3' ], python_requires='\u003e=3' ) ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:4","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"Start build conda build my_package/ ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:5","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"Publish anaconda login anaconda upload /home/miniconda3/conda-bld/linux-64/my_package-1.0.0-py39_0.tar.bz2 ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:6","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":null,"content":"Juexiao Zhou 周觉晓 Tenure-track Assistant Professor @CUHK-Shenzhen Healthcare Ethical AI Lab, HEAL (意为“治愈”，技术创新助力延长人类寿命) School of Data Science The Chinese University of Hong Kong, Shenzhen Email: juexiao.zhou[AT]gmail.com Office: Zhi Xin Building, 403b, CUHK-Shenzhen CV (last update: 2025.6) | Github | Linkedln | ORCID | Google Scholar Openings: Plans 25 Fall 26 Spring 26 Summer 26 Fall Remote/Onsite Intern Full Open Open Open PhD/MPhil students Full Full - Open (2) Research Assistant Full Full Full Open (2) Recent News: Aug 2025, I have joined CUHK-Shenzhen as an Assistant Professor Jun 2025, I am happy to serve as the editor of npj Artificial Intelligence May 2025, got my Doctor of Philosophy degree, Ph.D. in Computer Science at King Abdullah University of Science and Technology. May 2025, passed my Ph.D. dissertation defense titled \"Towards Privacy-preserving Artificial Intelligence (PAI) for Healthcare and Bioinformatics\" May 2025, I am happy to serve as the co-chair of IS-HIS 2025 Symposium, ICCNS2025, Varna, Bulgaria Mar 2025, fair medical LLM paper is accepted by Nature Computational Science (IF=12) Feb 2025, I am invited to attend the launching ceremony of The Global AI for Science Developer Community, 2025 Global Developer Conference, Shanghai, China Jan 2025, pulmonary artery and vein segmentation paper is accepted by Nature Communications (IF=17) Dec 2024, chemical LLM paper is accepted by Communications Chemistry (IF=5.9) Nov 2024, I am happy to join the Editorial Board of BMC Bioinformatics Nov 2024, We showcased MOSS2.ai at Saudi's first Space Tech Incubation Program Sep 2024, GBD 2021 upper respiratory infections is accepted by The Lancet Infectious Diseases (IF=36.4) Aug 2024, AutoBA is accepted by Advanced Science (IF=15.1) Jul 2024, our recent work SkinGPT-4 is reported by Arab News Jun 2024, SkinGPT-4 paper is accepted by Nature Communications (IF=17) Jun 2024, a paper is accepted by Bioinformatics (IF=5.8) May 2024, GBD 2021 Forecasting Capstone paper is accepted by The Lancet (IF=168.9) May 2024, GBD 2021 Risk Factors Capstone paper is accepted by The Lancet (IF=168.9) May 2024, a paper is accepted by Computers in Biology and Medicine (IF=7.7) Apr 2024, GBD 2021 Global incidence, prevalence, YLDs, DALYs, and HALE paper is accepted by The Lancet (IF=168.9) Apr 2024, GBD 2021 Causes of Death paper is accepted by The Lancet (IF=168.9) Mar 2024, GBD 2021 Global fertility paper is accepted by The Lancet (IF=168.9) Mar 2024, Patient privacy paper is accepted by Trends in Genetics (IF=11.4) Mar 2024, GBD 2021 Demographics paper is accepted by The Lancet (IF=168.9) Feb 2024, invited to the TV show \"Investing Now for Future in Hong Kong and the Middle East：New Cradle of Innovation\" by RTHK 香港電台 Dec 2023, PPML-Omics is accepted by Science Advances (IF=15.4) Dec 2023, PPPML-HMI is accepted by Computers in Biology and Medicine (IF=7.7) Nov 2023, invited to give a talk to the Saudi Olympiad Elite Camp Oct 2023, AFS is accepted by Nature Communications (IF=17) Sep 2023, passed my Ph.D. proposal titled \"Towards Privacy-preserving Artificial General Intelligence (PAGI) for Healthcare and Bioinformatics\" Jun 2023, COVID-19 paper is accepted by Nature Communications (IF=17) Mar 2023, spatial transcriptomics paper is accepted by Nature Communications (IF=17) Feb 2023, invited to give a talk at Rising Stars in AI Symposium 2023 at KAUST Oct 2022, DeeReCT-TSS paper is accepted by Genomics, Proteomics \u0026 Bioinformatics (IF=10.1) May 2022, COVID-19 paper is accepted by Nature Machine Intelligence (IF=27.2) Dec 2021, got my master of science degree, M.S. in Computer Science at King Abdullah University of Science and Technology. ","date":"0001-01-01","objectID":"/about/:0:1","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Education He got the Ph.D. degree in Computer Science at King Abdullah University of Science and Technology under the supervision of Prof. Xin Gao from Dec 2021 - May 2025. He got the Master of Science degree, M.S. in Computer Science at King Abdullah University of Science and Technology under the supervision of Prof. Xin Gao in Dec 2021. He got the Bachelor of Science degree, B.S. (Honored) in Bioinformatics at Southern University of Science and Technology under the supervision of Prof. Wei Chen in Jun 2020. I said “Hello World” in January 1999 in China. ","date":"0001-01-01","objectID":"/about/:0:2","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Research Interests AI-driven Intelligent Healthcare: I develop cutting-edge AI algorithms, particularly DL and LLMs, to enable disease detection, prognosis, and risk assessment across clinical settings. Bioinformatics: I develop intelligent computational frameworks to decode gene regulatory networks, predict protein function and structure, and model complex biological systems. I also develop curiosity-driven AI scientists based on AI agents. Ethical and Trustworthy AI in Healthcare: I investigate the ethical and societal implications of AI in medicine, focusing on pressing challenges such as privacy, security, bias, fairness, toxicity and so on. ","date":"0001-01-01","objectID":"/about/:0:3","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Selected Publications (# equal contribution, * corresponding author) [Full list] Pre-trained Multimodal Large Language Model Enhances Dermatological Diagnosis using SkinGPT-4. Juexiao Zhou#, Xiaonan He#, Liyuan Sun#, Jiannan Xu, Xiuying Chen, Yuetan Chu, Longxi Zhou, Xingyu Liao, Bin Zhang, Shawn Afvari, Xin Gao* Nature Communications DOI: https://doi.org/10.1038/s41467-024-50043-3 Access: online, pdf Press: Arab News, ChicHue, KAUST Discovery, 转化医学网 A unified method to revoke the private data of patients in intelligent healthcare with audit to forget. Juexiao Zhou#, Haoyang Li#, Xingyu Liao, Bin Zhang, Wenjia He, Zhongxiao Li, Longxi Zhou, Xin Gao* Nature Communications DOI: 10.1038/s41467-023-41703-x Access: online, pdf Press: KAUST Discovery, Enerzine PPML-Omics: A privacy-preserving federated machine learning method protects patients’ privacy in omic data. Juexiao Zhou#, Siyuan Chen#, Yulian Wu#, Haoyang Li, Bin Zhang, Longxi Zhou, Yan Hu, Zihang Xiang, Zhongxiao Li, Ningning Chen, Wenkai Han, Di Wang and Xin Gao*. Science Advances DOI: 10.1126/sciadv.adh8601 Access: online, pdf Press: Inside Precision Medicine, Today Headline, Tech Xplore, ScienMag, Bioengineer.org, Newswise, EurekAlert, Biocompare, nabd.ws An AI Agent for Fully Automated Multi-omic Analyses. Juexiao Zhou#, Bin Zhang#, Guowei Li, Xiuying Chen, Haoyang Li, Xiaopeng Xu, Siyuan Chen, Liwei Liu, Xin Gao* Advanced Science DOI: https://doi.org/10.1002/advs.202407094 Access: online, pdf Press: CBIRT news, Medium Patient privacy in AI-driven omics methods. Juexiao Zhou, Chao Huang, Xin Gao Trends in Genetics DOI: https://doi.org/10.1016/j.tig.2024.03.004 Access: online, pdf Annotating TSSs in Multiple Cell Types Based on DNA Sequences and RNA-seq Data via DeeReCT-TSS. Juexiao Zhou#, Bin Zhang#, Haoyang Li, Longxi Zhou, Zhongxiao Li, Yongkang Long, Wenkai Han, Mengran Wang, Huanhuan Cui, Wei Chen, Xin Gao*. Genomics, Proteomics \u0026 Bioinformatics DOI: 10.1016/j.gpb.2022.11.010 Access: online, pdf Personalized and privacy-preserving federated heterogeneous medical image analysis with PPPML-HMI. Juexiao Zhou#, Longxi Zhou#, Di Wang, Xiaopeng Xu, Haoyang Li, Yuetan Chu, Wenkai Han, Xin Gao* Computers in Biology and Medicine DOI: 10.1016/j.compbiomed.2023.107861 Access: online, pdf A comprehensive benchmarking with practical guidelines for cellular deconvolution of spatial transcriptomics. Haoyang Li#, Juexiao Zhou#, Zhongxiao Li, Siyuan Chen, Xingyu Liao, Bin Zhang, Ruochi Zhang, Yu Wang, Shiwei Sun, Xin Gao* Nature Communications DOI: 10.1038/s41467-023-37168-7 Access: online, pdf Press: BioMed, CBIRT news, KAUST news Chosen as Editors’ Highlights in Nature Communications An Interpretable Deep Learning Workflow for Discovering Sub-Visual Abnormalities in CT Scans of COVID-19 Inpatients and Survivors. Longxi Zhou#, Xianglin Meng#, Yuxin Huang#, Kai Kang#, Juexiao Zhou, Yuetan Chu, Haoyang Li, Dexuan Xie, Jiannan Zhang, Weizhen Yang, Na Bai, Yi Zhao, Mingyan Zhao, Guohua Wang, Lawrence Carin, Xigang Xiao, Kaijiang Yu, Zhaowen Qiu, Xin Gao*. Nature Machine Intelligence DOI: 10.1038/s42256-022-00483-7 Access: online, pdf Evaluating and mitigating bias in AI-based medical text generation. Xiuying Chen, Tairan Wang, Juexiao Zhou, Zirui Song, Xin Gao, Xiangliang Zhang Nature Computational Science DOI: 10.1038/s43588-025-00789-7 Access: online, pdf ","date":"0001-01-01","objectID":"/about/:0:4","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Short Bio Juexiao Zhou is a Tenure-track Assistant Professor at the School of Data Science, The Chinese University of Hong Kong, Shenzhen. He obtained his bachelor’s degree in Bioinformatics from the Southern University of Science and Technology (SUSTech) in 2020 and his Ph.D. degree in Computer Science from King Abdullah University of Science and Technology (KAUST) in 2025. His research lies at the intersection of computer science and biomedicine, with a primary focus on AI-driven intelligent healthcare, bioinformatics, and ethical and trustworthy AI in healthcare. Juexiao develops cutting-edge deep learning models and large language models (LLMs) to enable disease detection, prognosis, and risk assessment across clinical settings. In the domain of bioinformatics, he builds intelligent computational frameworks to decode gene regulatory networks, predict protein structure and function, and model complex biological systems. His recent research also explores curiosity-driven AI agents as autonomous scientific researchers. He is committed to advancing ethical AI in healthcare, tackling key challenges such as data privacy, bias, fairness, security, toxicity, and the broader implications of emerging Artificial General Intelligence (AGI) in clinical practice. Juexiao has authored over 30 publications in top-tier journals and conferences, including Science Advances, Nature Machine Intelligence, Nature Computational Science, Nature Communications, The Lancet, Genome Research, Trends in Genetics, Bioinformatics, IEEE TMI, and MICCAI. His work has been featured by major media outlets such as Arab News, Radio Television Hong Kong (RTHK), and Inside Precision Medicine. He is an active member of CAAI, APBioNET, and GBD. He serves as a reviewer for leading journals and conferences, including Nature, Nature Methods, Nature Communications, Medical Image Analysis, Genome Biology, Genome Research, NeurIPS, SIGKDD, and MICCAI. He is also an editorial board member of BMC Bioinformatics and a guest editor for Biomedical Informatics. ","date":"0001-01-01","objectID":"/about/:0:5","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Academia Experience Tenure-track Assistant Professor in Computer Science, The Chinese University of Hong Kong, Shenzhen, Aug 2025 - Present Student Ambassador, CEMSE, King Abdullah University of Science and Technology, Dec 2021 - Apr 2025 ","date":"0001-01-01","objectID":"/about/:0:6","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Industry Experience Co-founder \u0026 CEO, MOSS.ai, Sep 2024 Co-founder \u0026 Chief Scientist, BeautyX.ai, Sep 2024 Co-founder \u0026 Chief AI Scientist, DermAssure.ai, April 2024 ","date":"0001-01-01","objectID":"/about/:0:7","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Teaching Experience [Full list] CS220, Data Analytics - AI Camp for Ministry of Interior, Fall 2024/2025, Saudi Arabia Cooperated with Prof. Xin Gao Position: Teaching Assistant CS220, Data Analytics, Fall 2024/2025, KAUST Cooperated with Prof. Xin Gao Position: Teaching Assistant CS220, Data Analytics - AI Camp for Ministry of Interior, Fall 2023/2024, Saudi Arabia Cooperated with Prof. Xin Gao Position: Senior Teaching Assistant CS220, Data Analytics, Fall 2022/2023, KAUST Cooperated with Prof. Xin Gao Position: Teaching Assistant BioE 201/230 Foundations of Bioengineering, Fall 2022/2023, KAUST Cooperated with Prof. Xin Gao Position: Guest Lecturer, Building 9 Room 4225 Contents: Lab 1. Genome data analysis, 2022.08.30, colab Python basics D/RNA sequence analysis Biopython BLAST Reference genome Lab 2. Protein sequence analysis, 2022.09.06, colab Protein sequence analysis MSA PDB PyMOL Secondary structure prediction Lab 3. Protein structure and function, 2022.09.13, colab Ab initio with PyRosetta AlphaFold2 NucleicNet Docking with Smina Pfam annotation with deep learning CS398 Graduate Seminar, Spring 2022, KAUST Cooperated with Prof. Dominik Michels Position: Teaching Assistant ","date":"0001-01-01","objectID":"/about/:0:8","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Mentoring [Full list] I’m very glad to work and grow together with these excellent students. ","date":"0001-01-01","objectID":"/about/:0:9","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Honors \u0026 Awards King Abdullah University of Science and Technology KAUST, 2021-Present PhD, Computer Science GPA: 4.00 / 4.00 CEMSE Dean’s List Award, 2025 CEMSE Dean’s List Award, 2024 CEMSE Dean’s List Award, 2023 KAUST AII’s NeurIPS travel grant, 2022 CEMSE Dean’s List Award, 2022 Excellent Research Award, CEMSE, 2021 King Abdullah University of Science and Technology KAUST, 2020-2021 Master of Science, Computer Science GPA: 3.95 / 4.00 Student ambassador, CEMSE, 2021 Yearly best student award, CEMSE, 2021 Full scholarship for MS/PhD study, 2020 Southern University of Science and Technology SUSTech, 2016-2020 Bachelor of Science, Bioinformatics, Biology GPA: 3.92 / 4.00 (Top 0.1%), Core GPA: 3.94/4.00 Outstanding graduate of SUSTech, 2020. Cum Laude Graduate of the Department of Biology (Top 1/10), 2020. The Guinness world record for “the most vows received by a single civilized act activity”, 2019 Candidate for 2019 National Scholarship, 2019 Summer social practice excellent experience Award, 2018 Excellent Student, The First Prize Scholarship, 2018 Outstanding volunteer for the 12th CBIS Biennial Meeting, Shenzhen, China, 2018 Candidate for 2018 National Scholarship, 2018 Outstanding Volunteer of the 3rd Shenzhen International Life Science \u0026 Health Industry Summit (2016) Excellent Student, The First Prize Scholarship, 2017 Dean scholarship, The First Prize Scholarship, 2017 Excellent Student Cadre, 2017 Outstanding Volunteer of 2017 Shenzhen International Precision Medicine Summit, 2017 Alma mater practice excellent team, 2017 National Literary Creation Award, 2016 Excellent Student, The Second Prize Scholarship, 2016 ","date":"0001-01-01","objectID":"/about/:0:10","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Memberships Chinese Association for Artificial Intelligence (CAAI) Member The international Asia-Pacific Bioinformatics Network (APBioNET) Member Global Burden of Disease (GBD) Collaborator Network Member CCF生物信息专委会通讯委员 ","date":"0001-01-01","objectID":"/about/:0:11","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Press Coverage SkinGPT-4 was covered by: How a Saudi university is using AI to transform the diagnosis and treatment of skin diseases, Arab News How Saudi Arabia’s SkinGPT-4 is Revolutionizing Skin Care?, ChicHue 皮肤诊断“智能”升级：阿卜杜拉国王科技大学团队引入多模态大语言模型, 澎湃新闻 AI tool for diagnosing skin disorders, KAUST Discovery PPML-Omics protects patients’ privacy in omic data was covered by: Algorithm Proposed to Protect Patient Privacy, Inside Precision Medicine An integrated shuffler optimizes the privacy of personal genomic data used for machine learning, Today Headline An integrated shuffler optimizes the privacy of personal genomic data used for machine learning, Tech Xplore Shuffling the deck for privacy, ScienMag Shuffling the deck for privacy, Bioengineer.org Shuffling the deck for privacy, Newswise Shuffling the deck for privacy, EurekAlert Novel Privacy-Preserving Machine-Learning Method Developed for Genomics Data, Biocompare نهج ثوري يحافظ على خصوصية البيانات الطبية, nabd.ws Revolutionizing Healthcare: Secure Multi-Party Computation and Privacy-Preserving Machine Learning, BNN Breaking An integrated shuffler optimizes the privacy of personal genomic data used for machine learning, Microsoft Start Shuffling The Deck For Privacy, Eurasia Review Audit to forget was covered by: Un logiciel pour garantir le droit à l’oubli des patients dans l’IA en milieu de santé, Enerzine Safeguarding the right to be forgotten, KAUST Discovery ","date":"0001-01-01","objectID":"/about/:0:12","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Invited Talks [2025/08/10] 迈向智慧医疗的伦理人工智能（Towards Healthcare Ethical AI） Oral. 第十届中国计算机学会生物信息学会议, 海南海口, China. [2025/07/14] 迈向智慧医疗的伦理人工智能（Towards Healthcare Ethical AI） Oral. “新医科的创新实践：人工智能赋能科学研究”, 汕头大学医学院, China. [2025/06/06] 迈向智慧医疗的伦理人工智能（Towards Healthcare Ethical AI） Oral. BAAI Conference, 2025 (北京智源大会), Beijing, China. [2025/05/15] Pre-trained Multimodal Large Language Model Enhances Dermatological Diagnosis using SkinGPT-4. Poster. Inaugural KCSH Conference: Shaping the Future of Smart Health, Jeddah, Saudi Arabia. [2025/02/24] Private Artificial Intelligence (PAI) for Healthcare. Oral. Shanghai Innovation Institute, China. [2024/11/27] Pre-trained Multimodal Large Language Model Enhances Dermatological Diagnosis using SkinGPT-4. Poster. 1st International Health Conference on Quality and Organization Excellence, Jeddah, Saudi Arabia. certificate [2024/11/04] Private Artificial Intelligence (PAI) for Healthcare. Oral. Westlake University, China. [2024/10/28] Private Artificial Intelligence (PAI) for Healthcare. Oral. CUHK-Shenzhen, China. [2024/10/22] Pre-trained Multimodal Large Language Model Enhances Dermatological Diagnosis using SkinGPT-4. Poster. Health Innovation Week 2024, Global Health Exhibition, Riyadh, Saudi Arabia. certificate [2024/08/15] AI for Healthcare: Pre-trained Multimodal Large Language Model Enhances Dermatological Diagnosis using SkinGPT-4. Oral. 汕头大学医学院“智能计算赋能医学”, 中国 [2023/11/22] Introduction to ChatGPT and Application of GPT in Healthcare. Oral. Saudi Olympiad Elite Camp, King Abdullah University of Science and Technology, Saudi Arabia [2023/09/20] A Unified Method to Revoke the Private Data of Patients in Intelligent Healthcare with Audit to Forget. Oral. CBRC Seminar, King Abdullah University of Science and Technology, Saudi Arabia [2023/06/12] SkinGPT-4: An Interactive Dermatology Diagnostic System with Visual Large Language Model. Oral. Unlocking the Power of “ChatGPT”, King Abdullah University of Science and Technology, Saudi Arabia [2023/03/02] Audit to Forget: A Unified Method to Revoke Patients’ Private Data in Intelligent Healthcare. Poster. CBRC session, KAUST Research Open Week, Saudi Arabia [2023/02/02] Audit to Forget: A Unified Method to Revoke Patients’ Private Data in Intelligent Healthcare. Oral \u0026 Poster. Spotlight, Rising Stars in AI Symposium 2023 at KAUST, Saudi Arabia [2022/11/10] Privacy in Bioinformatics and Intelligent Healthcare. Poster. Smart-Health Student Research Symposium, KAUST, Saudi Arabia [2022/03/29] PPML-Omics: a Privacy-Preserving federated Machine Learning system protects patients’ privacy from omic data Oral. CBRC Dual Seminar, King Abdullah University of Science and Technology, Saudi Arabia [2022/03/09] PPML-Omics: a Privacy-Preserving federated Machine Learning system protects patients’ privacy from omic data Oral. BDAI重点实验室研究生沙龙第19期, 中国人民大学高瓴人工智能学院，中国北京 ","date":"0001-01-01","objectID":"/about/:0:13","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Academic Services Reviewer Journal/Conference # Paper Reviewed AI4D3 @ NeurIPS 2023 1 BMC Artificial Intelligence 1 BMC Bioinformatics 2 BMC Medical Informatics and Decision Making 1 Computers in Biology and Medicine 21 Computational Biology and Chemistry 3 Computerized Medical Imaging and Graphics 2 Computational and Structural Biotechnology Journal 1 Genome Biology 1 Genome Research 2 Heliyon 1 IJCAI-ECAI 2022 1 ICONIP 2020 1 ICMLA 2021 1 International Journal of Intelligent Systems 1 IEEE Transactions on Knowledge and Data Engineering 1 International Journal of Machine Learning and Cybernetics 1 Journal of Bioinformatics and Computational Biology 1 Knowledge and Information Systems 1 Medical Image Analysis 2 MICCAI 2020 1 MICCAI 2024 5 Multimedia Systems 1 Nature 1 Nature Methods 2 Nature Communications 3 npj Precision Oncology 1 npj Digital Medicine 2 SIGKDD 2022 2 Scientific Reports 3 Editor Editorial Board Member of npj Artificial Intelligence Editorial Board Member of BMC Bioinformatics Guest Editor Assistant in Biomedical Informatics (Special issue: spatial transcriptomics) Conference Administrator Co-Chair, IS-HIS 2025 Symposium, ICCNS2025, Varna, Bulgaria Administrator, The 21st International Conference on Bioinformatics (InCoB2022), certificate ","date":"0001-01-01","objectID":"/about/:0:14","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Hey there! Feel free to propose a meeting time slot based on my calendar below. Option 1: When you do, please send a Google Calendar invitation to juexiao.zhou@gmail.com with the title {Your Name}-Juexiao Zhou-{Meeting Purpose}. Just replace {Your Name} with your actual name and {Meeting Purpose} with the specific reason for the meeting. Option 2: You can also book a timeslot at https://calendly.com/juexiao-zhou/meeting-with-juexiao Thanks a lot! If possible, please suggest a time between 9 am and 5 pm on a working day. I really appreciate it! Just a heads up, the calendar shows my meeting schedules, but I might be working on papers during some free slots. I might ask to adjust the proposed time if something comes up that’s not marked in the calendar. ","date":"0001-01-01","objectID":"/calendar/:0:0","tags":null,"title":"","uri":"/calendar/"},{"categories":null,"content":"At CUHK-Shenzhen Ph.D. Student Zhangtianyi Chen, (B.S., Jinan University), 2025.9 - Zijian Wang, (B.S., Dalian University of Technology), 2025.9 - MPhil Student Yuhao Shen, (B.S., Hangzhou Dianzi University), 2025.9 - Xinyuan Zhang, (B.S., Xi’an Jiaotong-Liverpool University), 2025.9 - Postdoc We want you! Visiting Scholar We want you! Research Assistant Shiqin Han, (B.S., South China Normal University), 2025.11 - Yuyuan Yang, (B.S., Southwest University of Science and Technology), 2025.10 - Interns Jiahe Qian, (M.S., Chinese Academy of Sciences), 2025.6 - Florensia Widjaja, (B.S., CUHK-Shenzhen), 2025.6 - Yuanhao He, (B.S., CUHK-Shenzhen), 2025.9 - Siqi Yao, (B.S., CUHK-Shenzhen), 2025.9 - Jiachen Luo, (Ph.D., Queen Mary University of London), 2025.9 - Yiyang Zhang, (B.S., CUHK-Shenzhen), 2025.9 - Luchang Jiang, 2025.5 - Jindong Jiang, (B.S., Nanjing University), 2024.11 - 2025.9 Published a co-first-authored paper on Briefings in Bioinformatics (IF: 7.7) ","date":"0001-01-01","objectID":"/mentoring/:0:1","tags":null,"title":"","uri":"/mentoring/"},{"categories":null,"content":"At KAUST (During my Ph.D.) Jiaqi Dong, (Ph.D., KAUST), 2025 Jingyi Fang, Remote Intern, 2025 Yuxin He, Remote Intern (B.S., Sun Yat-sen University), 2025 Pavel Putintcev, (M.S., KAUST), 2024 -\u003e now, Dubai Mohammed Saif, (Sr.System Administrator/DevOps Evangelist, KAUST), 2024 For his master’s thesis on the application of advanced AI methods in the diagnosis of difficult skin diseases. ","date":"0001-01-01","objectID":"/mentoring/:0:2","tags":null,"title":"","uri":"/mentoring/"},{"categories":null,"content":"Happy Moment 2025/9 Shenzhen, China ","date":"0001-01-01","objectID":"/mentoring/:0:3","tags":null,"title":"","uri":"/mentoring/"},{"categories":null,"content":"Journal (# equal contribution, * corresponding author, supervised students) 2025 Streamline Automated Biomedical Discoveries with Agentic Bioinformatics Juexiao Zhou*, Jindong Jiang, Zhongyi Han, Zijian Wang, Xin Gao Briefings in Bioinformatics Accepted. Evaluating and Mitigating Bias in AI-Driven Medical Text Generation. Xiuying Chen, Tairan Wang, Juexiao Zhou, Xin Gao, Xiangliang Zhang Nature Computational Science DOI: https://doi.org/10.1038/s43588-025-00789-7 Access: online, pdf Deep learning-driven pulmonary artery and vein segmentation reveals demography-associated vasculature anatomical differences. Yuetan Chu#, Gongning Luo#, Longxi Zhou, Shaodong Cao, Guolin Ma, Xianglin Meng, Juexiao Zhou, Changchun Yang, Dexuan Xie, Dan Mu, Ricardo Henao, Gianluca Setti, Xigang Xiao, Lianming Wu, Zhaowen Qiu, Xin Gao* Nature Communications DOI: https://doi.org/10.1038/s41467-025-56505-6 Access: online, pdf 2024 AggNet: Advancing Protein Aggregation Analysis Through Deep Learning and Protein Language Model. Wenjia He, Xiaopeng Xu, Haoyang Li, Juexiao Zhou, Xin Gao Protein Science DOI: https://doi.org/10.1002/pro.70031 Access: online, pdf Unveiling the Power of Language Models in Chemical Research Question Answering. Xiuying Chen, Tairan Wang, Taicheng Guo, Kehan Guo, Juexiao Zhou, Haoyang Li, Zirui Song, Xin Gao, Xiangliang Zhang. Communications Chemistry DOI: https://doi.org/10.1038/s42004-024-01394-x Access: online, pdf Global, regional, and national burden of upper respiratory infections and otitis media, 1990–2021: a systematic analysis from the Global Burden of Disease Study 2021. GBD 2021 Upper Respiratory Infections Otitis Media Collaborators* (Authors listed alphabetically) The Lancet Infectious Diseases DOI: https://doi.org/10.1016/S1473-3099(24)00430-4 Access: online, pdf An AI Agent for Fully Automated Multi-omic Analyses. Juexiao Zhou#, Bin Zhang#, Guowei Li, Xiuying Chen, Haoyang Li, Xiaopeng Xu, Siyuan Chen, Liwei Liu, Xin Gao* Advanced Science DOI: https://doi.org/10.1002/advs.202407094 Access: online, pdf Press: CBIRT news, Medium Pre-trained Multimodal Large Language Model Enhances Dermatological Diagnosis using SkinGPT-4. Juexiao Zhou#, Xiaonan He#, Liyuan Sun#, Jiannan Xu, Xiuying Chen, Yuetan Chu, Longxi Zhou, Xingyu Liao, Bin Zhang, Shawn Afvari, Xin Gao* Nature Communications DOI: https://doi.org/10.1038/s41467-024-50043-3 Access: online, pdf HELM-GPT: de novo macrocyclic peptide design using generative pre-trained transformer. Xiaopeng Xu, Chencheng Xu, Wenjia He, Lesong Wei, Haoyang Li, Juexiao Zhou, Ruochi Zhang, Yu Wang, Yuanpeng Xiong, Xin Gao Bioinformatics DOI: https://doi.org/10.1093/bioinformatics/btae364 Access: online, pdf Burden of disease scenarios for 204 countries and territories, 2022–2050: a forecasting analysis for the Global Burden of Disease Study 2021. GBD 2021 Forecasting Collaborators* (Authors listed alphabetically) The Lancet DOI: https://doi.org/10.1016/S0140-6736(24)00685-8 Access: online, pdf Global burden and strength of evidence for 88 risk factors in 204 countries and 811 subnational locations, 1990–2021: a systematic analysis for the Global Burden of Disease Study 2021. GBD 2021 Risk Factors Collaborators* (Authors listed alphabetically) The Lancet DOI: https://doi.org/10.1016/S0140-6736(24)00933-4 Access: online, pdf KaryoXpert: An Accurate Chromosome Segmentation and Classification Framework for Karyotyping Analysis without Training with Manually Labeled Metaphase-Image Mask Annotations. Siyuan Chen, Kaichuang Zhang, Jingdong Hu, Na Li, Ao Xu, Haoyang Li, Juexiao Zhou, Chao Huang, Yongguo Yu, and Xin Gao Computers in Biology and Medicine DOI: https://doi.org/10.1016/j.compbiomed.2024.108601 Access: online, pdf Global incidence, prevalence, years lived with disability (YLDs), disability-adjusted life-years (DALYs), and healthy life expectancy (HALE) for 371 diseases and injuries in 204 countries and territories and 811 subnational locations, 1990–2021: a systematic analysis for t","date":"0001-01-01","objectID":"/publications/:0:1","tags":null,"title":"","uri":"/publications/"},{"categories":null,"content":"Conference 2020 Automatic and interpretable model for periodontitis diagnosis in panoramic radiographs. Haoyang Li, Juexiao Zhou, Yi Zhou, Jieyu Chen, Feng Gao, Ying Xu, Xin Gao*. Medical Image Computing and Computer Assisted Interventions 2020 DOI: 10.1007/978-3-030-59713-9_44. Access: online, pdf ","date":"0001-01-01","objectID":"/publications/:0:2","tags":null,"title":"","uri":"/publications/"},{"categories":null,"content":"Posters 2023 Privacy in Bioinformatics and Intelligent Healthcare. Juexiao Zhou, Xin Gao*. Poster. Smart-Health Student Research Symposium, KAUST, Saudi Arabia, November 10, 2022. Access: certificate 2020 Deetal-Perio: DEEp denTAL Advisor for Periodontitis Diagnosis based on Two-step Segmentation of Teeth and Gingiva with Lower-dimensional Features. Haoyang Li, Juexiao Zhou, Xin Gao*. Poster. DigitalHealth, KAUST, 2020. Access: online 2019 CaMeRe: A novel tool for inference of cancer metabolic reprogramming. Haoyang Li, Juexiao Zhou, Huiyan Sun, Zhaowen Qiu, Xin Gao* and Ying Xu*. Poster. Advance In Artificial Intelligence, KAUST, 2019. DeeRect-PAS—A Deep-Learning based method for Transcriptome-wide PAS Identification. Yongkang Long, Juexiao Zhou, Zhongxiao Li, Wei Chen, Xin Gao*. Poster. Advance In Artificial Intelligence, KAUST, 2019. Systematical discovery of cis-elements regulating alternative polyadenylation in mammalian cells. Min Zhang, Yisheng Li, Juexiao Zhou, Yuhao He, Guipeng Li, Liang Fang, Wei Chen*. Poster. RNA Biology, CSH Asia, 2019. Systematical discovery of cis-elements regulating alternative polyadenylation in mammalian cells. Min Zhang, Yisheng Li, Juexiao Zhou, Yuhao He, Guipeng Li, Liang Fang, Wei Chen*. Poster. Regulatory RNAs, Cell Symposia, Berlin, Germany, May 12-14, 2019. ","date":"0001-01-01","objectID":"/publications/:0:3","tags":null,"title":"","uri":"/publications/"},{"categories":null,"content":"Preprint MoE Meets Reparameterization: Reparameterizable Mixture-of-Experts Model Enhances Dermatology Diagnosis via Dense-to-Experts Distillation Jiahe Qian, Juexiao Zhou* under review. Facial Foundational Model Advances Early Warning of Coronary Artery Disease from Live Videos with DigitalShadow Juexiao Zhou, Zhongyi Han, Mankun Xin, Xingwei He, Guotao Wang, Jiaoyan Song, Gongning Luo, Wenjia He, Xintong Li, Yuetan Chu, Juanwen Chen, Bo Wang, Xia Wu, Wenwen Duan, Zhixia Guo, Liyan Bai, Yilin Pan, Xuefei Bi, Lu Liu, Long Feng, Xiaonan He, Xin Gao under review. Beyond Perceptual Limit: Verifiable AI for Pulmonary Embolism Detection on Non-contrast CT Longxi Zhou#, Yuetan Chu#, Xianglin Meng#, Gongning Luo#, Juexiao Zhou, Kai Kang, Yang Gao, Xue Du, Anthony Capone, Dan Mu, Gang Yang, Manxi Xu, Shilong Sun, Hongwei Yu, Tong Zhang, Dexuan Xie, Mingsheng Lei, Guoxu Zhang, Shibo Wu, Lei Xu, Xin Guo, Jinyu Meng, Yuan Cheng, Ricardo Henao, Lawrence Carin, Yuan Qi, Gianluca Setti, Guo-Lin Ma, Zhaowen Qiu, Xin Gao under review. Mitigating Bias Catastrophic Inheritance in Medical Large Vision-Language Models with Logit Fairness Adjustment under review. Adaptive Feature Unlearning for Trustworthy Healthcare Data Privacy Zhongyi Han#, Bin Wang#, Shenjing Wu#, Juexiao Zhou#, Wenhao Wang, Gongning Luo, Benzheng Wei, Xin Gao under review. Large Language Models in Biomedicine and Healthcare. Juexiao Zhou, Haoyang Li, Siyuan Chen, Zhongyi Han, Xin Gao under review. SkinCAP: A Multi-modal Dermatology Dataset Annotated with Rich Medical Captions. Juexiao Zhou#, Liyuan Sun#, Yan Xu#, Wenbin Liu#, Shawn Afvari#, Zhongyi Han, Jiaoyan Song, Yongzhi Ji, Xiaonan He, Xin Gao under review. Wiskott-Aldrich Syndrome Protein Regulates Nucleolar Organization and Function in Innate Immune Response. Xuan Zhou#, Baolei Yuan#, Yeteng Tian, Juexiao Zhou, Mengge Wang, Ismail shakir, Yingzi Zhang, Chongwei Bi, Bayan Mohammed Aljamal, Mais Omar Hashem, Omar Imad Abuyousef, Firdous Mohammed Abdulwahab, Afshan Ali, Sarah Dunn, James Moresco, John Robert Yates III, Francesco Frassoni, Xin Gao, Fowzan Alkuraya, Juan Carlo Izpisua Belmonte, Mo Li* under review. Access: bioRxiv Deep Learning Enhanced Tandem Repeat Variation Identification via Multi-Modal Conversion of Nanopore Reads Alignment. Xingyu Liao#, Juexiao Zhou#, Bin Zhang#, Xingyi Li, Xiaopeng Xu, Haoyang Li, Xin Gao* under review. Access: arXiv Path to Medical AGI: Unify Domain-specific Medical LLMs with the Lowest Cost. Juexiao Zhou#, Xiuying Chen#, Xin Gao* under review. Access: arXiv Heart Region Anchoring: a Model-Agnostic Workflow to Improve Segmentation Robustness for Breast Cancer in DCE-MRI. Longxi Zhou, Yitong Ding, Jiayang Guo, Ming Fan, Juexiao Zhou, Haoyang Li, Yujiao Li, Yuxin Huang, Yi Zhao, Yuetan Chu, Kun Wang, Qiming Fang, Xin Gao, Hongxia Zhang, Lihua Li. under review. ","date":"0001-01-01","objectID":"/publications/:0:4","tags":null,"title":"","uri":"/publications/"},{"categories":null,"content":"Patents and Patent Applications Automated Bioinformatics Analysis via AutoBA. Juexiao Zhou, Xin Gao KAUST reference: 2024-010. Personalized and privacy-preserving federated heterogeneous medical image analysis with PPPML-HMI. Juexiao Zhou, Xin Gao KAUST reference: 2023-012. A high-precision identification method of tandem repeat expansion based on refined alignment and deep learning. Xingyu Liao, Juexiao Zhou, Xin Gao KAUST reference: 2023-054. Audit to forget: a unified suite to revoke patients’ private data in intelligent healthcare. Juexiao Zhou, Xin Gao KAUST reference: 2023-056. A camera-based privacy-preserving early warning system for critical diseases. Juexiao Zhou, Xin Gao KAUST reference: 2023-074. ","date":"0001-01-01","objectID":"/publications/:0:5","tags":null,"title":"","uri":"/publications/"}]