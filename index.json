[{"categories":["system"],"content":"Run Ubuntu Linux in Docker with Desktop Environment and VNC ","date":"2022-08-21","objectID":"/run-ubuntu-in-docker/:0:0","tags":["ubuntu","docker"],"title":"Run Ubuntu Linux in Docker with Desktop Environment and VNC","uri":"/run-ubuntu-in-docker/"},{"categories":["system"],"content":"Step 1 – Install Docker on your System sudo systemctl start docker \u0026\u0026 sudo systemctl enable docker Add your system user to the Docker group to be able to execute Docker commands without *sudo*. sudo usermod -aG docker $USER newgrp docker Verify the installed Docker version. $ docker version Client: Docker Engine - Community Version: 20.10.12 API version: 1.41 Go version: go1.16.12 Git commit: e91ed57 Built: Mon Dec 13 11:45:48 2021 OS/Arch: linux/amd64 Context: default Experimental: true .... ","date":"2022-08-21","objectID":"/run-ubuntu-in-docker/:1:0","tags":["ubuntu","docker"],"title":"Run Ubuntu Linux in Docker with Desktop Environment and VNC","uri":"/run-ubuntu-in-docker/"},{"categories":["system"],"content":"Step 2 – Pull the Ubuntu Docker Image As said earlier, there are several images for Ubuntu that can be pulled. These images are available on the Docker page and can be pulled using Docker as shown. ##For Ubuntu 20.04 (latest) docker pull dorowu/ubuntu-desktop-lxde-vnc:latest ##For Focal with LXDE docker pull dorowu/ubuntu-desktop-lxde-vnc:focal ##For Focal with LXQt docker pull dorowu/ubuntu-desktop-lxde-vnc:focal-lxqt ##For Bionic with LXDE docker pull dorowu/ubuntu-desktop-lxde-vnc:bionic ##For Bionic with LXQt docker pull dorowu/ubuntu-desktop-lxde-vnc:bionic-lxqt ##For Trusty docker pull dorowu/ubuntu-desktop-lxde-vnc:trusty ##For Xenial docker pull dorowu/ubuntu-desktop-lxde-vnc:xenial Once the desired Ubuntu image has been pulled, check if it is available in the local registry. $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE dorowu/ubuntu-desktop-lxde-vnc latest 1a89db715923 10 months ago 1.32GB ","date":"2022-08-21","objectID":"/run-ubuntu-in-docker/:2:0","tags":["ubuntu","docker"],"title":"Run Ubuntu Linux in Docker with Desktop Environment and VNC","uri":"/run-ubuntu-in-docker/"},{"categories":["system"],"content":"Step 3 – Run the Ubuntu Container with Desktop Environment Here, we will go through several methods with configuration on how you can run the Ubuntu container to give you an intuitive experience. ","date":"2022-08-21","objectID":"/run-ubuntu-in-docker/:3:0","tags":["ubuntu","docker"],"title":"Run Ubuntu Linux in Docker with Desktop Environment and VNC","uri":"/run-ubuntu-in-docker/"},{"categories":["system"],"content":"Quick Start. You can simply run the container and access it via port 6080 using the command below. docker run -d \\ --name ubuntu_desktop \\ -v /dev/shm:/dev/shm \\ -p 6080:80 \\ dorowu/ubuntu-desktop-lxde-vnc In the above command, we have set the container name to *ubuntu_desktop* and a persistent volume at */dev/shm* Remember to replace ubuntu-desktop-lxde-vnc with the appropriate image pulled. Check if the container is running with the port exposed. $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f8fd69e3865e dorowu/ubuntu-desktop-lxde-vnc \"/startup.sh\" 17 seconds ago Up 15 seconds (health: starting) 0.0.0.0:6080-\u003e80/tcp, :::6080-\u003e80/tcp ubuntu_desktop As seen from the output, we have port 6080 exposed. Allow it through the firewall and proceed to access the Ubuntu Desktop using the URL http://IP_Address:6080/. ","date":"2022-08-21","objectID":"/run-ubuntu-in-docker/:3:1","tags":["ubuntu","docker"],"title":"Run Ubuntu Linux in Docker with Desktop Environment and VNC","uri":"/run-ubuntu-in-docker/"},{"categories":["system"],"content":"Set HTTP Base Authentication You can also set a password to be used when accessing the HTTP page on port 6080 by adding the HTTP_PASSWORD variable to the above command: docker run -d \\ --name ubuntu_desktop \\ -e HTTP_PASSWORD=Passw0rd \\ -v /dev/shm:/dev/shm \\ -p 6080:80 \\ dorowu/ubuntu-desktop-lxde-vnc Now accessing the page, you will be required to provide a password. ","date":"2022-08-21","objectID":"/run-ubuntu-in-docker/:3:2","tags":["ubuntu","docker"],"title":"Run Ubuntu Linux in Docker with Desktop Environment and VNC","uri":"/run-ubuntu-in-docker/"},{"categories":["system"],"content":"Enable VNC Viewer The VNC viewer is accessed via a separate port 5900 that needs to be exposed in order to access it. The VNC Viewer port can be exposed as below. docker run -d \\ --name ubuntu_desktop \\ -v /dev/shm:/dev/shm \\ -p 6080:80 \\ -p 5900:5900 \\ dorowu/ubuntu-desktop-lxde-vnc Here, the VNC viewer should be available on port *5900*. You can as well set a password for the viewer by adding the VNC_PASSWORD variable to the above command: docker run -d \\ --name ubuntu_desktop \\ -e VNC_PASSWORD=StrongPassword \\ -v /dev/shm:/dev/shm \\ -p 6080:80 \\ -p 5900:5900 \\ dorowu/ubuntu-desktop-lxde-vnc ","date":"2022-08-21","objectID":"/run-ubuntu-in-docker/:3:3","tags":["ubuntu","docker"],"title":"Run Ubuntu Linux in Docker with Desktop Environment and VNC","uri":"/run-ubuntu-in-docker/"},{"categories":["system"],"content":"Encrypt with SSL. You can generate SSL certificates for encryption. In this guide, we will generate self-signed certificates as below. Ensure that OpenSSL is installed on your system before you proceed: mkdir -p ssl openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ssl/nginx.key -out ssl/nginx.crt Now when running the container, you need to specify the SSL_PORT and the path to the generated certificate as below. docker run -d \\ --name ubuntu_desktop \\ -v /dev/shm:/dev/shm \\ -p 6081:443 \\ -e SSL_PORT=443 \\ -v ${PWD}/ssl:/etc/nginx/ssl \\ dorowu/ubuntu-desktop-lxde-vnc Here, you can access the Ubuntu Desktop using the URL https://IP_address:6081. Ref https://computingforgeeks.com/run-ubuntu-linux-in-docker-with-desktop-environment-and-vnc/https://www.youtube.com/watch?v=umqz7kKWxyw) ","date":"2022-08-21","objectID":"/run-ubuntu-in-docker/:3:4","tags":["ubuntu","docker"],"title":"Run Ubuntu Linux in Docker with Desktop Environment and VNC","uri":"/run-ubuntu-in-docker/"},{"categories":["privacy"],"content":"全同态加密 Fully homomorphic encryption (FHE) ","date":"2022-08-10","objectID":"/fhe/:0:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"What’s is FHE 第一种形式：同时使用secret key加密和解密，public key用于第三方加密进行同态计算 第二种形式：asymmetric FHE，只使用public key进行加密，secret key用于解密 Efficient FHE is a giant leap towards httpz:// ? what’s httpz? ","date":"2022-08-10","objectID":"/fhe/:1:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"History Major task: find a new scheme to combine both addition and multiplication together. ","date":"2022-08-10","objectID":"/fhe/:2:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"1. First generation Plain text: single bit 这个方法的主要问题是noise，随着计算的叠加，there is a notion of noise in ciphertexts，noise accumulates Defining noise budget thourgh defining parameters noise growth is exponential bootstrapping to rescure (decrease the noise) Somewhat homomorphic encyption (SHE) 初代的FHE目标是每一步同态计算，都进行一次bootstrapping，来抑制噪音增加。但是bootstrapping的计算消耗太大，所以SHE的目标是控制在output时的噪音水平，保证是可以接受的。 ","date":"2022-08-10","objectID":"/fhe/:3:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"2. Second generation targeting the exponential growing noise ","date":"2022-08-10","objectID":"/fhe/:4:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"3. Third generation: GSW 只是概念上的简化，但是无法实用。 ","date":"2022-08-10","objectID":"/fhe/:5:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"4. 4th generation: Torus FHE, TFHE ","date":"2022-08-10","objectID":"/fhe/:6:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"Open-source FHE librabies FV-NFLlib SEAL HEAAN TFHE HElib nuFHE Palisade ","date":"2022-08-10","objectID":"/fhe/:7:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"Two encryption ","date":"2022-08-10","objectID":"/fhe/:8:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["privacy"],"content":"Plaintext encoding 但是在计算的时候，noise会在右侧累积。 通过bootstrapping，可以减少右侧的noise LWE ciphertexts are homomorphic Ref Complete talk: Introduction to Homomorphic Encryption (by Pascal Paillier) - YouTube ","date":"2022-08-10","objectID":"/fhe/:9:0","tags":["privacy"],"title":"Fully homomorphic encryption (FHE)","uri":"/fhe/"},{"categories":["system"],"content":"After installing PyG, here is the error: libc10_cuda.so: cannot open shared object file: No such file or directory Solution conda install pytorch==1.11.0 cudatoolkit=11.3 -c pytorch conda install pyg -c pyg ","date":"2022-08-06","objectID":"/libc10_cuda.so-error-for-installing-pyg/:0:0","tags":["system","linux"],"title":"libc10_cuda.so error for installing pyG","uri":"/libc10_cuda.so-error-for-installing-pyg/"},{"categories":["system"],"content":"在运行任务时，往linux的同一个文件夹中写入超过500万个文件，导致在硬盘还有空间的情况下，在该文件夹下无法继续写入文件，也无法使用ls、rm等命令。记录处理过程。 Background: physical server, about two years old, 7200-RPM SATA drives connected to a 3Ware RAID card, ext3 FS mounted noatime and data=ordered, not under crazy load, kernel 2.6.18-92.1.22.el5, uptime 545 days. Directory doesn’t contain any subdirectories, just millions of small (~100 byte) files, with some larger (a few KB) ones. We have a server that has gone a bit cuckoo over the course of the last few months, but we only noticed it the other day when it started being unable to write to a directory due to it containing too many files. Specifically, it started throwing this error in /var/log/messages: ext3_dx_add_entry: Directory index full! The disk in question has plenty of inodes remaining: Filesystem Inodes IUsed IFree IUse% Mounted on /dev/sda3 60719104 3465660 57253444 6% / So I’m guessing that means we hit the limit of how many entries can be in the directory file itself. No idea how many files that would be, but it can’t be more, as you can see, than three million or so. Not that that’s good, mind you! But that’s part one of my question: exactly what is that upper limit? Is it tunable? Before I get yelled at—I want to tune it down; this enormous directory caused all sorts of issues. Anyway, we tracked down the issue in the code that was generating all of those files, and we’ve corrected it. Now I’m stuck with deleting the directory. A few options here: rm -rf (dir) I tried this first. I gave up and killed it after it had run for a day and a half without any discernible impact. unlink(2) on the directory: Definitely worth consideration, but the question is whether it’d be faster to delete the files inside the directory via fsck than to delete via unlink(2). That is, one way or another, I’ve got to mark those inodes as unused. This assumes, of course, that I can tell fsck not to drop entries to the files in /lost+found; otherwise, I’ve just moved my problem. In addition to all the other concerns, after reading about this a bit more, it turns out I’d probably have to call some internal FS functions, as none of the unlink(2) variants I can find would allow me to just blithely delete a directory with entries in it. Pooh. while [ true ]; do ls -Uf | head -n 10000 | xargs rm -f 2\u003e/dev/null; done ) This is actually the shortened version; the real one I’m running, which just adds some progress-reporting and a clean stop when we run out of files to delete, is: export i=0; time ( while [ true ]; do ls -Uf | head -n 3 | grep -qF ‘.png’ || break; ls -Uf | head -n 10000 | xargs rm -f 2\u003e/dev/null; export i=$(($i+10000)); echo “$i…”; done ) This seems to be working rather well. As I write this, it has deleted 260,000 files in the past thirty minutes or so. Now, for the questions: As mentioned above, is the per-directory entry limit tunable? Why did it take “real 7m9.561s / user 0m0.001s / sys 0m0.001s” to delete a single file which was the first one in the list returned by ls -U, and it took perhaps ten minutes to delete the first 10,000 entries with the command in #3, but now it’s hauling along quite happily? For that matter, it deleted 260,000 in about thirty minutes, but it’s now taken another fifteen minutes to delete 60,000 more. Why the huge swings in speed? Is there a better way to do this sort of thing? Not store millions of files in a directory; I know that’s silly, and it wouldn’t have happened on my watch. Googling the problem and looking through SF and SO offers a lot of variations on find that are not going to be significantly faster than my approach for several self-evident reasons. But does the delete-via-fsck idea have any legs? Or something else entirely? I’m eager to hear out-of-the-box (or inside-the-not-well-known-box) thinking. Thanks for reading the small novel; feel free to ask questions and I’ll be sure to respond. I’ll also update the question with the final number of files and how long the delete script ran once I have that.","date":"2022-08-05","objectID":"/linux%E5%88%A0%E9%99%A4%E7%99%BE%E4%B8%87%E7%BA%A7%E5%88%AB%E6%96%87%E4%BB%B6/:0:0","tags":["system","linux"],"title":"linux删除百万级别文件","uri":"/linux%E5%88%A0%E9%99%A4%E7%99%BE%E4%B8%87%E7%BA%A7%E5%88%AB%E6%96%87%E4%BB%B6/"},{"categories":["system"],"content":"Automatically Sort Data in Google Sheets Extension -\u003e Apps script function autoSort(e) { const ss = SpreadsheetApp.getActiveSpreadsheet() const ws = ss.getSheetByName(\"Sheet1\") const range = ws.getRange(2,1,ws.getLastRow()-1,2) range.sort({column: 2, ascending: false}) } function onEdit(e){ autoSort(e) } ","date":"2022-07-01","objectID":"/googlesheetautomaticsort/:0:0","tags":["system","linux"],"title":"Automatically Sort Data in Google Sheets","uri":"/googlesheetautomaticsort/"},{"categories":["system"],"content":" Check SWAP used by differnt PID for i in $(cd /proc;ls | grep \"^[0-9]\" | awk '$0\u003e100'); do awk '/Swap:/{a=a+$2}END{print '\"$i\"',a/1024\"M\"}' /proc/$i/smaps;done| sort -k2nr | head Get the information about the PID ps aux | grep ${pid} ","date":"2022-06-09","objectID":"/check-swap/:0:0","tags":["system","linux"],"title":"Check SWAP","uri":"/check-swap/"},{"categories":["system"],"content":"显示“未能找到金属编译器安装的Xcode。请安装Xcode并运行Xcode.app来接受协议，或确保激活的开发者目录设为当前的Xcode安装（使用xcode-select） 解决方案： sudo xcode-select -s /Applications/Xcode.app/Contents/Developer ","date":"2022-06-09","objectID":"/xcode-select/:0:0","tags":["system","linux"],"title":"xcode-select","uri":"/xcode-select/"},{"categories":["leetcode"],"content":"给定两个稀疏向量，计算它们的点积（数量积）。 实现类 SparseVector： SparseVector(nums) 以向量 nums 初始化对象。 dotProduct(vec) 计算此向量与 vec 的点积。 稀疏向量 是指绝大多数分量为 0 的向量。你需要 高效 地存储这个向量，并计算两个稀疏向量的点积。 进阶：当其中只有一个向量是稀疏向量时，你该如何解决此问题？ 示例 1： 输入：nums1 = [1,0,0,2,3], nums2 = [0,3,0,4,0] 输出：8 解释：v1 = SparseVector(nums1) , v2 = SparseVector(nums2) v1.dotProduct(v2) = 10 + 03 + 00 + 24 + 3*0 = 8 示例 2： 输入：nums1 = [0,1,0,0,0], nums2 = [0,0,0,0,2] 输出：0 解释：v1 = SparseVector(nums1) , v2 = SparseVector(nums2) v1.dotProduct(v2) = 00 + 10 + 00 + 00 + 0*2 = 0 示例 3： 输入：nums1 = [0,1,0,0,2,0,0], nums2 = [1,0,0,0,3,0,4] 输出：6 提示： n == nums1.length == nums2.length 1 \u003c= n \u003c= 10^5 0 \u003c= nums1[i], nums2[i] \u003c= 100 解题思路 这个题的关键点在于用什么数据形式来存储稀疏向量。因为稀疏向量大部分地方都是0，所以使用list来存储是非常低效的。所以我们可以考虑用hash的形式来存储不为0的位置的数据。两个向量点乘的时候，只有两个vector中都不为0，才能对最后的结果产生影响。 因此，这个题目换个思路就是把hash化后的两个vector，有对应key的位置乘起来。 Answer class SparseVector: def __init__(self, nums): \"\"\" :type nums: List[int] \"\"\" self.h=self.hashit(nums) def hashit(self,l): h={} for i in range(len(l)): if l[i]!=0: h[i]=l[i] return h # Return the dotProduct of two sparse vectors def dotProduct(self, vec): \"\"\" :type vec: 'SparseVector' :rtype: int \"\"\" hv=vec.h ans=0 for key in self.h.keys(): try: ans+=self.h[key]*hv[key] except: pass return ans ","date":"2022-03-01","objectID":"/lc1570.-dot-product-of-two-sparse-vectors/:0:0","tags":["leetcode"],"title":"lc1570. Dot Product of Two Sparse Vectors","uri":"/lc1570.-dot-product-of-two-sparse-vectors/"},{"categories":["leetcode"],"content":"Implement pow(x, n), which calculates x raised to the power n (i.e., xn). Example 1: Input: x = 2.00000, n = 10 Output: 1024.00000 Example 2: Input: x = 2.10000, n = 3 Output: 9.26100 Example 3: Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Constraints: -100.0 \u003c x \u003c 100.0 -231 \u003c= n \u003c= 231-1 -104 \u003c= xn \u003c= 104 思路 ","date":"2022-03-01","objectID":"/lc50.-powx-n/:0:0","tags":["leetcode"],"title":"lc50. Pow(x, n)","uri":"/lc50.-powx-n/"},{"categories":["leetcode"],"content":"Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\". The testcases will be generated such that the answer is unique. A substring is a contiguous sequence of characters within the string. Example 1: Input: s = \"ADOBECODEBANC\", t = \"ABC\" Output: \"BANC\" Explanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t. Example 2: Input: s = \"a\", t = \"a\" Output: \"a\" Explanation: The entire string s is the minimum window. Example 3: Input: s = \"a\", t = \"aa\" Output: \"\" Explanation: Both 'a's from t must be included in the window. Since the largest window of s only has one 'a', return empty string. Constraints: m == s.length n == t.length 1 \u003c= m, n \u003c= 105 s and t consist of uppercase and lowercase English letters. 解题思路 这道题要求我们返回字符串 s中包含字符串 t 的全部字符的最小窗口，我们利用滑动窗口的思想解决这个问题。因此我们需要两个哈希表，hs哈希表维护的是s字符串中滑动窗口中各个字符出现多少次，ht哈希表维护的是t字符串各个字符出现多少次。如果hs哈希表中包含ht哈希表中的所有字符，并且对应的个数都不小于ht哈希表中各个字符的个数，那么说明当前的窗口是可行的，可行中的长度最短的滑动窗口就是答案。 过程如下： 1、遍历t字符串，用ht哈希表记录t字符串各个字符出现的次数。 2、定义两个指针j和i，j指针用于收缩窗口，i指针用于延伸窗口，则区间[j,i]表示当前滑动窗口。首先让i和j指针都指向字符串s开头，然后枚举整个字符串s ，枚举过程中，不断增加i使滑动窗口增大，相当于向右扩展滑动窗口。 3、每次向右扩展滑动窗口一步，将s[i]加入滑动窗口中，而新加入了s[i]，相当于滑动窗口维护的字符数加一，即hs[s[i]]++。 4、对于新加入的字符s[i],如果hs[s[i]] \u003c= ht[s[i]]，说明当前新加入的字符s[i]是必需的，且还未到达字符串t所要求的数量。我们还需要事先定义一个cnt变量， cnt维护的是s字符串[j,i]区间中满足t字符串的元素的个数，记录相对应字符的总数。新加入的字符s[i]必需，则cnt++。 5、我们向右扩展滑动窗口的同时也不能忘记收缩滑动窗口。因此当hs[s[j]] \u003e ht[s[j]时，说明hs哈希表中s[j]的数量多于ht哈希表中s[j]的数量，此时我们就需要向右收缩滑动窗口，j++并使hs[s[j]]–，即hs[s[j ++ ]] –。 6、当cnt == t.size时，说明此时滑动窗口包含符串 t 的全部字符。我们重复上述过程找到最小窗口即为答案。 时间复杂度分析： 两个指针都严格递增，最多移动 n 次，所以总时间复杂度是 O(n)。 作者：lin-shen-shi-jian-lu-k 链接：https://leetcode-cn.com/problems/minimum-window-substring/solution/leetcode-76-zui-xiao-fu-gai-zi-chuan-cja-lmqz/ Answer from collections import defaultdict class Solution: def minWindow(self, s, t): if len(s)\u003clen(t): return \"\" hs, ht = defaultdict(int), defaultdict(int) for chr in t: ht[chr] += 1 res = \"\" left, right = 0, 0 cnt = 0 while right\u003clen(s): hs[s[right]] += 1 if hs[s[right]] \u003c= ht[s[right]]: cnt += 1 while left\u003c=right and hs[s[left]] \u003e ht[s[left]]: hs[s[left]] -= 1 left += 1 if cnt == len(t): if not res or right-left+1\u003clen(res): res = s[left:right+1] right += 1 return res ","date":"2022-03-01","objectID":"/lc76.-minimum-window-substring/:0:0","tags":["leetcode"],"title":"lc76. Minimum Window Substring","uri":"/lc76.-minimum-window-substring/"},{"categories":["leetcode"],"content":"You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. Example 1: Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. Example 2: Input: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1]. Example 3: Input: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1. Constraints: nums1.length == m + n nums2.length == n 0 \u003c= m, n \u003c= 200 1 \u003c= m + n \u003c= 200 -109 \u003c= nums1[i], nums2[j] \u003c= 109 Follow up: Can you come up with an algorithm that runs in O(m + n) time? 思路 由于nums1的后序数字全为0，并且nums1和nums2都是以升序排列，所以我们可以把两个数组从大到小依次比较，然后插入num1。因为num1和num2中的数字只会遍历一次，因此最终的时间复杂度是O(m+n)。 Answer class Solution(object): def merge(self, nums1, m, nums2, n): \"\"\" :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: None Do not return anything, modify nums1 in-place instead. \"\"\" insert=-1 m,n=m-1,n-1 while m\u003e=0 and n\u003e=0: if nums1[m]\u003enums2[n]: nums1[m],nums1[insert]=nums1[insert],nums1[m] m-=1 elif nums1[m]\u003c=nums2[n]: nums1[insert]=nums2[n] n-=1 insert-=1 while n\u003e=0: nums1[insert]=nums2[n] n-=1 insert-=1 ","date":"2022-03-01","objectID":"/lc88.-merge-sorted-array/:0:0","tags":["leetcode"],"title":"lc88. Merge Sorted Array","uri":"/lc88.-merge-sorted-array/"},{"categories":["leetcode"],"content":"Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle. However, there is a non-negative integer n that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least n units of time between any two same tasks. Return the least number of units of times that the CPU will take to finish all the given tasks. Example 1: Input: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2 Output: 8 Explanation: A -\u003e B -\u003e idle -\u003e A -\u003e B -\u003e idle -\u003e A -\u003e B There is at least 2 units of time between any two same tasks. Example 2: Input: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0 Output: 6 Explanation: On this case any permutation of size 6 would work since n = 0. [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"] [\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"] [\"B\",\"B\",\"B\",\"A\",\"A\",\"A\"] ... And so on. Example 3: Input: tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2 Output: 16 Explanation: One possible solution is A -\u003e B -\u003e C -\u003e A -\u003e D -\u003e E -\u003e A -\u003e F -\u003e G -\u003e A -\u003e idle -\u003e idle -\u003e A -\u003e idle -\u003e idle -\u003e A Constraints: 1 \u003c= task.length \u003c= 104 tasks[i] is upper-case English letter. The integer n is in the range [0, 100]. 解题思路 第一思路是先根据数目最多的task来排位置，确保每两个之间隔的距离是n。这个时候留出来的idel之间也有符合距离为n的位点，然后再考虑其它task的位置。 建立大小为 n+1 的桶子，个数为任务数量最多的那个任务，比如下图，等待时间 n=2，A 任务个数 6 个，我们建立 6 桶子，每个容量为 3： 我们可以把一个桶子看作一轮任务 先从最简单的情况看起，现在就算没有其他任务，我们完成任务 A 所需的时间应该是 (6-1)*3+1=16，因为最后一个桶子，不存在等待时间。 接下来我们添加些其他任务 可以看到 C 其实并没有对总体时间产生影响，因为它被安排在了其他任务的冷却期间；而 B 和 A 数量相同，这会导致最后一个桶子中，我们需要多执行一次 B 任务，现在我们需要的时间是 (6-1)*3+2=17 前面两种情况，总结起来：总排队时间 = (桶个数 - 1) * (n + 1) + 最后一桶的任务数 当冷却时间短，任务种类很多时 比如上图，我们刚好排满了任务，此时所需时间还是 17，如果现在我还要执行两次任务 F，该怎么安排呢？ 此时我们可以临时扩充某些桶子的大小，插进任务 F，对比一下插入前后的任务执行情况： 插入前：ABC | ABC | ABD | ABD | ABD | AB 插入后：ABCF | ABCF | ABD | ABD | ABD | AB 我们在第一个、第二个桶子里插入了任务F，不难发现无论再继续插入多少任务，我们都可以类似处理，而且新插入元素肯定满足冷却要求 继续思考一下，这种情况下其实每个任务之间都不存在空余时间，冷却时间已经被完全填满了。 也就是说，我们执行任务所需的时间，就是任务的数量 这样剩下就很好处理了，我们只需要算两个数： 记录最大任务数量 N，看一下任务数量并列最多的任务有多少个，即最后一个桶子的任务数 X， 计算 NUM1=(N-1)*(n+1)+x NUM2=tasks.size() 输出其中较大值即可因为存在空闲时间时肯定是 NUM1 大，不存在空闲时间时肯定是 NUM2\u003e=NUM1 引用解析作者：popopop 引用解析链接：https://leetcode-cn.com/problems/task-scheduler/solution/tong-zi-by-popopop/ Answer from collections import Counter class Solution(object): def leastInterval(self, tasks, n): \"\"\" :type tasks: List[str] :type n: int :rtype: int \"\"\" F=Counter(tasks).values() max_F=max(F) count_max_F=0 for x in F: if x==max_F: count_max_F+=1 ans1=(max_F-1)*(n+1)+count_max_F ans2=len(tasks) return max(ans1,ans2) ","date":"2022-02-16","objectID":"/lc621.-task-scheduler/:0:0","tags":["leetcode"],"title":"lc621. Task Scheduler","uri":"/lc621.-task-scheduler/"},{"categories":["leetcode"],"content":"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets. Example 1: Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Example 2: Input: nums = [] Output: [] Example 3: Input: nums = [0] Output: [] Constraints: 0 \u003c= nums.length \u003c= 3000 -105 \u003c= nums[i] \u003c= 105 解题思路 class Solution(object): def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" nums=sorted(nums) ans=set() i=0 total_len=len(nums) while i\u003c=total_len-3: if nums[i]\u003e0: break val=nums[i] head=i+1 tail=total_len-1 while head\u003ctail: _sum=val+nums[head]+nums[tail] if _sum==0: ans.add((val,nums[head],nums[tail])) head+=1 tail-=1 elif _sum\u003c0: head+=1 elif _sum\u003e0: tail-=1 i+=1 return [list(x) for x in ans] ","date":"2022-02-14","objectID":"/lc15.-3sum/:0:0","tags":["leetcode"],"title":"lc15. 3Sum","uri":"/lc15.-3sum/"},{"categories":["leetcode"],"content":"Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Example 1: Input: root = [1,2,3,null,null,4,5] Output: [1,2,3,null,null,4,5] Example 2: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 104]. -1000 \u003c= Node.val \u003c= 1000 解题思路 二叉树的序列化本质上是对其值进行编码，更重要的是对其结构进行编码。可以遍历树来完成上述任务。众所周知，我们一般有两个策略：广度优先搜索和深度优先搜索。 广度优先搜索可以按照层次的顺序从上到下遍历所有的节点 深度优先搜索可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将深度优先搜索策略区分为： 1. 先序遍历 2. 中序遍历 3. 后序遍历 如Example 1的树，采用先序遍历我们可以得到字符串: 1, 2, None, None, 3, 4, 5 None表示子节点不存在，因此该字符串就保留了树的结构。 该序列化方法的时间复杂度为O(N)，因为我们只会访问每个节点一次。空间复杂度也为O(N). 反序列化的过程我们先把字符串根据“,”拆分，然后从左往右遍历元素。 序列化函数和反序列化函数都可以用递归思想。 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Codec: def serialize(self, root): \"\"\"Encodes a tree to a single string. :type root: TreeNode :rtype: str \"\"\" if root==None: return '#,' left=self.serialize(root.left) right=self.serialize(root.right) return str(root.val)+','+left+right def deserialize(self, data): \"\"\"Decodes your encoded data to tree. :type data: str :rtype: TreeNode \"\"\" return self.buildTree(data.split(',')) def buildTree(self,data): val=data.pop(0) if val=='#': return None node=TreeNode(val) node.left=self.buildTree(data) node.right=self.buildTree(data) return node # Your Codec object will be instantiated and called as such: # ser = Codec() # deser = Codec() # ans = deser.deserialize(ser.serialize(root)) ","date":"2022-02-14","objectID":"/lc297.-serialize-and-deserialize-binary-tree/:0:0","tags":["leetcode"],"title":"lc297. Serialize and Deserialize Binary Tree","uri":"/lc297.-serialize-and-deserialize-binary-tree/"},{"categories":["leetcode"],"content":"Given the root of a binary tree, return the vertical order traversal of its nodes’ values. (i.e., from top to bottom, column by column). If two nodes are in the same row and column, the order should be from left to right. Example 1: Input: root = [3,9,20,null,null,15,7] Output: [[9],[3,15],[20],[7]] Example 2: Input: root = [3,9,8,4,0,1,7] Output: [[4],[9],[3,0,1],[8],[7]] Example 3: Input: root = [3,9,8,4,0,1,7,null,null,null,2,5] Output: [[4],[9,5],[3,0,1],[8,2],[7]] Constraints: The number of nodes in the tree is in the range [0, 100]. -100 \u003c= Node.val \u003c= 100 解题思路 我们可以在使用BFS遍历的时候给每一个元素带上vertical的位置信息。 使用BFS确保在每个column内的顺序是正确的。 带上vertical信息确保我们知道每一个元素属于哪一列。 使用hashmap来模拟即可。 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def verticalOrder(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" if root: stack=[[root,0]] hashmap={} while stack!=[]: current_node=stack[0][0] current_idx=stack[0][1] stack=stack[1:] try: hashmap[current_idx].append(current_node) except: hashmap[current_idx]=[current_node] if current_node.left: stack.append([current_node.left,current_idx-1]) if current_node.right: stack.append([current_node.right,current_idx+1]) res=[[node.val for node in hashmap[key]] for key in sorted(hashmap.keys())] else: res=[] return res 注意题目有边界条件，如果输入是null需要返回[]。 ","date":"2022-02-08","objectID":"/lc314.binary-tree-vertical-order-traversal/:0:0","tags":["leetcode"],"title":"lc314. Binary Tree Vertical Order Traversal","uri":"/lc314.binary-tree-vertical-order-traversal/"},{"categories":["Papers"],"content":"Title: Personalized Federated Learning: A Meta-Learning Approach INFO: 34th Conference on Neural Information Processing Systems (NeurIPS 2020) 研究背景 目前的联邦学习框架是基于所有users的数据，整合训练出一个最优的server模型。 However, this scheme only develops a common output for all the users, and, therefore, it does not adapt the model to each user. 但是，这样训练处来的server模型不一定适用于每一个user，尤其在不同的users所独有的数据差异比较大的时候。 This is an important missing feature, especially given the heterogeneity of the underlying data distribution for various users. 在heterogeneous的情景下，使用federated averaging方法训练出来的模型可能在每个独立user上的表现会比较差。 In particular, in the heterogeneous settings where the underlying data distribution of users are not identical, the resulted global model obtained by minimizing the average loss could perform arbitrarily poorly once applied to the local dataset of each user. 所以，参照Model-Agnostic Meta-Learning (MAML)的思路，这篇文章中，作者试图在联邦学习的思路上，训练一个最优的initial shared model，使得这个模型在每一个user上只需要非常少的几步finetune就可以适应本地的任务。 In this paper, we study a personalized variant of the federated learning in which our goal is to find aninitial shared model that current or new users can easily adapt to their local dataset by performing one or a few steps of gradient descent with respect to their own data. This approach keeps all the benefits ofthe federated learning architecture, and, by structure, leads to a more personalized model foreach user. Problem formulation Building on the Model-AgnosticMeta-Learning (MAML) problem formulation, the goal of this new formulationis to find an initial point shared between all users which performs well after each user updates it with respect to its own loss function, potentially by performing a few steps of a gradient-based method. This way, while the initial model is derived in a distributed manner over all users, thefinal model implemented by each user differs from other ones based on her or his own data. Westudy a Personalized variant of the FedAvg algorithm, called Per-FedAvg. Per-FedAvg ","date":"2022-02-05","objectID":"/neurips-personalized-federated-learning-a-meta-learning-approach/:0:0","tags":["NeurIPS","Machine learning","privacy","federated learning"],"title":"[NeurIPS] Personalized Federated Learning: A Meta-Learning Approach解读","uri":"/neurips-personalized-federated-learning-a-meta-learning-approach/"},{"categories":["Papers"],"content":"Title: Personalized Federated Learning With Differential Privacy DOI: 10.1109/JIOT.2020.2991416 INFO: IEEE INTERNET OF THINGS JOURNAL, VOL. 7, NO. 10, OCTOBER 2020 发表周期: Manuscript received December 15, 2019; revised March 20, 2020; accepted April 13, 2020. Date of publication April 30, 2020; ","date":"2022-02-04","objectID":"/ieee-personalized-federated-learning-with-differential-privacy/:0:0","tags":["IEEE","Machine learning","privacy","federated learning"],"title":"[IEEE] Personalized Federated Learning WithDifferential Privacy解读","uri":"/ieee-personalized-federated-learning-with-differential-privacy/"},{"categories":["paper"],"content":"并列递进 moreover, in addition, furthermore, besides, likewise, also, then, additionally 转折 not, yet, however, nevertheless, nonetheless, meanwhile, on the other hand, on the contrary, conversely, paradoxically, by contrast, in spite of，rather than, instead of, unfortunately 解释 in other words, in fact, as a matter of fact, that is, namely, in simpler terms 对比比较 Likewise, Similarly, In parallel to, while, whereas, 原因 because, because of, as, since, owing to, due to, thanks to, for this reason 结果 therefore, as a result, then, consequently, thus, hence, so, therefore, accordingly, consequently, as a consequence 举例 for example, for instance, as such, such as, take …for example, to illustrate, to name a few 总结 overall, eventually, consequently, in summary, in a word, as a result, together, collectively, thus, hence, consequently, on the whole, in conclusion, to sum up, in brief, to conclude, to summarize, in short, briefly 强调 surprisingly, interestingly, intriguingly, strikingly, unexpectedly, clearly, obviously, apparently, in fact, indeed, actually, as a matter of fact, undoubtedly, notably, specifically, particularly, especially firstly, … secondly, … finally …; first, … then … etc. 让步 although, after all, in spite of…, despite, even if, even though, though, admittedly, given that 可能 presumably, probably, perhaps 1、大家在文章中肯定有这样一句，虽然这个科学问题很重要，然而有哪个具体的细节关键我们还不知道。“不知道”有哪些表述方式呢？ virtually/largely unknown, elusive, unclear, much less explored, surprisingly limited, less understood, unsolved, scarcely understood 2、如果是研究某些新材料、新技术等，我们在文章中又该从哪几个方面来夸我们的成果呢？ reliability and validity, robust and fundamental, efficiency and specificity, cost-effectiveness(price), the simplicity of the protocols, the amount of labor required, equipment requirement，necessary or sufficient 3、在引用别人文献中的论点论据时，我们该如何表述“别人说”呢？ clearly/obviously demonstrate, reveal, illustrate, prove, show, report, implicate, confirm, describe 4、“执行动词”的第N种表示方法。在引述别人工作的时，别人都如何“做”呢？ examine, perform, carry out, observe, compare, investigate, indicate, show, manipulate, test, establish, identify, detect, stimulate, analyse, assess, suggest, propose, speculate, determine, find, apply, purify, construct a model, devised a protocol, calculate, categorize, conduct, imply, measure 5、关于“方式方法”的“效应”评价，你真的可以玩转吗？ plays a central/ pivotal/ vital key/essential role a powerful regulator/ a key molecular determinant, a well-accepted model influence, affect, rescue, reverse, lead to, contribute to, attribute to, ascribe to, drop, reduce, increasing, attenuate, ameliorate, improve, mount, accumulate 6、写文章免不了溯古叙今，“时间表述词”，你掌握了吗？ recently, most recently, at the same time/period, since then, for several decades 7、重大影响的描述，教你如何夸“成果” pushing the boundariesrecent/enormous advance, progress, knowledge, historic, perspectives, new/novel insights, seminal discovery, an emerging theme, major/important findings, a better understanding ","date":"2022-02-04","objectID":"/sci%E9%AB%98%E9%A2%91%E8%AF%8D%E6%B1%87/:0:0","tags":["paper"],"title":"SCI高频词汇","uri":"/sci%E9%AB%98%E9%A2%91%E8%AF%8D%E6%B1%87/"},{"categories":["leetcode"],"content":"给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，返回 所需会议室的最小数量 。 示例 1： 输入：intervals = [[0,30],[5,10],[15,20]] 输出：2 示例 2： 输入：intervals = [[7,10],[2,4]] 输出：1 提示： 1 \u003c= intervals.length \u003c= 104 0 \u003c= starti \u003c endi \u003c= 106 解题思路 我们可以想象把这些interval给叠起来，所需要会议室的最小数量就等于最大重叠的interval的数目。 转化为上下车问题，每个interval的开始时间+1，每个interval的结束时间-1，然后我们统计counter的最大数值。 换个思路就是我们以时间为单位，我们可以知道每个单位时间车上的总人数是增加多少还是减少多少，这样我们可以直接求和从开始扫描到结束，获取当前车上最大的人数就可以。 class Solution(object): def minMeetingRooms(self, intervals): \"\"\" :type intervals: List[List[int]] :rtype: int \"\"\" dic={} for interval in intervals: try: dic[interval[0]]+=1 except: dic[interval[0]]=1 try: dic[interval[1]]-=1 except: dic[interval[1]]=-1 max_=0 count=0 for key in sorted(dic.keys()): count+=dic[key] if count\u003emax_: max_=count return max_ ","date":"2022-02-03","objectID":"/lc253.%E4%BC%9A%E8%AE%AE%E5%AE%A4ii/:0:0","tags":["leetcode"],"title":"lc253. 会议室 II","uri":"/lc253.%E4%BC%9A%E8%AE%AE%E5%AE%A4ii/"},{"categories":["leetcode"],"content":"Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high]. Example 1: Input: root = [10,5,15,3,7,null,18], low = 7, high = 15 Output: 32 Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32. Example 2: Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10 Output: 23 Explanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23. Constraints: The number of nodes in the tree is in the range [1, 2 * 104]. 1 \u003c= Node.val \u003c= 105 1 \u003c= low \u003c= high \u003c= 105 All Node.val are unique. 解题思路 因为题中树结构的每个父节点，其左孩子都更小，右孩子都更大，所以直接用树搜索获取所有在区间内的值即可。 二叉搜索树 BST 的 value 具有 左值 \u003c 根值 \u003c 右值 的特点。所以我们可以用递归算法累积求和。 class Solution(object): def rangeSumBST(self, root, low, high): \"\"\" :type root: TreeNode :type low: int :type high: int :rtype: int \"\"\" global res res = 0 def traverse(root): global res if root: traverse(root.left) if low \u003c= root.val \u003c= high: res += root.val traverse(root.right) traverse(root) return res ","date":"2022-02-03","objectID":"/lc938.range_sum_of_bst/:0:0","tags":["leetcode"],"title":"lc938. Range Sum of BST","uri":"/lc938.range_sum_of_bst/"},{"categories":["system"],"content":"本文转载自：https://zhuanlan.zhihu.com/p/31088141 本文的内容分为： Time Machine 是什么？ 自建Time Machine 服务器的理由 硬件的选择 软件的部署 Mac 备份到Time Machine 服务器 从Time Machine 服务器恢复Mac ","date":"2022-01-29","objectID":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/:0:0","tags":["system","linux"],"title":"搭建Time Machine 服务器 （转载）","uri":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/"},{"categories":["system"],"content":"Time Machine 是什么？ Time Machine是macOS中一个非常强大的功能，Time Machine能够保留： 本地快照（只要空间允许） 过去24小时的每小时备份 过去一个月的每日备份 过去所有月份的每周备份 Time Machine的备份是增量备份，只会备份自上次备份以来有变动的文件，因此备份速度很快，占用的空间也不多。如果Time Machine 占满了磁盘空间，最早的备份会被自动删除。 引用知友 @Xing 在OS X 中的 Time Machine 真的有用吗？中的回答： 只要使用Time Machine备份过，即使原来的Mac在Windows双系统下渲染片子时突然蓝屏被你一气之下砸坏或者在麦当劳吃晚饭时被人连电脑包顺走，你也只需走进Apple Store，买一台新Mac，回家连上Time Capsule或者插上含有备份的硬盘，按住option开机进入recovery分区，选择从Time Machine中恢复。开机后打开迁移助手Migration Assistant，选择从Time Machine备份中恢复。等你小憩醒来，将会看到一台和之前一模一样的Mac，不仅是图库音乐库昨晚看过的美剧进度，包括所有设置、开机启动项浏览器历史都是完全一致的。 当然上面只是Time Machine顺滑体验的一部分，Time Machine可以带你回到每一个有记录的节点，例如你有一个project几个月前 从零开始做，在Time Machine中可以演绎整个project文件夹内的变化，同时可以把某个时间任何文件揪出来。这感觉就像你有一麻袋后悔药，想怎么来就怎么来。 使用Time Machine，你既可以回到过去某个时刻，提取某个文件在当时的版本；也可以在电脑异常崩溃后直接全盘恢复到过去某个时刻的状态。 ","date":"2022-01-29","objectID":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/:1:0","tags":["system","linux"],"title":"搭建Time Machine 服务器 （转载）","uri":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/"},{"categories":["system"],"content":"自建Time Machine 服务器的理由 Time Machine的使用方法有三种： 使用一块外置的USB移动硬盘，要求文件系统是HFS+。 使用苹果的AirPort网络设备，通过有线网络/无线网络的方式备份到Airport的硬盘上。 使用Mac mini，安装「macOS Server」使之成为AFP协议传输的文件服务器，Time Machine备份到文件服务器上。 方法1. 外置的USB移动硬盘需要总是挂在Mac上占用一个USB接口，对于有移动需求的MacBook要经常插拔，我经常会忘记弹出直接拔，或者忘记去停下备份中的Time Machine直接拔，长此以往容易造成硬盘的损坏。 方法2. 中可选的Airport设备有两款，分别是AirPort Extreme和AirPort Time Capsule (2TB/3TB)，除了售价高昂之外，性能孱弱，功能单一，最新款发布于2013年，产品线已经多年没有更新。 方法3. 如果不考虑价格，是事实上的最优解，但是对于一般用户如果只是想要单纯的作「Time Machine服务器」似乎费效比太高。 因此，我的目标是自建一台低成本低功耗长期运行的服务器，在服务器上部署Time Machine server服务，并且具有性能/功能的冗余，以应对日后产生的需求。 ","date":"2022-01-29","objectID":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/:2:0","tags":["system","linux"],"title":"搭建Time Machine 服务器 （转载）","uri":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/"},{"categories":["system"],"content":"硬件选择 我购买了一个X86的准系统： 尺寸：16012037，重量：600g，功耗：6-12W，全铝设计无风扇被动散热。 CPU：14nm Intel® Celeron® N3150 四核心 1.6GHz, 最高2.08GHz, 内建Intel HD Graphics 4K 显示核心。 前置面板：4个原生USB3.0，2个USB2.0。 后置面板：12V-19V宽幅电压外接直流供电，2个HDMI，2个千兆有线网口，3.5mm音频输入/输出，2个SMA天线座。 板载：SATA3 6Gb/s机械硬盘插槽（蓝色），MSATA3 6Gb/s固态硬盘插槽（橙色），mini PCIe无线网卡插槽（红色），DDR3L-1600内存插槽（黄色）。 另外购买了相关硬件： 内存：威刚(ADATA) DDR3L 1G 1600 笔记本内存； 固态硬盘：闪迪(SanDisk) i100 32G MSATA3 MLC SSD； 无线网卡：博通(Broadcom) BCM94352hmb 802.11ac + 蓝牙4.0； 机械硬盘：昱科(HGST) 500G SATA3 7200转32M 笔记本硬盘。 组装好之后，与MacBook Pro 13大小比较。总计开销1180=准系统550+内存80+固态硬盘80+无线网卡200+机械硬盘270。 ","date":"2022-01-29","objectID":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/:3:0","tags":["system","linux"],"title":"搭建Time Machine 服务器 （转载）","uri":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/"},{"categories":["system"],"content":"软件的部署 安装Linux，我选择的是Ubuntu Server 16.04.3 LTS，以下以此为例，我的账户名为tmback，密码为tmback，主机名为TMBack-Server。 SSH登陆： ssh tmback@tmback-server.local 首先，查看识别到的硬盘： ~$ sudo fdisk -l sda是系统所在的SSD，sdb就是我要用来作Time Machine备份的硬盘，把这个硬盘格式化为Linux的EXT4文件格式： ~$ sudo mkfs.ext4 /dev/sdb1 把格式化好的分区起个名字就叫TMBack： ~$ sudo e2label /dev/sdb1 TMBack 在/media创建一个目录，把sdb1挂载上去： ~$ sudo mkdir /media/TMBack ~$ sudo mount /dev/sdb1 /media/TMBack 把/media/TMBack目录所有者修改为tmback:tmback ~$ sudo chown -R tmback:tmback /media/TMBack 安装Netatalk服务，项目主页Netatalk。 Netatalk is an OpenSource software package, that can be used to turn a *NIX machine into an extremely high-performance and reliable file server for Macintosh computers. Using Netatalk’s AFP 3.3 compliant file-server leads to significantly higher transmission speeds compared with Macs accessing a server via SaMBa/NFS while providing clients with the best possible user experience (full support for Macintosh metadata, flawlessly supporting mixed environments of classic Mac OS and OS X clients) 用来把Linux/Unix伪装成AFP协议传输的文件服务器： ~$ sudo apt-get install netatalk 修改Netatalk的配置文件： ~$ sudo nano /etc/netatalk/AppleVolumes.default 在末尾加上这么一句：「/media/TMBack “TMback” options:tm」 重启Netatalk服务： ~$ sudo service netatalk restart 这时在网络上就能发现一台新的，主机名为「tmback-server」的Mac主机。 用刚刚设的账户名tmback密码tmback登陆。 能看到挂载的硬盘TMBack目录。 安装avahi-daemon，项目主页avahi - mDNS/DNS-SD。 Avahi is a system which facilitates service discovery on a local network via the mDNS/DNS-SD protocol suite. This enables you to plug your laptop or computer into a network and instantly be able to view other people who you can chat with, find printers to print to or find files being shared. Compatible technology is found in Apple MacOS X (branded “Bonjour” and sometimes “Zeroconf”). Avahi is primarily targetted at Linux systems and ships by default in most distributions. It is not ported to Windows at this stage, but will run on many other BSD-like systems. The primary API is D-Bus and is required for usage of most of Avahi, however services can be published using an XML service definition placed in /etc/avahi/services. 用来在Linux/Unix中开启类似的Bonjour的服务： ~$ sudo apt-get install avahi-daemon 然后我们新建一个它的服务： ~$ sudo nano /etc/avahi/services/afpd.service 输入以下内容： \u003c?xml version=\"1.0\" standalone='no'?\u003e\u003c!--*-nxml-*--\u003e \u003c!DOCTYPE service-group SYSTEM \"avahi-service.dtd\"\u003e \u003cservice-group\u003e \u003cname replace-wildcards=\"yes\"\u003e%h\u003c/name\u003e \u003cservice\u003e \u003ctype\u003e_afpovertcp._tcp\u003c/type\u003e \u003cport\u003e548\u003c/port\u003e \u003c/service\u003e \u003cservice\u003e \u003ctype\u003e_device-info._tcp\u003c/type\u003e \u003cport\u003e0\u003c/port\u003e \u003ctxt-record\u003emodel=Xserve\u003c/txt-record\u003e \u003c/service\u003e \u003c/service-group\u003e 重启avahi-daemon服务： ~$ sudo service avahi-daemon restart 这时「tmback-server」变成了一台Mac文件服务器。 如果关闭ubuntu，你还会在Mac上收到通知。 安装nss-mdns，项目主页nss-mdns 0.10。 nss-mdns is a plugin for the GNU Name Service Switch (NSS) functionality of the GNU C Library (glibc) providing host name resolution via Multicast DNS (aka Zeroconf, aka Apple Rendezvous, aka Apple Bonjour), effectively allowing name resolution by common Unix/Linux programs in the ad-hoc mDNS domain .local. nss-mdns provides client functionality only, which means that you have to run a mDNS responder daemon seperately from nss-mdns if you want to register the local host name via mDNS. I recommend Avahi. nss-mdns is very lightweight (9 KByte stripped binary .so compiled with -DNDEBUG=1 -Os on i386, gcc 4.0), has no dependencies besides the glibc and requires only minimal configuration. By default nss-mdns tries to contact a running avahi-daemon for resolving host names and addresses and making use of its superior record cacheing. Optionally nss-mdns can be compiled with a mini mDNS stack that can be used to resolve host names without a local Avahi installation. Both Avahi support and this mini mDNS stack are optional, however at least one of them needs to be enabled. If both are enabled a connection to Avahi is tried first, and if that fails the mini mDNS stack is used. 用来配合刚刚设置好的avahi-daemon： ~$ sudo apt-get install libnss-mdns 修改nss-mdns配置文件： ~$ sudo nano /etc/nssw","date":"2022-01-29","objectID":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/:4:0","tags":["system","linux"],"title":"搭建Time Machine 服务器 （转载）","uri":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/"},{"categories":["system"],"content":"Mac 备份到Time Machine 服务器 系统偏好设置–\u003eTime Machine–\u003e选择备份磁盘 会发现一个名为「TMBack」的网络共享磁盘，选择它。 用我们之前设的账户名tmback密码tmback登陆。 耐心等待首次备份完成，嫌慢的话，把ubuntu和Mac都插上千兆网线，备份速度不输给外置USB硬盘备份。 此后，只要Mac与ubuntu处在同一个网络内，就会自动进行备份，Mac脱离网络则备份会自动停止，一切都是无感的。 ","date":"2022-01-29","objectID":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/:5:0","tags":["system","linux"],"title":"搭建Time Machine 服务器 （转载）","uri":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/"},{"categories":["system"],"content":"从Time Machine 服务器恢复Mac 按住「command+R」启动Mac，直到进入「Recovery」模式。 选择「从Time Machine 备份进行恢复」。 选择网络上的分区，输入账号密码连接即可。 ","date":"2022-01-29","objectID":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/:6:0","tags":["system","linux"],"title":"搭建Time Machine 服务器 （转载）","uri":"/%E6%90%AD%E5%BB%BAtimemachine-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AC%E8%BD%BD/"},{"categories":["leetcode"],"content":"Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where: '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Example 1: Input: s = \"aa\", p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\". Example 2: Input: s = \"aa\", p = \"a*\" Output: true Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\". Example 3: Input: s = \"ab\", p = \".*\" Output: true Explanation: \".*\" means \"zero or more (*) of any character (.)\". Constraints: 1 \u003c= s.length \u003c= 20 1 \u003c= p.length \u003c= 30 s contains only lowercase English letters. p contains only lowercase English letters, '.', and '*'. It is guaranteed for each appearance of the character '*', there will be a previous valid character to match. 解题思路 手写最简单的正则表达式函数，判断s是否符合p的正则规则。 初始思路 用两个指针分别读取s和p的头，按照规则依次匹配。确保两个指针可以在满足规则的前提下都移动到s和p的尾端。 进阶思路 动态规划。类似于两个序列做比对，只要可以完全alignment上就OK。 class Solution: def isMatch(self, s, p): m = len(s) + 1 n = len(p) + 1 dp = [[False for _ in range(n)] for _ in range(m)] dp[0][0] = True for j in range(2, n): if p[j-1] == '*': dp[0][j] = dp[0][j - 2] for r in range(1, m): i = r - 1 for c in range(1, n): j = c - 1 if s[i] == p[j] or p[j] == '.': dp[r][c] = dp[r - 1][c - 1] elif p[j] == '*': if p[j - 1] == s[i] or p[j - 1] == '.': dp[r][c] = dp[r - 1][c] or dp[r][c - 2] else: dp[r][c] = dp[r][c - 2] else: dp[r][c] = False return dp[m - 1][n - 1] ","date":"2022-01-27","objectID":"/lc10.regular_expression_matching/:0:0","tags":["leetcode"],"title":"lc10. Regular Expression Matching","uri":"/lc10.regular_expression_matching/"},{"categories":["leetcode"],"content":"A permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for arr = [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1]. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). For example, the next permutation of arr = [1,2,3] is [1,3,2]. Similarly, the next permutation of arr = [2,3,1] is [3,1,2]. While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement. Given an array of integers nums, find the next permutation of nums. The replacement must be in place and use only constant extra memory. Example 1: Input: nums = [1,2,3] Output: [1,3,2] Example 2: Input: nums = [3,2,1] Output: [1,2,3] Example 3: Input: nums = [1,1,5] Output: [1,5,1] Constraints: 1 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 100 解题思路 首先我们要知道，什么情况下是没有下一个（除了回到正序第一个）：当nums所有的数字都是严格降序排列。所以我们首先需要判断num是否严格降序，如果是则返回严格升序排列。 那么如何判断存在下一个刚刚好更大的数呢？只要nums中存在nums[i-1]\u003cnums[i]的情况就存在。既然如此，我们只要把nums[i-1]和nums[i:~]中恰好大于nums[i-1]的数交换位置即可。但是这样一来nums[i: ~]中也可能继续存在有恰好更大的排列。因此，我们注意到，最终我们需要把nums[i: ~]的数字全部严格降序排列。 所以最终的解题思路是： 对nums，从右边往左边扫，寻找nums[i-1]\u003cnums[i]的情况 如果无法找到（严格降序），那么返回严格升序序列 如果可以找到，那么把num[i-1]和num[i: ~]中最小的数字交换，然后把num[i: ~]全部严格升序排列 class Solution(object): def nextPermutation(self, nums): \"\"\" :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. \"\"\" for i in range(2,len(nums)+1): if nums[-i]\u003cnums[-i+1]: min_value=None for j in range(1,i): if min_value==None and nums[-j]\u003enums[-i]: min_value=nums[-j] if nums[-j]\u003c=min_value: min_idx=-j min_value=nums[-j] nums[-i],nums[min_idx]=nums[min_idx],nums[-i] nums[-i+1:]=sorted(nums[-i+1:],reverse=False) return nums[:]=sorted(nums,reverse=False) 这里有几个坑需要注意： 题目中强调不需要return，而是直接在nums上修改，因此如果是新建内存空间再赋值给nums，有可能无法通过。 记得最后如果是严格降序，需要返回严格升序。 在剩下序列中找的最小值，一定要大于nums[i-1] ","date":"2022-01-27","objectID":"/lc31.next_permutation/:0:0","tags":["leetcode"],"title":"lc31. Next Permutation","uri":"/lc31.next_permutation/"},{"categories":["leetcode"],"content":"Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. Example 1: Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. Constraints: 1 \u003c= intervals.length \u003c= 10^4 intervals[i].length == 2 0 \u003c= starti \u003c= endi \u003c= 10^4 解题思路 非常简单的思路是我们使用一个辅助list，首先遍历所有的input区间来记录有覆盖的位置，然后我们在遍历辅助list输出最终的interval。但是这种解法需要的内存会非常大，因此空间复杂度高。 另一种思路是先把input的区间按照区间头从小到大排序，然后再依次合并区间。 class Solution(object): def merge(self, intervals): \"\"\" :type intervals: List[List[int]] :rtype: List[List[int]] \"\"\" def partition(lists,low,high): i=low-1 pivot=lists[high][0] for j in range(low,high): if lists[j][0]\u003c=pivot: i+=1 lists[i],lists[j]=lists[j],lists[i] lists[i+1],lists[high]=lists[high],lists[i+1] return i+1 def quickSort(lists,low,high): if len(lists)==1: return lists if low\u003chigh: pi=partition(lists,low,high) quickSort(lists,low,pi-1) quickSort(lists,pi+1,high) return lists def overlap(intv1,intv2): if intv2[0]\u003c=intv1[1]: if intv2[1]\u003c=intv1[1]: return True,intv1 else: return True,[intv1[0],intv2[1]] else: return False,[intv1,intv2] _intervals=quickSort(intervals,0,len(intervals)-1) ans=[] tmp=_intervals[0] for _ in _intervals: isoverlapped,res=overlap(tmp,_) if isoverlapped==True: tmp=res else: ans.append(tmp) tmp=res[1] ans.append(tmp) return ans ","date":"2022-01-27","objectID":"/lc56.merge_intervals/:0:0","tags":["leetcode"],"title":"lc56. Merge Intervals","uri":"/lc56.merge_intervals/"},{"categories":["leetcode"],"content":"A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true if it is a palindrome, or false otherwise. Example 1: Input: s = \"A man, a plan, a canal: Panama\" Output: true Explanation: \"amanaplanacanalpanama\" is a palindrome. Example 2: Input: s = \"race a car\" Output: false Explanation: \"raceacar\" is not a palindrome. Example 3: Input: s = \" \" Output: true Explanation: s is an empty string \"\" after removing non-alphanumeric characters. Since an empty string reads the same forward and backward, it is a palindrome. Constraints: 1 \u003c= s.length \u003c= 2 * 105 s consists only of printable ASCII characters. 解题思路 把字符串转成小写 首先第一个循环只保留字符串中的字母和数字 利用指针双头判断。 class Solution(object): def isPalindrome(self, s): \"\"\" :type s: str :rtype: bool \"\"\" valid='abcdefghijklmnopqrstuvwxyz0123456789' s=s.lower() s=''.join([x for x in s if x in valid]) while len(s)\u003e1: if s[0]!=s[-1]: return False else: s=s[1:-1] return True 这道题注意一下valid字符串别漏写就行。因为我们只需要遍历一遍字符串，所以时间复杂度为O(N)，同时空间复杂度也为O(N) ","date":"2022-01-26","objectID":"/lc125.valid_palindrome/:0:0","tags":["leetcode"],"title":"lc125. Valid Palindrome","uri":"/lc125.valid_palindrome/"},{"categories":["leetcode"],"content":"Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] Constraints: 2 \u003c= nums.length \u003c= 105 -30 \u003c= nums[i] \u003c= 30 The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.) 解题思路: 题目非常鸡贼。最简单的想法是第一遍遍历把所有数字乘起来，然后第二遍遍历把乘积除以对应位置的数，如果是0则不除。结果发现题目中进一步要求 without using the division operation. 左右乘积 用两次遍历，第一次遍历维护一个左乘积，第二遍维护一个右乘积。 第三次遍历，把左乘积和右乘积乘起来，就是每个位置（exclude）之后其它部分的乘积。 class Solution(object): def productExceptSelf(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" left=[] right=[] _mul=1 for i in range(len(nums)): left.append(_mul) _mul*=nums[i] _nums=nums[::-1] _mul=1 for i in range(len(_nums)): right.append(_mul) _mul*=_nums[i] right=right[::-1] return [left[i]*right[i] for i in range(len(left))] 在这个算法下，因为我们有一个循环，所以时间复杂度是O(N)，同时我们需要维护和nums同长的一个list，所以空间复杂度是O(N) 进阶，空间复杂度O(1) 如果需要实现空间复杂度O(1)，意味着除了最终的输出答案，我们中间不能使用任何和nums等长的list存储中间答案。 所以最简单的方案是我们只维护一个final result list，然后通过两次遍历来更新final。 class Solution(object): def productExceptSelf(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" res=[1 for i in range(len(nums))] _mul=1 for i in range(len(nums)): res[i]*=_mul _mul*=nums[i] _mul=1 for i in range(len(nums)): res[-i-1]*=_mul _mul*=nums[-i-1] return res 这里需要注意在计算右乘积时使用的index，因为我们使用的是-i，所以i=0的时候会出现问题，我们需要在idx上减去1. ","date":"2022-01-26","objectID":"/lc238._product_of_array_except_self/:0:0","tags":["leetcode"],"title":"lc238. Product of Array Except Self","uri":"/lc238._product_of_array_except_self/"},{"categories":["leetcode"],"content":"Given two non-negative integers, num1 and num2 represented as string, return the sum of num1and num2 as a string. You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly. Example 1: Input: num1 = \"11\", num2 = \"123\" Output: \"134\" Example 2: Input: num1 = \"456\", num2 = \"77\" Output: \"533\" Example 3: Input: num1 = \"0\", num2 = \"0\" Output: \"0\" Constraints: 1 \u003c= num1.length, num2.length \u003c= 104 num1 and num2 consist of only digits. num1 and num2 don’t have any leading zeros except for the zero itself. 解题思路： 这道题限制not convert the inputs to integers directly，所以我们只能按照每一步来模拟进位计算。 把两个字符串反向。 把每一位变成数字，模拟进位计算 class Solution(object): def addStrings(self, num1, num2): \"\"\" :type num1: str :type num2: str :rtype: str \"\"\" ans='' _up=0 while len(num1)\u003e0 and len(num2)\u003e0: _1=int(num1[-1]) _2=int(num2[-1]) num1=num1[:-1] num2=num2[:-1] _sum=_1+_2+_up if _sum\u003e9: _up=1 else: _up=0 ans+=str(_sum%10) num='' if len(num1)\u003e0: num=num1 elif len(num2)\u003e0: num=num2 while len(num)\u003e0: _1=int(num[-1]) num=num[:-1] _sum=_1+_up if _sum\u003e9: _up=1 else: _up=0 ans+=str(_sum%10) if _up==1: ans+='1' return ans[::-1] 注意如果最后_up还是1，那么记得在最终答案上补上1. 执行用时：36 ms, 在所有 Python 提交中击败了41.44%的用户 内存消耗：13.3 MB, 在所有 Python 提交中击败了43.47%的用户 ","date":"2022-01-26","objectID":"/lc415.add_strings/:0:0","tags":["leetcode"],"title":"lc415. Add Strings","uri":"/lc415.add_strings/"},{"categories":["leetcode"],"content":"Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k. Example 1: Input: nums = [1,1,1], k = 2 Output: 2 Example 2: Input: nums = [1,2,3], k = 3 Output: 2 Constraints: 1 \u003c= nums.length \u003c= 2 * 104 -1000 \u003c= nums[i] \u003c= 1000 -107 \u003c= k \u003c= 107 解题思路： 累积和（使用数组） 首先使用一个cumulative数组，保存nums中从0开始到每个元素的累积求和。 然后，cumulative数组中两两数之间的差，对应nums中这两个位置之间的累积求和。 通过计算两两差之后，我们就可以知道有多少continuous subarrays whose sum equals to k class Solution(object): def subarraySum(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: int \"\"\" cumulative=[0] base=0 for num in nums: base+=num cumulative.append(base) ans=0 for i in range(len(cumulative)-1): for j in range(i+1,len(cumulative)): res=cumulative[j]-cumulative[i] if res==k: ans+=1 return ans 这个方法因为我们需要在cumulative上进行两次循环，所以时间复杂度为O(N^2)，同时因为需要cumulative来存储，所以空间复杂度是O(N). 累积和（不使用数组） class Solution(object): def subarraySum(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: int \"\"\" ans=0 for i in range(len(nums)-1): sum=0 for j in range(i,len(nums)): sum+=nums[j] if sum==k: ans+=1 return ans 这个方法因为我们依旧需要在cumulative上进行两次循环，所以时间复杂度为O(N^2)，但是我们不需要使用数组来存储答案，所以空间复杂度是O(1). 哈希表 接下来我们希望可以把时间复杂度降到O(N)，所以我们需要抛弃两层循环。这里的思路是，我们只需要遍历nums一遍，然后用一个dict保存出现的和。空间换时间的算法，这题使用哈希表省去的是遍历开头的时间，因为我们已知结尾的话，需要什么开头很容易知道，就是B[j]-k，就是查看之前的前缀和元素里有没有B[j]-k这个元素。与遍历不同的是，遍历寻找开头的话还能知道是哪一段子数组，哈希表的话我们并不知道子数组是哪一段，只需要知道有没有就可以了，这题就是只需要我们给出有没有，有多少个的结果就可以了。 class Solution(object): def subarraySum(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: int \"\"\" _sum, res, cul = 0, 0, {0:1} for _ in nums: _sum+=_ if _sum-k in cul: res+=cul[_sum-k] try: cul[_sum]+=1 except: cul[_sum]=1 return res ","date":"2022-01-25","objectID":"/lc560.subarray_sum_equals_k/:0:0","tags":["leetcode"],"title":"lc560. Subarray Sum Equals K","uri":"/lc560.subarray_sum_equals_k/"},{"categories":["leetcode"],"content":"Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid. Return all the possible results. You may return the answer in any order. Example 1: Input: s = \"()())()\" Output: [\"(())()\",\"()()()\"] Example 2: Input: s = \"(a)())()\" Output: [\"(a())()\",\"(a)()()\"] Example 3: Input: s = \")(\" Output: [\"\"] Constraints: 1 \u003c= s.length \u003c= 25 s consists of lowercase English letters and parentheses '(' and ')'. There will be at most 20 parentheses in s. 难点：本题和1249. 移除无效的括号非常相似，但是这里最难的点是如何找到所有的可能解。 解题思路： 由于我们需要找到的是最小Removal，同时需要找到在当前最小Removal下的所有解，我们可以采用BFS搜索方法。对于BFS的tree中每一层可以认为是在上一层的字符串中删除一个括号之后的所有可能字符串，然后我们对所有节点判断是否为有效括号。使用BFS，有2个好处： 如果父节点已经是合法字符串，则无需再考虑任何子节点。 如果有一个节点已经是合法字符串，则其它所有结果都只可能出现在和这个节点同一层（为了确保minimal removal）。 class Solution(object): def removeInvalidParentheses(self, s): \"\"\" :type s: str :rtype: List[str] \"\"\" def delOne(string): out=set() for i in range(len(string)): tmp=list(string) tmp.pop(i) out.add(''.join(tmp)) return out def getNextLevel(level): \"\"\" :type level: set \"\"\" nextlevel=set() for _ in level: for __ in delOne(_): nextlevel.add(__) return nextlevel def isValid(string): count=0 for _ in string: if _=='(': count+=1 elif _==')': count-=1 if count\u003c0: return False if count==0: return True else: return False level=[s] length=len(s) while True: current_ans=[] #print(current_ans,level) for _ in level: if isValid(_)==True: current_ans.append(_) else: pass if len(current_ans)!=0: break else: if length\u003e1: level=getNextLevel(level) length-=1 else: current_ans=[\"\"] break return current_ans 但是使用BFS的时间复杂度比较高， 执行用时：668 ms, 在所有 Python 提交中击败了13.99%的用户 内存消耗：13.9 MB, 在所有 Python 提交中击败了5.12%的用户 ","date":"2022-01-20","objectID":"/lc301.remove_invalid_parentheses/:0:0","tags":["leetcode"],"title":"lc301. Remove Invalid Parentheses","uri":"/lc301.remove_invalid_parentheses/"},{"categories":["leetcode"],"content":"Given two binary strings a and b, return their sum as a binary string. Example 1: Input: a = \"11\", b = \"1\" Output: \"100\" Example 2: Input: a = \"1010\", b = \"1011\" Output: \"10101\" Constraints: 1 \u003c= a.length, b.length \u003c= 104 a and b consist only of '0' or '1' characters. Each string does not contain leading zeros except for the zero itself. 解题思路 直接按照进位处理即可。 朴素解法 class Solution(object): def addBinary(self, a, b): \"\"\" :type a: str :type b: str :rtype: str \"\"\" _up=0 ans=[] a,b=list(a),list(b) while len(a)!=0 and len(b)!=0: _a=int(a.pop(-1)) _b=int(b.pop(-1)) _sum=_a+_b+_up if _sum\u003e=2: ans.append(_sum%2) _up=1 else: ans.append(_sum) _up=0 if len(a)!=0: while len(a)!=0: _a=int(a.pop(-1)) _sum=_a+_up if _sum\u003e=2: ans.append(_sum%2) _up=1 else: ans.append(_sum) _up=0 elif len(b)!=0: while len(b)!=0: _b=int(b.pop(-1)) _sum=_b+_up if _sum\u003e=2: ans.append(_sum%2) _up=1 else: ans.append(_sum) _up=0 if _up!=0: ans.append(_up) return ''.join([str(x) for x in ans[::-1]]) 性能分析： Runtime: 32 ms, faster than 40.49% of Python online submissions for Add Binary. Memory Usage: 13.7 MB, less than 6.13% of Python online submissions for Add Binary. 调包解法： 直接把二进制转为10进制求和再转回二进制 res = int(a, 2) + int(b, 2) res_str = str(bin(res)) res_len = len(res_str) return res_str[2:res_len] ","date":"2022-01-20","objectID":"/lc67.add_binary/:0:0","tags":["leetcode"],"title":"lc67. Add Binary","uri":"/lc67.add_binary/"},{"categories":["leetcode"],"content":"Convert a non-negative integer num to its English words representation. Example 1: Input: num = 123 Output: \"One Hundred Twenty Three\" Example 2: Input: num = 12345 Output: \"Twelve Thousand Three Hundred Forty Five\" Example 3: Input: num = 1234567 Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\" Constraints: 0 \u003c= num \u003c= 2^31 - 1 解题思路： 根据数字长度分成不同的翻译位: 亿，百万，千，百，Billion, Million, Thousand, Hundred 90-20的整10读法: Ninety, Eighty, Seventy, Sixty, Fifty, Fourty, Thirty, Twenty 19-11的读法：Nienteen, Eighteen, Seventeen, Sixteen, Fifteen, Fourteen, Thirteen, Twelve, Eleven 10-0的读法：Ten, Nine, Eight, Seven, Six, Five, Four, Three, Two, One, Zero 难点：把数字根据位数拆开。 **两种解法：**递归和迭代。 递归解法： class Solution(object): def numberToWords(self, num): \"\"\" :type num: int :rtype: str \"\"\" from0to19=['','One','Two','Three','Four','Five','Six','Seven','Eight','Nine','Ten','Eleven','Twelve','Thirteen','Fourteen','Fifteen','Sixteen','Seventeen','Eighteen','Nineteen'] from20to90=['','','Twenty','Thirty','Forty','Fifty','Sixty','Seventy','Eighty','Ninety'] def recursive(num): if num\u003e=1000000000: # larger than 1 billion ans='{}Billion'.format(from0to19[num//1000000000])+recursive(num%1000000000) return ans elif num\u003e=1000000: ans='{}Million'.format(recursive(num//1000000))+recursive(num%1000000) return ans elif num\u003e=1000: ans='{}Thousand'.format(recursive(num//1000))+recursive(num%1000) return ans elif num\u003e=100: ans='{}Hundred'.format(from0to19[num//100])+recursive(num%100) return ans elif num\u003e=20: ans='{}'.format(from20to90[num//10])+recursive(num%10) return ans else: return '{}'.format(from0to19[num]) def addBlank(s): _s='' for _ in s: if _.isupper(): _s+=' {}'.format(_) else: _s+=_ return _s if num==0: return 'Zero' else: ans=recursive(num) return addBlank(ans)[1:] Runtime: 24 ms, faster than 54.38% of Python online submissions for Integer to English Words. Memory Usage: 13.6 MB, less than 13.33% of Python online submissions for Integer to English Words. 踩坑： 空格问题 数字区间分割 Billion位忘记转英文 英文拼写错误，eg: forteen ","date":"2022-01-17","objectID":"/lc273.integer_to_english_words/:0:0","tags":["leetcode"],"title":"lc273. Integer to English Words","uri":"/lc273.integer_to_english_words/"},{"categories":["leetcode"],"content":"Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2). You may return the answer in any order. The answer is guaranteed to be unique(except for the order that it is in). Example 1: Input: points = [[1,3],[-2,2]], k = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10). The distance between (-2, 2) and the origin is sqrt(8). Since sqrt(8) \u003c sqrt(10), (-2, 2) is closer to the origin. We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]]. Example 2: Input: points = [[3,3],[5,-1],[-2,4]], k = 2 Output: [[3,3],[-2,4]] Explanation: The answer [[-2,4],[3,3]] would also be accepted. Constraints: 1 \u003c= k \u003c= points.length \u003c= 104 -104 \u003c xi, yi \u003c 104 解题思路： 最直接的解法就是把每个点的距离计算出来之后，然后根据大小排序取前k。 难点：如何在排序算法中采用最快的方式。 可以考虑使用快速排序方法： class Solution(object): def kClosest(self, points, k): \"\"\" :type points: List[List[int]] :type k: int :rtype: List[List[int]] \"\"\" def calDist(points): return [(x,x[0]*x[0]+x[1]*x[1]) for x in points] def quickSort(lists,i,j): if i \u003e= j: return list pivot = lists[i] low = i high = j while i \u003c j: while i \u003c j and lists[j][1] \u003e= pivot[1]: j -= 1 lists[i]=lists[j] while i \u003c j and lists[i][1] \u003c=pivot[1]: i += 1 lists[j]=lists[i] lists[j] = pivot quickSort(lists,low,i-1) quickSort(lists,i+1,high) return lists _points=calDist(points) _points=quickSort(_points,0,len(_points)-1) return [_points[idx][0] for idx in range(k)] 但是快速排序性能不稳定，性能取决于pivot的选择。因为这个题有限制条件为topK，所以我们可以进一步考虑使用堆排序，通过维护一个大小为K的堆来遍历数据。 这里为了简化代码，我们调用python自带的heapq模块。由于heapq模块默认的保留K最大，所以为了获得k距离最近的点，我们需要把距离取负值。 import heapq class Solution(object): def kClosest(self, points, k): \"\"\" :type points: List[List[int]] :type k: int :rtype: List[List[int]] \"\"\" def dist(point): return (-(point[0]**2+point[1]**2),point) h=[] for point in points: if len(h)\u003ck: heapq.heappush(h,dist(point)) else: _new=dist(point) if h[0][0]\u003c_new[0]: heapq.heappop(h) heapq.heappush(h,_new) return [x[1] for x in h] 执行用时：148 ms, 在所有 Python 提交中击败了37.37%的用户 内存消耗：18.1 MB, 在所有 Python 提交中击败了53.54%的用户 使用堆在性能上显著优于使用快排。 ","date":"2022-01-16","objectID":"/lc973.k_closest_points_to_origin/:0:0","tags":["leetcode"],"title":"lc973. K Closest Points to Origin","uri":"/lc973.k_closest_points_to_origin/"},{"categories":["leetcode"],"content":"Given a string s, return true if the s can be palindrome after deleting at most one character from it. Example 1: Input: s = \"aba\" Output: true Example 2: Input: s = \"abca\" Output: true Explanation: You could delete the character 'c'. Example 3: Input: s = \"abc\" Output: false Constraints: 1 \u003c= s.length \u003c= 105 s consists of lowercase English letters. 解题思路： 如果最多删除一个字母可以使字符串满足回文序列即返回true。 我们可以从字符串两端开始依次比较，如果遇到不同，我们有一次机会删除其中一个字母继续比较，一个简单的while循环就可以完成任务。 代码： class Solution(object): def validPalindrome(self, s): \"\"\" :type s: str :rtype: bool \"\"\" def isPalindrome(_s): _left=0 _right=len(_s)-1 while _left\u003c_right: if _s[_left]!=_s[_right]: return False else: _left+=1 _right-=1 return True delcount=0 left=0 right=len(s)-1 while left\u003cright: if s[left]==s[right]: left+=1 right-=1 else: if delcount==0: delcount+=1 if isPalindrome(s[left+1:right+1])==True: left+=1 elif isPalindrome(s[left:right])==True: right-=1 else: return False else: return False return True 性能： 执行用时：140 ms, 在所有 Python 提交中击败了17.65%的用户 内存消耗：13.6 MB, 在所有 Python 提交中击败了47.06%的用户 ","date":"2022-01-13","objectID":"/lc680.valid_palindrome_ii/:0:0","tags":["leetcode"],"title":"lc680. Valid Palindrome II","uri":"/lc680.valid_palindrome_ii/"},{"categories":["leetcode"],"content":"In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language. Example 1: Input: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\" Output: true Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted. Example 2: Input: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\" Output: false Explanation: As 'd' comes after 'l' in this language, then words[0] \u003e words[1], hence the sequence is unsorted. Example 3: Input: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\" Output: false Explanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" \u003e \"app\", because 'l' \u003e '∅', where '∅' is defined as the blank character which is less than any other character (More info). Constraints: 1 \u003c= words.length \u003c= 100 1 \u003c= words[i].length \u003c= 20 order.length == 26 All characters in words[i] and order are English lowercase letters. 解题思路： 对于每一个单词的每一个字母我们都可以用其在字典中的位置来编码，比如说： hello=[0,6,1,1,14]，对于字典order = “hlabcdefgijkmnopqrstuvwxyz” 给定一组词汇如：words = [“hello”,“leetcode”] 我们可以把其中的单词全部翻译成index，然后依次比较。 代码： class Solution(object): def isAlienSorted(self, words, order): \"\"\" :type words: List[str] :type order: str :rtype: bool \"\"\" def word2idx(word,order): out=[] for _ in word: out.append(order.index(_)) return out A_idx=None # to record the left one B_idx=None # to record the right one for i in range(len(words)-1): A_idx=word2idx(words[i],order) B_idx=word2idx(words[i+1],order) flag=True while len(A_idx)!=0 and len(B_idx)!=0 and flag==True: A=A_idx[0] A_idx=A_idx[1:] B=B_idx[0] B_idx=B_idx[1:] if A\u003cB: flag=False elif A\u003eB: return False elif A==B: pass if flag==True: if len(A_idx)!=0: return False else: pass return True 性能： 执行用时：20 ms, 在所有 Python 提交中击败了69.01%的用户 内存消耗：13 MB, 在所有 Python 提交中击败了87.32%的用户 优化： 原始代码中定义了一些不必要的操作步骤，导致拉满速度和时间，以下代码采用了一样的思路，但运行速度更快： class Solution: def isAlienSorted(self, words: List[str], order: str) -\u003e bool: di = dict() # storing the alphabet order of language via hashmap for i in range(len(order)): di[order[i]] = i+1 # helper function comparing two words def compareWords(w1, w2): i = 0 # looping depends on smaller word while i\u003cmin(len(w1), len(w2)): # getting order/rank of words rank1, rank2 = di.get(w1[i]), di.get(w2[i]) # correct order if w2's rank is greater if rank1 \u003c rank2: return True # continue if letters are same elif rank1 == rank2: i += 1 continue # incorrect order if w1's rank is greater else: return False # w1 should be smaller if all letters are equal if len(w1)\u003elen(w2): return False else: return True for i in range(len(words)-1): w1, w2 = words[i], words[i+1] # comparing with the immediate next word if not compareWords(w1, w2): return False return True ","date":"2022-01-12","objectID":"/lc953.verifying_an_alien_dictionary/:0:0","tags":["leetcode"],"title":"lc953. Verifying an Alien Dictionary","uri":"/lc953.verifying_an_alien_dictionary/"},{"categories":["leetcode"],"content":"Given a string s of '(' , ')' and lowercase English characters. Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string. Formally, a parentheses string is valid if and only if: It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. Example 1: Input: s = \"lee(t(c)o)de)\" Output: \"lee(t(c)o)de\" Explanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted. Example 2: Input: s = \"a)b(c)d\" Output: \"ab(c)d\" Example 3: Input: s = \"))((\" Output: \"\" Explanation: An empty string is also valid. Constraints: 1 \u003c= s.length \u003c= 105 s[i] is either'(' , ')', or lowercase English letter. 解题思路： 有效字符串的意味着其中的左括号和右括号一对一匹配的（paired），最终序列中没有多余的括号，所以使用栈或者计数器来统计括号出现是比较好的解法。 题中的Minimum remove非常的让人困惑怀疑题目是否存在某些边界条件，比如说字符串存在多种remove方式都可以获得有效字符串（不考虑同时remove paired括号），其中有一种需要移除的括号数目是最少的。仔细思考后会发现这种情况是不存在的，字符串可能存在多种移除方式，但是这些移除方式所移除的数目都是相同的。 class Solution: def minRemoveToMakeValid(self, s): left, right, output = 0, s.count(')'),'' for _chr in s: if _chr=='(': if right\u003e0: # 有效左括号 left+=1 right-=1 output+=_chr elif _chr==')': if left==0: # 无效右括号 right-=1 else: left-=1 output+=_chr else: # 非括号字符 output+=_chr return output 性能： 执行用时：1456 ms, 在所有 Python 提交中击败了29.47%的用户 内存消耗：14.8 MB, 在所有 Python 提交中击败了94.74%的用户 ","date":"2022-01-11","objectID":"/lc1249.minimum_remove_to_make_valid_parentheses/:0:0","tags":["linux","leetcode"],"title":"lc1249. Minimum Remove to Make Valid Parentheses","uri":"/lc1249.minimum_remove_to_make_valid_parentheses/"},{"categories":["leetcode"],"content":"Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class: MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. Example 1: Input [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 Constraints: -231 \u003c= val \u003c= 231 - 1 Methods pop, top and getMinoperations will always be called on non-empty stacks. At most 3 * 104 calls will be made to push, pop, top, and getMin. 解题思路 Stack进行push和pop操作都非常简单，困难的是如何操作getMin。 getMin即拿到stack中所有未出栈数据中的最小值，因此我们在push和pop时可以给每个数据附加上一个属性，即当前的最小值。 each element is (x,x), the first value if the real value and the second value if the current min value 有几个注意点： 考虑边界条件，比如说stack中的最后一个数据被pop 每次pop之后需要把当前最小值变为top数据的最小值。 class MinStack(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.data=[] self.current_min=None # each element is (x,x), the first value if the real value and the second value if the current min value def push(self, x): \"\"\" :type x: int :rtype: None \"\"\" if self.current_min==None: self.current_min=x self.data.append((x,self.current_min)) elif x\u003e=self.current_min: self.data.append((x,self.current_min)) elif x\u003cself.current_min: self.current_min=x self.data.append((x,self.current_min)) return None def pop(self): \"\"\" :rtype: None \"\"\" self.data.pop(-1) if len(self.data)==0: self.current_min=None else: self.current_min=self.data[-1][1] return None def top(self): \"\"\" :rtype: int \"\"\" return self.data[-1][0] def min(self): \"\"\" :rtype: int \"\"\" return self.data[-1][1] # Your MinStack object will be instantiated and called as such: # obj = MinStack() # obj.push(x) # obj.pop() # param_3 = obj.top() # param_4 = obj.min() 性能： 执行用时：108 ms, 在所有 Python 提交中击败了85.47%的用户 内存消耗：17 MB, 在所有 Python 提交中击败了5.14%的用户 其它可能解法： 辅助栈 取巧的方法可以直接使用min函数 ","date":"2022-01-08","objectID":"/lc155.min_stack/:0:0","tags":["linux","leetcode"],"title":"lc155.Min Stack","uri":"/lc155.min_stack/"},{"categories":["leetcode"],"content":"用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 输入： [\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2： 输入： [\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示： 1 \u003c= values \u003c= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 输入为两个栈， 第一个栈对应的是操作： [“CQueue”,“appendTail”,“deleteHead”,“deleteHead”] CQueue表示init一个CQueue object appendTail表示调用appendTail函数 deleteHead表示调用deleteHead函数 第二个栈对应的是操作的值。 栈（Stack）的特点是先入后出，但是我们需要实现直接操作Head的功能。因此使用两个Stack可以实现列表倒序。 class CQueue: def __init__(self): self.A, self.B = [], [] def appendTail(self, value: int) -\u003e None: self.A.append(value) def deleteHead(self) -\u003e int: if self.B: return self.B.pop() if not self.A: return -1 while self.A: self.B.append(self.A.pop()) return self.B.pop() 时间复杂度： appendTail()为O(1), deleteHead()为O(N) 空间复杂度：O(N) ","date":"2022-01-08","objectID":"/jz09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/:0:0","tags":["linux","leetcode"],"title":"剑指 Offer 09. 用两个栈实现队列","uri":"/jz09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"categories":["Papers"],"content":"Title: A geometric deep learning approach to predict binding conformations of bioactive molecules DOI: https://doi.org/10.1038/s42256-021-00409-9 INFO: NATURE MACHINE INTELLIGENCE | VOL 3 | DECEMBER 2021 发表周期: Received: 18 May 2021; Accepted: 28 September 2021; Published online: 2 December 2021 药物设计是近年来AI应用的极火领域之一，其中一个最有挑战的问题就是空间结构设计。 One of the difficulties arises from the fact that only a small portion of the large chemical space will bind to a specific biological target and result in a therapeutic effect. 这篇文章中作者应用深度学习模型DeepDock捕获protein-ligand complex中的原子级微环境特征学习其中的结合构象。 数据集制备 The model reported in this study was trained using the general set of the PDBbind database (v.2019)30, which contains a collection of 17,679 protein–ligand structures with their respective potency (half-maximum inhibitory concentration, dissociation constant and so on). From these, we removed those complexes that are included in the CASF-2016 benchmark and those that failed during the preprocessing step, leaving a total of 16,367 protein–ligand complexes, which were randomly divided in a training set containing 15,000 complexes and a test set with 1,367. PDBbind数据库（http://www.pdbbind.org.cn）是基于PDB数据库，整合了大量实验统计所得的蛋白亲和力数据。 The PDBbind database is a comprehensive collection of experimentally measured binding affinity data (Kd, Ki, and IC50) for the protein-ligand complexes deposited in the Protein Data Bank (PDB).[1][2] It thus provides a link between energetic and structural information of protein-ligand complexes, which is of great value to various studies on molecular recognition occurred in biological systems. 作者使用图结构表示蛋白空间结构，node表示原子，edge表示bond。 Every node is represented by a one-hot vector that indicates the atom type among 28 possibilities (Be, B, C, N, O, F, Mg, Si, P, S, Cl, V, Fe, Co, Cu, Zn, As, Se, Br, Ru, Rh, Sb, I, Re, Os, Ir, Pt and Hg). 目标蛋白表面使用MSMS建模。 As in MaSIF, protein surfaces were triangulated using MSMS37 with a density of 3.0 nodes per Å^2 and a probe radius of 1.5 Å. The resulting meshes were downsampled to a resolution of 1 Å and processed using PyMesh. 只有具备结合位点性质的node才用于模型训练。 网络训练 如Fig1c，平行的图卷积网络被用来分别提取ligand和target结构中的表征以及特征编码。 Our approach directly uses the molecular surface of the binding site in the form of a polygon mesh. Both the target mesh and the ligand graph are processed by independent residual GNNs. Through this procedure, the processed node fea- tures not only contain information of an individual atom or point in the molecular surface, but also have information about the other nodes around them. In other words, the processed atom features encode all the atomic environment around a specific atom, whereas the target features encode a patch of the molecular surface around a specific point. GNN从ligand和target中分别提取出来的特征在特征向量上简单拼接后被送入mixture density network (MDN)。 by using this probability density function we can estimate the likelihood of finding ligand node i separated from a target node j by any distance $d_{ij}$. 模型评估 作者通过在CASF-2016 benchmark预测 Docking power Forward screening power Reverse screening power 来评估模型性能。 Docking power The evaluation of docking power measures the ability of a scor- ing function to identify native ligand binding poses among a set of decoys. Screening power The evaluation of screening power in CASF-2016 is designed to measure the ability of a scoring function to identify true binders of a specific target from a pool of random compounds. 模型细节 模型可分为3部分： 特征提取 特征融合 MDN First, the node and edge features are projected to a 128D embedding using a linear layer. We then use a sequence of three GNNs to update each node and edge based on their neighbouring nodes and the type of edges connecting them. After the initial processing by the GNNs, the node and edge features were processed by 10 residual GNN blocks. The MDN uses an MLP to create a hidden representation $h_{r,s}$ that combines the concatenated target and ligand node information. All MLPs used are composed of a linear layer followed by batch n","date":"2022-01-02","objectID":"/nmi-a-geometric-deep-learning-approach-to-predict-binding-conformations-of-bioactive-molecules/:0:0","tags":["NMI","Machine learning","proteins"],"title":"[NMI] A geometric deep learning approach to predict binding conformations of bioactive molecules 解读","uri":"/nmi-a-geometric-deep-learning-approach-to-predict-binding-conformations-of-bioactive-molecules/"},{"categories":["database"],"content":"ER diagram Notation: Chen Notation Crow’s Foot Notation UML Class Diagram Notation ","date":"2022-01-02","objectID":"/er_diagram_notation/:0:0","tags":["SQL","database"],"title":"ER Diagram Notation","uri":"/er_diagram_notation/"},{"categories":["system"],"content":"Example MD ","date":"2022-01-01","objectID":"/example/:0:0","tags":["linux"],"title":"Example","uri":"/example/"},{"categories":["system"],"content":"Problem Description Fors some unknow reason, the user is unable to click the text boxes or type anything into the publish window after running the Build \u0026 Publish. When the user clicks the main window in Unity, the cursor disappears and the user can not select the text boxes or anything else. This problem happens under my settings, macOS Catalina 10.15.7, Unity 2019.4.31f1, VRChat SDK3. Solution The reason of this problem is that when you click the temp scene created by the SDK3, the cursor will be invisible and locked. Find this file: VRCSDK/Dependencies/VRChat/ Scripts/RuntimeWorldCreation.cs Find this content, marked function Start(). new void Start() { if (!Application.isEditor || !Application.isPlaying) return; base.Start(); IsCurrentWorldInCommunityLabs = false; IsCurrentWorldUploaded = false; IsCurrentWorldPubliclyPublished = false; var desc = pipelineManager.GetComponent\u003cVRC.SDKBase.VRC_SceneDescriptor\u003e(); desc.PositionPortraitCamera(imageCapture.shotCamera.transform); Application.runInBackground = true; UnityEngine.XR.XRSettings.enabled = false; uploadButton.onClick.AddListener(SetupUpload); openCommunityLabsDocsButton.onClick.AddListener(OpenCommunityLabsDocumentation); shouldUpdateImageToggle.onValueChanged.AddListener(ToggleUpdateImage); releasePublic.gameObject.SetActive(false); System.Action\u003cstring\u003e onError = (err) =\u003e { VRC.Core.Logger.LogError(\"Could not authenticate - \" + err, DebugLevel.Always); blueprintPanel.SetActive(false); errorPanel.SetActive(true); }; Add 2 lines. Cursor.visible=true; Cursor.lockState=0; Now the final content will be new void Start() { Cursor.visible=true; Cursor.lockState=0; if (!Application.isEditor || !Application.isPlaying) return; base.Start(); IsCurrentWorldInCommunityLabs = false; IsCurrentWorldUploaded = false; IsCurrentWorldPubliclyPublished = false; var desc = pipelineManager.GetComponent\u003cVRC.SDKBase.VRC_SceneDescriptor\u003e(); desc.PositionPortraitCamera(imageCapture.shotCamera.transform); Application.runInBackground = true; UnityEngine.XR.XRSettings.enabled = false; uploadButton.onClick.AddListener(SetupUpload); openCommunityLabsDocsButton.onClick.AddListener(OpenCommunityLabsDocumentation); shouldUpdateImageToggle.onValueChanged.AddListener(ToggleUpdateImage); releasePublic.gameObject.SetActive(false); System.Action\u003cstring\u003e onError = (err) =\u003e { VRC.Core.Logger.LogError(\"Could not authenticate - \" + err, DebugLevel.Always); blueprintPanel.SetActive(false); errorPanel.SetActive(true); }; if (!ApiCredentials.Load()) onError(\"Not logged in\"); else APIUser.InitialFetchCurrentUser( delegate (ApiModelContainer\u003cAPIUser\u003e c) { UserLoggedInCallback(c.Model as APIUser); }, delegate (ApiModelContainer\u003cAPIUser\u003e c) { onError(c.Error); } ); Now rebuild, you find you can edit the texts now. ","date":"2021-12-17","objectID":"/vrcsdk_can_not_edit_text/:0:0","tags":["linux"],"title":"Unable to interact with text boxes during Build \u0026 Publish for VRChat SDK3","uri":"/vrcsdk_can_not_edit_text/"},{"categories":["system"],"content":" Avticate your environment，check for package ipykernel python -m ipykernel --version If it’s not installed： python -m pip install ipykernel Add kernel to Jupyter notebook python -m ipykernel install --user --name 'kernelname' Check Jupyter notebook kernel jupyter kernelspec list Delet jupyter kernel jupyter kernelspec remove kernelname ","date":"2021-11-28","objectID":"/install-jupyter-kernel/:0:0","tags":["system","linux","conda","python"],"title":"Install kernel for jupyter notebook","uri":"/install-jupyter-kernel/"},{"categories":["leetcode"],"content":"Given a string s, find the length of the longest substring without repeating characters. Example 1: Input: s = \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: s = \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: s = \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring. Example 4: Input: s = \"\" Output: 0 Constraints: 0 \u003c= s.length \u003c= 5 * 104 s consists of English letters, digits, symbols and spaces. Thinking The simplest method to do is the brute force searching. Given a substring, we check whether it contains repeated characters. Then for all substrings of a given string, we do such a test and the total number of substrings of a given string with length $n$ is $n*(n+1)/2$. For example, For each substring str[i, j] i.e. starting from index i and ending at index j, we use a function areUnique(str, i, j) to check if all the characters in the substring are unique or not. It will return true if all the characters are unique, otherwise false. The time complexity of areUnque(str,i,j) is $O(j-i+1)$. So the overall time compelxity is $n*(n+1)/2*O(j-i+1)=O(n^2)*O(j-i+1)$. In the worst-case, $O(j-i+1)=O(n)$, so the worst-case overall time complexity is $O(n^3)$. We are using few extra variables and a constant size set visited[]. So space complexity = O(1). To optimize, here is an optimization insight: In the brute force idea, we repeatedly check a substring starting from the character str[i] to see if it has a duplicate character or not. We can optimize it further because, during the loop, if a substring str[i, j-1] is already checked to have no duplicate characters, then for the substring str[i, j], we only need to check if str[j] is already present in the substring str[i, j-1] or not. Partially cited from: https://www.enjoyalgorithms.com/blog/longest-substring-without-repeating-characters 暴力解法： class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" _max=0 for i in range(len(s)): sub=[s[i]] for j in range(i+1,len(s)): if s[j] not in sub: sub.append(s[j]) else: break if len(sub)\u003e_max: _max=len(sub) return _max 时间复杂度为O(N^2) 滑动窗口解法： class Solution: def lengthOfLongestSubstring(self, s): if not s:return 0 left = 0 lookup = set() n = len(s) max_len = 0 cur_len = 0 for i in range(n): cur_len += 1 while s[i] in lookup: lookup.remove(s[left]) left += 1 cur_len -= 1 if cur_len \u003e max_len:max_len = cur_len lookup.add(s[i]) return max_len 时间复杂度为O(N) ","date":"2021-11-18","objectID":"/lc3.longest_substring_without_repeating_characters/:0:0","tags":["coding"],"title":"lc3.Longest Substring Without Repeating Characters","uri":"/lc3.longest_substring_without_repeating_characters/"},{"categories":["interview"],"content":"Q. What are genetic algorithm and evolutionary algorithm? Genetic algorithm (GA) is a sub-class of evolutionary algorithm (EA). There are 3 implementation of EAs: GA, evolution strategies (ES), and evolutionary programming (EP). Among these, GAs have proved to be the most popular of the 3 EAs. These algorithms are similar in general, yet there are big differences among them: GA: They were developed by Holland and thoroughly reviewed by Goldberg; ES: They were developed by Rechenberg and Schwefe; and EP: It was developed by L.J. Fogel and D.B. Fogel. Similarity and Differences: All 3 operate on fixed length strings, which contain real values in ESs and EP and binary numbers in the canonical GA. All 3 incorporate a mutation operator: for ESs and EP mutation is the driving force. GAs and ESs also use a recombination operator, which is the primary operator for the GA. All 3 use a selection operator which applies evolutionary pressure, either instinctive (in ESs and EP, the operator determines which individuals will be excluded from the new population) or preservative (in the GA the operator selects individuals for breeding).. In GAs and EP selection is probabilistic, while ESs use a deterministic selection. ESs and meta-EP allow self-adaptation, where parameters controlling mutation are allowed to evolve along with object variables. Finally, it is worth noting that the implementer is free to modify these algorithms. For example, the GA can be run using an integer alphabet. From: https://www.researchgate.net/post/Are_Genetic_Algorithms_GA_and_Evolutionary_Algorithms_EA_the_same_or_different ","date":"2021-11-14","objectID":"/i4.gaea/:0:0","tags":["interview","machine learning"],"title":"i4.genetic algorithm and evolutionary algorithm","uri":"/i4.gaea/"},{"categories":["system"],"content":"Install sudo apt install slurm-wlm slurm-wlm-doc -y Modify config rm /etc/slurm-llnl/slurm.conf vi /etc/slurm-llnl/slurm.conf Example of config # slurm.conf file generated by configurator easy.html. # Put this file on all nodes of your cluster. # See the slurm.conf man page for more information. # ControlMachine=girl #ControlAddr= # #MailProg=/bin/mail MpiDefault=none #MpiParams=ports=#-# ProctrackType=proctrack/pgid ReturnToService=1 SlurmctldPidFile=/var/run/slurm-llnl/slurmctld.pid #SlurmctldPort=6817 SlurmdPidFile=/var/run/slurm-llnl/slurmd.pid #SlurmdPort=6818 SlurmdSpoolDir=/var/spool/slurmd SlurmUser=slurm #SlurmdUser=root StateSaveLocation=/var/spool/slurm-llnl SwitchType=switch/none TaskPlugin=task/none # # # TIMERS #KillWait=30 #MinJobAge=300 #SlurmctldTimeout=120 #SlurmdTimeout=300 # # # SCHEDULING FastSchedule=1 SchedulerType=sched/backfill SelectType=select/linear #SelectTypeParameters= # # # LOGGING AND ACCOUNTING AccountingStorageType=accounting_storage/none ClusterName=cluster #JobAcctGatherFrequency=30 JobAcctGatherType=jobacct_gather/none #SlurmctldDebug=3 #SlurmctldLogFile= #SlurmdDebug=3 #SlurmdLogFile= # # # COMPUTE NODES NodeName=girl CPUs=4 State=UNKNOWN PartitionName=debug Nodes=girl Default=YES MaxTime=INFINITE State=UP Mkdir and Chown rm -rf /var/spool/slurm-llnl mkdir /var/spool/slurm-llnl chown -R slurm.slurm /var/spool/slurm-llnl rm -rf /var/run/slurm-llnl/ mkdir /var/run/slurm-llnl/ chown -R slurm.slurm /var/run/slurm-llnl/ Start slurmd and enable on boot systemctl start slurmd systemctl enable slurmd systemctl start slurmctld systemctl enable slurmctld Start service systemctl restart slurmctld systemctl restart slurmd ","date":"2021-11-14","objectID":"/install-slurm/:0:0","tags":["system","linux"],"title":"Install Slurm in Ubuntu","uri":"/install-slurm/"},{"categories":["system"],"content":"问题在于VNCServer使用Python编写，所以受到系统Python版本影响。 解决方案： $ cd $HOME $ vim .bashrc 找到如下语句： export PATH=\"/home/user/anaconda2/bin:$PATH\" 并修改为，并保存退出。 export PATH=\"$PATH:/home/user/anaconda2/bin\" $ vncserver -kill :id $ source .bashrc $ conda config --set auto_activate_base false #取消conda自动启动base ","date":"2021-11-14","objectID":"/%E5%AE%89%E8%A3%85python%E5%AF%BC%E8%87%B4vnc%E7%95%8C%E9%9D%A2%E9%BB%91%E5%B1%8F/:0:0","tags":["system","linux"],"title":"安装Python导致VNC黑屏解决方案","uri":"/%E5%AE%89%E8%A3%85python%E5%AF%BC%E8%87%B4vnc%E7%95%8C%E9%9D%A2%E9%BB%91%E5%B1%8F/"},{"categories":["interview"],"content":"Q. What Are the Different Types of Machine Learning? Supervised learning A model makes predictions or decisions based on past or labeled data. Labeled data refers to sets of data that are given tags or labels, and thus made more meaningful. Unsupervised learning In this case, we don’t have labeled data, a model can identify patterns, anomalies, and relationships in the input data. Reinforcement learning The model learn based on the rewards received from the previous action. ","date":"2021-11-08","objectID":"/i3.different-types-of-machine-learning/:0:0","tags":["interview","machine learning"],"title":"i3.different types of machine learning","uri":"/i3.different-types-of-machine-learning/"},{"categories":["leetcode"],"content":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 1: Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. Example 2: Input: l1 = [0], l2 = [0] Output: [0] Example 3: Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1] Constraints: The number of nodes in each linked list is in the range [1, 100]. 0 \u003c= Node.val \u003c= 9 It is guaranteed that the list represents a number that does not have leading zeros. Thinking To understand the question, we need to specify: 2-\u003e4-\u003e3 stands for the number 342 5-\u003e6-\u003e4 stands for the number 465 So, the sum should be 807, which can be represented as 7-\u003e0-\u003e8 Then the process goes easily. Firstly we add 2 and 5, which is the first element of both lists, if the sum is smaller than 10, then we simply output the sum to the corresponding element in the output list. Let’s say 2+5-\u003e7. If sum is \u003e=10, we leave the mode to the corresponding position in the output list and add 1 to the follow position as we know the sum \u003c=19 (9+9+?1), here ?1 depends on whether there is a 1 from the previous position. Solution class Solution: def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -\u003e Optional[ListNode]: _add2next=0 initialNode=ListNode() currentNode=initialNode while True: try: _l1=l1.val except: _l1=0 try: _l2=l2.val except: _l2=0 _sum=_l1+_l2+_add2next currentNode.val=_sum%10 _add2next=_sum//10 try: l1=l1.next except: l1=None try: l2=l2.next except: l2=None if l1==l2==None and _add2next==0: break elif l1==l2==None and _add2next==1: currentNode.next=ListNode(val=1) break else: nextNode=ListNode() currentNode.next=nextNode currentNode=nextNode return initialNode Runtime: 68ms Memory: 14.4MB ","date":"2021-11-07","objectID":"/lc2.add2numbers/:0:0","tags":["coding"],"title":"lc2.Add Two Numbers","uri":"/lc2.add2numbers/"},{"categories":["system"],"content":"MacOS install uPic brew install uPic Set uPic Set uPic host to Github The default host is SMMS Set Typora uploading to uPic ","date":"2021-11-07","objectID":"/typora-upic-github-image-hosting-service/:0:0","tags":["linux"],"title":"typora \u0026 uPic \u0026 Github image hosting service","uri":"/typora-upic-github-image-hosting-service/"},{"categories":["system"],"content":"Mofidy .inputrc sudo vi ~/.inputrc Add this line set completion-ignore-case on Restart your terminal Now you can ignore the upper and lower case when you use Tab in terminal ","date":"2021-11-05","objectID":"/how-to-ignore-upperlower-case-with-tab-in-ubuntu/:0:0","tags":["linux"],"title":"How to ignore upper and lower case when using Tab in Ubuntu","uri":"/how-to-ignore-upperlower-case-with-tab-in-ubuntu/"},{"categories":["system"],"content":"Mofidy bash.bashrc sudo vi /etc/bash.bashrc Find those code in the file #enable bash completion in interactive shells #if ! shopt -oq posix; then # if [-f /usr/share/bash-completion/bash_completion ]; then # . /usr/share/bash-completion/bash_completion # elif [ -f /etc/bash_completion]; then # . /etc/bash_completion # fi #fi Remove # Like below: #enable bash completion in interactive shells if ! shopt -oq posix; then if [-f /usr/share/bash-completion/bash_completion ]; then . /usr/share/bash-completion/bash_completion elif [ -f /etc/bash_completion]; then . /etc/bash_completion fi fi Source it sudo source /etc/bash.bashrc Now you can use Tab to autocomplete your command ","date":"2021-11-04","objectID":"/how-to-set-autocomplete-in-ubuntu/:0:0","tags":["linux"],"title":"How to set autocomplete in Ubuntu","uri":"/how-to-set-autocomplete-in-ubuntu/"},{"categories":["interview"],"content":"Q. How Many Times Do A Clock’s Hands Overlap In A Day? The most important is not the answer but the way to think and work out problems. In total 22, because the clock hands approximately overlap at 12:00, 1:05, 2:10, 3:15, 4:20, 5:25, 6:30, 7:35, 8:40, 9:45 and 10:50 twice a day. Although reaching the wrong answer is fine to an extent, you should avoid these common errors. Don’t just blurt out an answer without thinking it through. If you give the wrong answer, don’t get flustered. Don’t say, “I don’t know.” Don’t sit in silence. If you just sit in your chair quietly, then the interviewer is not going to know how you came to your answer. Talking the answer out gives the hiring manager valuable insight into how you are able to think. cite from: https://www.livecareer.com/resources/interviews/questions/how-many-times-do-a-clocks-hands-overlap-in-a-day ","date":"2021-11-04","objectID":"/i2.clock-hand-overlap/:0:0","tags":["interview","thinking"],"title":"i2.How Many Times Do A Clock’s Hands Overlap In A Day?","uri":"/i2.clock-hand-overlap/"},{"categories":["system"],"content":"Install You can find it at here: https://github.com/svenstaro/miniserve/releases Usage miniserve --help miniserve 0.4.1 Sven-Hendrik Haase \u003csvenstaro@gmail.com\u003e, Boastful Squirrel \u003cboastful.squirrel@gmail.com\u003e For when you really just want to serve some files over HTTP right now! USAGE: miniserve [FLAGS] [OPTIONS] [--] [PATH] FLAGS: -u, --upload-files Enable file uploading -h, --help Prints help information -P, --no-symlinks Do not follow symbolic links -o, --overwrite-files Enable overriding existing files during file upload --random-route Generate a random 6-hexdigit route -V, --version Prints version information -v, --verbose Be verbose, includes emitting access logs OPTIONS: -a, --auth \u003cauth\u003e Set authentication (username:password) -c, --color-scheme \u003ccolor_scheme\u003e Default color scheme [default: Squirrel] [possible values: Archlinux, Zenburn, Monokai, Squirrel] -i, --if \u003cinterfaces\u003e... Interface to listen on -p, --port \u003cport\u003e Port to use [default: 8080] ARGS: \u003cPATH\u003e Which path to serve Serve single folder miniserve share/ -u -o Serve single file miniserve file Start user verification miniserve --auth joe:123 some_dir ","date":"2021-11-04","objectID":"/miniserver/:0:0","tags":["linux"],"title":"Miniserve, an elegant file server","uri":"/miniserver/"},{"categories":["interview"],"content":"Q. What is the most efficient way to sort a million integers? Time Complexity Sorting Algorithm Average Case Best Case Worst Case Bubble Sort O(n^2) O(n) O(n^2) Insertion Sort O(n^2) O(n) O(n^2) Selection Sort O(n^2) O(n^2) O(n^2) Quick Sort O(n.log(n)) O(n.log(n)) O(n^2) Merge Sort O(n.log(n)) O(n.log(n)) O(n.log(n)) Heap Sort O(n.log(n)) O(n.log(n)) O(n.log(n)) Counting Sort O(n+k) O(n+k) O(n+k) Radix Sort O(n*k) O(n*k) O(n*k) Bucket Sort O(n+k) O(n+k) O(n^2) Space Complexity Sorting Algorithm Space Complexity Bubble Sort O(1) Insertion Sort O(1) Selection Sort O(1) Quick Sort O(log(n)) Merge Sort O(n) Heap Sort O(1) Counting Sort O(k) Radix Sort O(n + k) Bucket Sort O(n) Stability Sorting Algorithm Stable Sort? Bubble Sort Yes Insertion Sort Yes Selection Sort No Quick Sort No Merge Sort Yes Heap Sort No Counting Sort Yes Radix Sort Yes Bucket Sort Yes Consider above all, merge sort will be the best choice. ","date":"2021-11-03","objectID":"/i1.sort-1-million/:0:0","tags":["interview","bat","algorithm"],"title":"i1.What is the most efficient way to sort a million integers?","uri":"/i1.sort-1-million/"},{"categories":["coding"],"content":"Install Conda Packaging Tool conda install conda-build anaconda-client ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:0","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"File Structure - home/ - my_package/ - my_package/ - package_lib/ - setup.py - README.md - run_test.py - build.sh - meta.yaml ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:1","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"meta.yaml This file tells conda-build how to package files under my_package/ package: name: my_package version: 1.1.2 source: path: my_package/my_package/ build: number: 0 requirements: build: - python \u003e=3 - setuptools run: - python \u003e=3 - numpy \u003e=1.20 - scipy - pandas - scikit-learn \u003e=0.22 - lightgbm - matplotlib - seaborn - plink \u003e=1.9 test: source_files: - run_test.py about: home: https://github.com/JoshuaChou2018 license: MIT ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:2","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"build.sh The build.sh script contains methods to compile and install. So we use setuptools to complete the compilation and installation process. Content of build.sh # Install my_package $PYTHON setup.py install ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:3","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"setup.py # -*- coding: utf-8 -*- from setuptools import setup, find_packages setup( name='my_package', version='1.0.3', description=( 'my_package' ), author='my_package', author_email='my_package', maintainer='my_package', maintainer_email='my_package', license='MIT License', url='https://github.com/JoshuaChou2018/my_package', packages=find_packages(), entry_points={ 'console_scripts': [ 'run = my_package.entry:main', ] }, classifiers=[ 'Operating System :: OS Independent', 'License :: OSI Approved :: MIT License', 'Programming Language :: Python :: 3' ], python_requires='\u003e=3' ) ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:4","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"Start build conda build my_package/ ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:5","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":["coding"],"content":"Publish anaconda login anaconda upload /home/miniconda3/conda-bld/linux-64/my_package-1.0.0-py39_0.tar.bz2 ","date":"2021-11-01","objectID":"/publish-package-on-conda/:0:6","tags":["conda","python"],"title":"Publish python package on Anaconda","uri":"/publish-package-on-conda/"},{"categories":null,"content":" Hi! I’m Juexiao Zhou, Joshua Chou, 周觉晓 PhD student @KAUST. Major in Computer Science and Bioinformatics. Email: juexiao.zhou@kaust.edu.sa, juexiao.zhou@gmail.com Wechat: JoshuaChou666 CV, Github, Linkedln, ORCID, Google Scholar ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Education PhD Student, Supervised by Prof. Xin Gao, Computational Bioscience Research Center (CBRC), King Abdullah University of Science and Technology, Dec 2021 - Present Master of Science, M.S., Supervised by Prof. Xin Gao, Computational Bioscience Research Center (CBRC), King Abdullah University of Science and Technology, Aug 2020 - Dec 2021 Visiting Student, Supervised by Prof. Xin Gao, Computational Bioscience Research Center (CBRC), King Abdullah University of Science and Technology, Sep 2019 - Feb 2020 B.S. (Honored) in Bioinformatics, Supervised by Prof. Wei Chen, Southern University of Science and Technology, Sep 2016 - Jun 2020 ","date":"0001-01-01","objectID":"/about/:0:1","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Research Interest Intelligent Healthcare and Privacy Medical Imaging EEG, X-ray, CT, fMRI Artificial Intelligence Theoretical Research of Deep Learning. Bioinformatics Analysis and integration of biological omics data with deep learning methods. Developing new bioinformatics tools. Metaverse Computer vision and VR Cognitive Neuroscience Mechanism of Language, Emotion, Memory, and Dream. Brain Computer Interface ","date":"0001-01-01","objectID":"/about/:0:2","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Projects and Publications Please check here ","date":"0001-01-01","objectID":"/about/:0:3","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Working Experience Student Ambassador, CEMSE, King Abdullah University of Science and Technology, Dec 2021 - Present ","date":"0001-01-01","objectID":"/about/:0:4","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Teaching Experience BioE 201/230, Fall 2022/2023, KAUST Cooperated with Prof. Xin Gao Position: Teaching Labs, TBD Contents: Lab 1. TBD Lab 2. TBD Lab 3. TBD CS398 Graduate Seminar, Spring 2022, KAUST Cooperated with Prof. Dominik Michels Position: Teaching Assistant ","date":"0001-01-01","objectID":"/about/:0:5","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Honours King Abdullah University of Science and Technology KAUST, 2021-Present PhD, Computer Science GPA: 4.00 / 4.00 CEMSE Dean’s List Award, 2022 Excellent Research Award, CEMSE, 2021 King Abdullah University of Science and Technology KAUST, 2020-2021 MS, Computer Science GPA: 3.95 / 4.00 Student ambassador, CEMSE, 2021 Yearly best studetnt award, CEMSE, 2021 Full scholarship for MS/PhD study, 2020 Southern University of Science and Technology SUSTech, 2016-2020 Bachelor, Bioinformatics, Biology GPA: 3.92 / 4.00 (Top 0.1%), Core GPA: 3.94/4.00 Outstanding graduate of SUSTech, 2020. Cum Laude Graduate of the Department of Biology (Top 1/10), 2020. The Guinness world record for “the most vows received by a single civilized act activity”, 2019 Candidate for 2019 National Scholarship, 2019 Summer social practice excellent experience Award, 2018 Excellent Student, The First Prize Scholarship, 2018 Outstanding volunteer for the 12th CBIS Biennial Meeting, Shenzhen, China, 2018 Candidate for 2018 National Scholarship, 2018 Outstanding Volunteer of the 3rd Shenzhen International Life Science \u0026 Health Industry Summit (2016) Excellent Student, The First Prize Scholarship, 2017 Dean scholarship, The First Prize Scholarship, 2017 Excellent Student Cadre, 2017 Outstanding Volunteer of 2017 Shenzhen International Precision Medicine Summit, 2017 Alma mater practice excellent team, 2017 National Literary Creation Award, 2016 Excellent Student, The Second Prize Scholarship, 2016 ","date":"0001-01-01","objectID":"/about/:0:6","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Membership Chinese Association for Artificial Intelligence (CAAI) Member ","date":"0001-01-01","objectID":"/about/:0:7","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Talks PPML-Omics: a Privacy-Preserving federated Machine Learning system protects patients’ privacy from omic data CBRC Dual Seminar, King Abdullah University of Science and Technology, Saudi Arabia, March 29, 2022 PPML-Omics: a Privacy-Preserving federated Machine Learning system protects patients’ privacy from omic data BDAI重点实验室研究生沙龙第19期, 中国人民大学高瓴人工智能学院，中国北京，March 9, 2022 ","date":"0001-01-01","objectID":"/about/:0:8","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Reviewer Journal/Conference # Paper Reviewed Genome Biology 1 Genome Research 2 IJCAI-ECAI 2022 1 ICONIP2020 1 ICMLA2021 1 Journal of Bioinformatics and Computational Biology 1 MICCAI2020 1 SIGKDD2022 2 ","date":"0001-01-01","objectID":"/about/:0:9","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Journal \u0026 Conference An Interpretable Deep Learning Workflow for Discovering Sub-Visual Abnormalities in CT Scans of COVID-19 Inpatients and Survivors. Longxi Zhou*, Xianglin Meng*, Yuxin Huang*, Kai Kang*, Juexiao Zhou, Yuetan Chu, Haoyang Li, Dexuan Xie, Jiannan Zhang, Weizhen Yang, Na Bai, Yi Zhao, Mingyan Zhao, Guohua Wang, Lawrence Carin, Xigang Xiao, Kaijiang Yu, Zhaowen Qiu, Xin Gao. Nature machine intelligence DOI: 10.1038/s42256-022-00483-7 Access: online, pdf An interpretable computer-aided diagnosis method for periodontitis from panoramic radiographs. Haoyang Li, Juexiao Zhou, Yi Zhou, Jieyu Chen, Feng Gao, Ying Xu, Xin Gao. Frontiers in Physiology, section Computational Physiology and Medicine DOI: 10.3389/fphys.2021.655556. Access: online, pdf Automatic and interpretable model for periodontitis diagnosis in panoramic radiographs. Haoyang Li, Juexiao Zhou, Yi Zhou, Jieyu Chen, Feng Gao, Ying Xu, Xin Gao. Medical Image Computing and Computer Assisted Interventions 2020. DOI: 10.1007/978-3-030-59713-9_44. Access: online, pdf DeeReCT-APA: Prediction of Alternative Polyadenylation Site Usage through Deep Learning. Zhongxiao Li, Yisheng Li, Bin Zhang, Yu Li, Yongkang Long, Juexiao Zhou, Xudong Zou, Min Zhang, Yuhui Hu, Wei Chen, Xin Gao. Genomics Proteomics and Bioinformatics. DOI: 10.1016/j.gpb.2020.05.004. Access: online, pdf A Rapid, Accurate and Machine-agnostic Segmentation and Quantification Method for CT-based COVID-19 Diagnosis. Liongxi Zhou, Zhongxiao Li, Juexiao Zhou, Haoyang Li, Yupeng Chen, Yuxin Huang, Dexuan Xie, Lintao Zhao, Ming Fan, Shahrukh Hashmi, Faisal AbdelKareem, Riham Eiada, Xigang Xiao, Lihua Li, Zhaowen Qiu, and Xin Gao. Transactions on Medical Imaging, 2020. DOI: 10.1109/TMI.2020.3001810. Access: online, pdf CaMeRe: A novel tool for inference of cancer metabolic reprogramming. Haoyang Li, Juexiao Zhou, Huiyan Sun, Zhaowen Qiu, Xin Gao and Ying Xu. Front. Oncol., 2020. DOI: 10.3389/fonc.2020.00207. Access: online, pdf Pan-tissue analysis of allelic alternative polyadenylation suggests widespread functional regulation. Yisheng Li*, Bernhard Schaefke*, Xudong Zou, Min Zhang, Florian Heyd, Wei Sun, Bin Zhang, Guipeng Li, Weizheng Liang, Yuhao He, Juexiao Zhou, Yunfei Li, Liang Fang, Yuhui Hu. Molecular Systems Biology, 2020. DOI: 10.15252/msb.20199367. Access: online, pdf Deetal-Perio: DEEp denTAL Advisor for Periodontitis Diagnosis based on Two-step Segmentation of Teeth and Gingiva with Lower-dimensional Features. Haoyang Li, Juexiao Zhou, Xin Gao. Poster. DigitalHealth, KAUST, 2020. Access: online CaMeRe: A novel tool for inference of cancer metabolic reprogramming. Haoyang Li, Juexiao Zhou, Huiyan Sun, Zhaowen Qiu, Xin Gao and Ying Xu. Poster. Advance In Artificial Intelligence, KAUST, 2019. DeeRect-PAS—A Deep-Learning based method for Transcriptome-wide PAS Identification. Yongkang Long, Juexiao Zhou, Zhongxiao Li, Wei Chen, Xin Gao. Poster. Advance In Artificial Intelligence, KAUST, 2019. Systematical discovery of cis-elements regulating alternative polyadenylation in mammalian cells. Min Zhang, Yisheng Li, Juexiao Zhou, Yuhao He, Guipeng Li, Liang Fang, Wei Chen. Poster. RNA Biology, CSH Asia, 2019. Systematical discovery of cis-elements regulating alternative polyadenylation in mammalian cells. Min Zhang, Yisheng Li, Juexiao Zhou, Yuhao He, Guipeng Li, Liang Fang, Wei Chen. Poster. Regulatory RNAs, Cell Symposia, Berlin, Germany, May 12-14, 2019. ","date":"0001-01-01","objectID":"/publications/:1:0","tags":null,"title":"","uri":"/publications/"},{"categories":null,"content":"Preprint or under review Application of Deep Learning in Understanding Gene Expression Regulation Zhongxiao Li, Elva Gao, Juexiao Zhou, Wenkai Han, Xiaopeng Xu, and Xin Gao under review. Antibody library design with transformer and deep reinforcement learning Xiaopeng Xu, Tiantian Xu, Juexiao Zhou, Xingyu Liao, Lu Zhang and Xin Gao under review. PPML-Omics: a Privacy-Preserving federated Machine Learning system protects patients’ privacy from omic data Juexiao Zhou*, Siyuan Chen*, Yulian Wu*, Haoyang Li, Bin Zhang, Longxi Zhou, Yan Hu, Zihang Xiang, Zhongxiao Li, Ningning Chen, Wenkai Han, Di Wang and Xin Gao. under review. DeeReCT-TSS: A novel meta-learning-based method annotates TSS in multiple cell types based on DNA sequences and RNA-seq data. Juexiao Zhou*, Bin Zhang*, Haoyang Li, Longxi Zhou, Zhongxiao Li, Yongkang Long, Wenkai Han, Mengran Wang, Huanhuan Cui, Wei Chen, Xin Gao. under review. A Workflow for Automatic, Accurate and Robust Breast Tumor Segmentation on Multi-Database DCE-MRI. Longxi Zhou, Yitong Ding, Jiayang Guo, Ming Fan, Juexiao Zhou, Haoyang Li, Yujiao Li, Yuxin Huang, Yi Zhao, Yuetan Chu, Kun Wang, Qiming Fang, Xin Gao, Hongxia Zhang, Lihua Li. under review. SD2: Spatially resolved transcriptomics deconvolution through integration of spatial and dropout information. Haoyang Li, Hanmin Li, Juexiao Zhou and Xin Gao. under review. Accurate transcriptome-wide identification and quantification of alternative polyadenylation from RNA-seq data with APAIQ. Yongkang Long*, Bin Zhang*, Shuye Tian, Jiajia Chan, Juexiao Zhou, Zhongxiao Li, Yisheng Li, Zheng An, Xingyu Liao, Yu Wang, Shiwei Sun, Ying Xu, Yvonne Tay, Wei Chen, Xin Gao under review. ","date":"0001-01-01","objectID":"/publications/:2:0","tags":null,"title":"","uri":"/publications/"}]