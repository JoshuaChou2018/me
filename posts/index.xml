<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - Juexiao Zhou 周觉晓</title>
        <link>https://www.joshuachou.ink/posts/</link>
        <description>All Posts | Juexiao Zhou 周觉晓</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 07 Mar 2023 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://www.joshuachou.ink/posts/" rel="self" type="application/rss+xml" /><item>
    <title>ubuntu18.04安装后的登陆问题、卡顿问题及基本环境配置</title>
    <link>https://www.joshuachou.ink/ubuntu18.04%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E7%99%BB%E9%99%86%E9%97%AE%E9%A2%98%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98%E5%8F%8A%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
    <pubDate>Tue, 07 Mar 2023 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/ubuntu18.04%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E7%99%BB%E9%99%86%E9%97%AE%E9%A2%98%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98%E5%8F%8A%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
    <description><![CDATA[参考 https://blog.csdn.net/weixin_51524504/article/details/119487457]]></description>
</item><item>
    <title>macOS上使用Openconnect代替Cisco Anyconnect</title>
    <link>https://www.joshuachou.ink/macos%E4%B8%8A%E4%BD%BF%E7%94%A8openconnect%E4%BB%A3%E6%9B%BFcisco-anyconnect/</link>
    <pubDate>Tue, 03 Jan 2023 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/macos%E4%B8%8A%E4%BD%BF%E7%94%A8openconnect%E4%BB%A3%E6%9B%BFcisco-anyconnect/</guid>
    <description><![CDATA[今天Cisco Anyconnect莫名奇妙用不了，重新安装却提示安装器错误，于是找到了Openconnect这个替代品
下面说下Openconnect安装方法：
命令行模式:
1 brew install openconnect GUI模式:
1 brew install openconnect-gui --cask 安装完之后, 发现GUI打不开, 提示来自不被信任的开发者, 这个时候需要我们开启权限允许所有来源的软件:
1 sudo spctl --master-disable ]]></description>
</item><item>
    <title>macos cmake-gui</title>
    <link>https://www.joshuachou.ink/macos-cmake-gui/</link>
    <pubDate>Fri, 30 Dec 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/macos-cmake-gui/</guid>
    <description><![CDATA[之前使用命令行安装：
1 brew install cmake 安装的是最新版，安装速度也很快，但是这个cmake是不带 GUI的，用着不习惯，就又一个命令行给卸载了。
1 brew uninstall cmake 然后手动安装cmake，去官网下载。
网址：https://cmake.org/download/
下载框线这个，可能因为时间段问题，晚上下载只有几kb/s，然后就放弃了，早上下载几MB/s。
下载完成后直接双击安装。双击会出现这个界面，直接将cmake图标拖到右边Application文件夹中，这样就可以在launcher中找到cmake了。
这个样可以从laucher中找到cmake并使用，但是命令行还是查不到cmake,也不能使用cmake。
安装完成之后，使用以下指令创建/usr/local/bin下 CMake 的软链接。
1 sudo &#34;/Applications/CMake.app/Contents/bin/cmake-gui&#34; --install 查看版本：
1 cmake --version Ref: https://www.cnblogs.com/juluwangshier/p/12987258.html]]></description>
</item><item>
    <title>pycharm增加运行时内存</title>
    <link>https://www.joshuachou.ink/pycharm%E5%A2%9E%E5%8A%A0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/</link>
    <pubDate>Wed, 21 Dec 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/pycharm%E5%A2%9E%E5%8A%A0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/</guid>
    <description><![CDATA[1，Help -&gt; Find Action -&gt; (输入 “VM”) -&gt; (点击)“Edit Custom VM options”
2，Pycharm会在编辑器中打开适当的vmoptions文件（pycharm.vmoptions或pycharm64.options）。
3，将**-Xms**属性的值修改为你想要的结果，然后保存
1 -Xmx750m 增加到 -Xmx1024m 4，重启Pycharm]]></description>
</item><item>
    <title>python安装blender包bpy</title>
    <link>https://www.joshuachou.ink/blender-python/</link>
    <pubDate>Thu, 06 Oct 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/blender-python/</guid>
    <description><![CDATA[ 1 2 3 conda create -n p37 python==3.7 wget https://github.com/TylerGubala/blenderpy/releases/download/v2.91a0/bpy-2.91a0-cp37-cp37m-manylinux2014_x86_64.whl pip install bpy-2.91a0-cp37-cp37m-manylinux2014_x86_64.whl &amp;&amp; bpy_post_install ]]></description>
</item><item>
    <title>jupyter in pycharm</title>
    <link>https://www.joshuachou.ink/pycharm-jupyter/</link>
    <pubDate>Mon, 03 Oct 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/pycharm-jupyter/</guid>
    <description><![CDATA[When setting jupyter interpreter in pycharm, it may throw the error:
1 jupyter URL is invalid Solution:
Even without a token, use the url: http://url:port?token=
Then it works]]></description>
</item><item>
    <title>[转载] 谷歌开源计算框架JAX”</title>
    <link>https://www.joshuachou.ink/%E8%BD%AC%E8%BD%BD-%E8%B0%B7%E6%AD%8C%E5%BC%80%E6%BA%90%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6jax/</link>
    <pubDate>Thu, 29 Sep 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/%E8%BD%AC%E8%BD%BD-%E8%B0%B7%E6%AD%8C%E5%BC%80%E6%BA%90%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6jax/</guid>
    <description><![CDATA[相信大家对numpy, Tensorflow, Pytorch已经极其熟悉，不过，你知道JAX吗？ JAX发布之后，有网友进行了测试，发现，使用JAX，Numpy运算可以快三十多倍！
下面是使用Numpy的运行情况：
1 2 3 import numpy as np # 使用标准numpy，运算将在CPU上执行。 x = np.random.random([5000, 5000]).astype(np.float32) %timeit np.matmul(x, x) 运行结果：
1 2 1 loop, best of 3: 3.9 s per loop 而下面是使用JAX的Numpy的情况： import jax.numpy as np # 使用&#34;JAX版&#34;的numpy from jax import random # 注意JAX下随机数API有所不同 x = random.uniform(random.PRNGKey(0), [5000, 5000]) %timeit np.matmul(x, x) 运行情况：
1 1 loop, best of 3: 109 ms per loop 我们可以发现，使用原始numpy，运行时间大概为3.9s，而使用JAX的numpy，运行时间仅仅只有0.109s，速度上直接提升了三十多倍！
是不是很神奇？ 那JAX到底是什么？
JAX是谷歌开源的、可以在CPU、GPU和TPU上运行的numpy，是针对机器学习研究的高性能自微分计算框架。]]></description>
</item><item>
    <title>[转载] 同态加密：实现数据的“可算不可见”</title>
    <link>https://www.joshuachou.ink/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/</link>
    <pubDate>Tue, 20 Sep 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/%E8%BD%AC%E8%BD%BD-%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E7%AE%97%E4%B8%8D%E5%8F%AF%E8%A7%81/</guid>
    <description><![CDATA[同态加密是密码学领域自1978年以来的经典难题，也是实现数据隐私计算的关键技术，在云计算、区块链、隐私计算等领域均存在着广泛的应用需求和一些可行的应用方案。
本文首先介绍同态加密的基本概念、研究进展以及标准化进展，然后对主流的乘法/加法半同态加密算法和全同态加密算法及其工程实现情况进行概述，最后对同态加密在各领域的应用场景进行分析。
一、同态加密概述 1、基本概念 同态加密（Homomorphic Encryption, HE）是指满足密文同态运算性质的加密算法，即数据经过同态加密之后，对密文进行特定的计算，得到的密文计算结果在进行对应的同态解密后的明文等同于对明文数据直接进行相同的计算，实现数据的“可算不可见”。同态加密的实现效果如图1所示。
图1：同态加密原理
如果一种同态加密算法支持对密文进行任意形式的计算，则称其为全同态加密（Fully Homomorphic Encryption, FHE）；如果支持对密文进行部分形式的计算，例如仅支持加法、仅支持乘法或支持有限次加法和乘法，则称其为半同态加密或部分同态加密，英文简称为SWHE（Somewhat Homomorphic Encryption）或PHE（Partially Homomorphic Encryption）。一般而言，由于任意计算均可通过加法和乘法构造，若加密算法同时满足加法同态性和乘法同态性，则可称其满足全同态性。
目前，同态加密算法已在区块链、联邦学习等存在数据隐私计算需求的场景实现了落地应用。由于全同态加密仍处于方案探索阶段，现有算法存在运行效率低、密钥过大和密文爆炸等性能问题，在性能方面距离可行工程应用还存在一定的距离。因此，实际应用中的同态加密算法多选取半同态加密（如加法同态），用于在特定应用场景中实现有限的同态计算功能。
2、研究进展 1978年，Rivest、Adleman（“RSA”中的“R”和“A”）和Dertouzos提出了全同态加密的构想[1]，自此成为了密码学研究领域的一个公开难题。目前，同态加密算法主要分为半同态加密和全同态加密两大类。半同态加密主要包括以RSA算法[2]和ElGamal算法[3]为代表的乘法同态加密、以Paillier算法[4]为代表的加法同态加密以及以Boneh-Goh-Nissim方案[5]为代表的有限次数全同态加密；全同态加密算法主要包括以Gentry方案[6][7]为代表的第一代方案、以BGV方案[8]和BFV方案[9][10]为代表的第二代方案、以GSW方案[11]为代表的第三代方案以及支持浮点数近似计算的CKKS方案[12]等等。上述方案及其基本特性和应用情况总览如表1所示。
表1：各类同态加密算法
*类型* *算法* *时间* *说明* *实际应用* 半同态加密 乘法同态 RSA算法 1977 非随机化加密，具有乘法同态性的原始算法面临选择明文攻击 在非同态场景中应用广泛 ElGamal算法 1985 随机化加密 DSS数字签名标准基于ElGamal数字签名算法的变体 加法同态 Paillier算法 1999 应用最为成熟 联邦学习 有限次数全同态 Boneh-Goh-Nissim方案 2005 仅支持1次乘法同态运算 / 全同态加密 Gentry方案 2009 第一代全同态加密，性能较差 / BGV方案 2012 第二代全同态加密，性能相对较好 IBM HElib开源库 BFV方案 2012 第二代全同态加密，与BGV类似 微软SEAL开源库 GSW方案 2013 第三代全同态加密，基于近似特征向量 TFHE开源库 CKKS方案 2017 可实现浮点数近似计算，适合机器学习建模场景 HElib和SEAL 3、标准化进展 （1）半同态加密标准化]]></description>
</item><item>
    <title>Homomorphic Encryption</title>
    <link>https://www.joshuachou.ink/homomorphic-encryption/</link>
    <pubDate>Tue, 20 Sep 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/homomorphic-encryption/</guid>
    <description><![CDATA[Outsourcing computation, privately Homomorphic evaluation function:
Eval: f, Enc(x) -&gt; Enc(f(x))
Fully homomorphic encryption Fully homomorphic = correctness for any efficient f = correctness for universal set
Approximate eigenvector method 基于GSW13的特征向量的构造，我们可以在ciphertext上计算加法和乘法，然后可以通过secret key恢复出message的计算结果。但是这个方法不安全，因为特征向量很容易被找到。
**idea：**使用approximate eigenvectors，在secret key右乘cipher text
Learning with errors (LWE) R05 Rearranging notation **basic idea: ** we have a matrix A, we can generate a matrix s, such that sA=$\eta$
Encryption scheme from LWE Encryption Decryption it can be generalized to matrices.]]></description>
</item><item>
    <title>SEAL</title>
    <link>https://www.joshuachou.ink/ms-seal/</link>
    <pubDate>Mon, 19 Sep 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/ms-seal/</guid>
    <description><![CDATA[Microsoft SEAL Ref https://www.youtube.com/watch?v=XaYEHnaAg8M]]></description>
</item><item>
    <title>CKKS</title>
    <link>https://www.joshuachou.ink/ckks/</link>
    <pubDate>Sun, 18 Sep 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/ckks/</guid>
    <description><![CDATA[What’s is CKKS Plain Computation Encrypted Computation bool, int (uint 64), modulo p BGV, BFV, TFHE double (float) CKKS Approximate arithmetic For floating-point arithmetic, we keep the bits of significand to be the same.
For fixed-point arithmetic, we keep the scaling factor to be the same.
Algorithms in CKKS Encoding and decoding 在编码过程中需要使用比较大的scaling factor，这样可以保证更大的精度。
Encrypt and decrypt Ref https://www.youtube.com/watch?v=iQlgeL64vfo]]></description>
</item><item>
    <title>Homomorphic Encryption for Arithmetic of Approximate Numbers</title>
    <link>https://www.joshuachou.ink/homomorphic-encryption-for-arithmetic-of-approximate-numbers/</link>
    <pubDate>Sun, 18 Sep 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/homomorphic-encryption-for-arithmetic-of-approximate-numbers/</guid>
    <description><![CDATA[]]></description>
</item><item>
    <title>Run Ubuntu Linux in Docker with Desktop Environment and VNC</title>
    <link>https://www.joshuachou.ink/run-ubuntu-in-docker/</link>
    <pubDate>Sun, 21 Aug 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/run-ubuntu-in-docker/</guid>
    <description><![CDATA[Run Ubuntu Linux in Docker with Desktop Environment and VNC Step 1 – Install Docker on your System 1 sudo systemctl start docker &amp;&amp; sudo systemctl enable docker Add your system user to the Docker group to be able to execute Docker commands without *sudo*.
1 2 sudo usermod -aG docker $USER newgrp docker Verify the installed Docker version.
1 2 3 4 5 6 7 8 9 10 11 $ docker version Client: Docker Engine - Community Version: 20.]]></description>
</item><item>
    <title>Fully homomorphic encryption (FHE)</title>
    <link>https://www.joshuachou.ink/fhe/</link>
    <pubDate>Wed, 10 Aug 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/fhe/</guid>
    <description><![CDATA[全同态加密 Fully homomorphic encryption (FHE) What’s is FHE 第一种形式：同时使用secret key加密和解密，public key用于第三方加密进行同态计算
第二种形式：asymmetric FHE，只使用public key进行加密，secret key用于解密
Efficient FHE is a giant leap towards httpz://
? what’s httpz?
History Major task: find a new scheme to combine both addition and multiplication together.
1. First generation Plain text: single bit
这个方法的主要问题是noise，随着计算的叠加，there is a notion of noise in ciphertexts，noise accumulates
Defining noise budget thourgh defining parameters
noise growth is exponential
bootstrapping to rescure (decrease the noise)]]></description>
</item><item>
    <title>libc10_cuda.so error for installing pyG</title>
    <link>https://www.joshuachou.ink/libc10_cuda.so-error-for-installing-pyg/</link>
    <pubDate>Sat, 06 Aug 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/libc10_cuda.so-error-for-installing-pyg/</guid>
    <description><![CDATA[After installing PyG, here is the error:
libc10_cuda.so: cannot open shared object file: No such file or directory
Solution
1 2 conda install pytorch==1.11.0 cudatoolkit=11.3 -c pytorch conda install pyg -c pyg ]]></description>
</item><item>
    <title>linux删除百万级别文件</title>
    <link>https://www.joshuachou.ink/linux%E5%88%A0%E9%99%A4%E7%99%BE%E4%B8%87%E7%BA%A7%E5%88%AB%E6%96%87%E4%BB%B6/</link>
    <pubDate>Fri, 05 Aug 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/linux%E5%88%A0%E9%99%A4%E7%99%BE%E4%B8%87%E7%BA%A7%E5%88%AB%E6%96%87%E4%BB%B6/</guid>
    <description><![CDATA[在运行任务时，往linux的同一个文件夹中写入超过500万个文件，导致在硬盘还有空间的情况下，在该文件夹下无法继续写入文件，也无法使用ls、rm等命令。记录处理过程。
Background: physical server, about two years old, 7200-RPM SATA drives connected to a 3Ware RAID card, ext3 FS mounted noatime and data=ordered, not under crazy load, kernel 2.6.18-92.1.22.el5, uptime 545 days. Directory doesn&rsquo;t contain any subdirectories, just millions of small (~100 byte) files, with some larger (a few KB) ones.
We have a server that has gone a bit cuckoo over the course of the last few months, but we only noticed it the other day when it started being unable to write to a directory due to it containing too many files.]]></description>
</item><item>
    <title>Automatically Sort Data in Google Sheets</title>
    <link>https://www.joshuachou.ink/googlesheetautomaticsort/</link>
    <pubDate>Fri, 01 Jul 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/googlesheetautomaticsort/</guid>
    <description><![CDATA[Automatically Sort Data in Google Sheets
Extension -&gt; Apps script
1 2 3 4 5 6 7 8 9 10 function autoSort(e) { const ss = SpreadsheetApp.getActiveSpreadsheet() const ws = ss.getSheetByName(&#34;Sheet1&#34;) const range = ws.getRange(2,1,ws.getLastRow()-1,2) range.sort({column: 2, ascending: false}) } function onEdit(e){ autoSort(e) } ]]></description>
</item><item>
    <title>Check SWAP</title>
    <link>https://www.joshuachou.ink/check-swap/</link>
    <pubDate>Thu, 09 Jun 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/check-swap/</guid>
    <description><![CDATA[ Check SWAP used by differnt PID 1 for i in $(cd /proc;ls | grep &#34;^[0-9]&#34; | awk &#39;$0&gt;100&#39;); do awk &#39;/Swap:/{a=a+$2}END{print &#39;&#34;$i&#34;&#39;,a/1024&#34;M&#34;}&#39; /proc/$i/smaps;done| sort -k2nr | head Get the information about the PID 1 ps aux | grep ${pid} ]]></description>
</item><item>
    <title>xcode-select</title>
    <link>https://www.joshuachou.ink/xcode-select/</link>
    <pubDate>Thu, 09 Jun 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/xcode-select/</guid>
    <description><![CDATA[显示“未能找到金属编译器安装的Xcode。请安装Xcode并运行Xcode.app来接受协议，或确保激活的开发者目录设为当前的Xcode安装（使用xcode-select）
解决方案：
1 sudo xcode-select -s /Applications/Xcode.app/Contents/Developer ]]></description>
</item><item>
    <title>lc1570. Dot Product of Two Sparse Vectors</title>
    <link>https://www.joshuachou.ink/lc1570.-dot-product-of-two-sparse-vectors/</link>
    <pubDate>Tue, 01 Mar 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc1570.-dot-product-of-two-sparse-vectors/</guid>
    <description><![CDATA[给定两个稀疏向量，计算它们的点积（数量积）。
实现类 SparseVector：
SparseVector(nums) 以向量 nums 初始化对象。 dotProduct(vec) 计算此向量与 vec 的点积。 稀疏向量 是指绝大多数分量为 0 的向量。你需要 高效 地存储这个向量，并计算两个稀疏向量的点积。
进阶：当其中只有一个向量是稀疏向量时，你该如何解决此问题？
示例 1：
输入：nums1 = [1,0,0,2,3], nums2 = [0,3,0,4,0]
输出：8
解释：v1 = SparseVector(nums1) , v2 = SparseVector(nums2)
v1.dotProduct(v2) = 10 + 03 + 00 + 24 + 3*0 = 8
示例 2：
输入：nums1 = [0,1,0,0,0], nums2 = [0,0,0,0,2]
输出：0
解释：v1 = SparseVector(nums1) , v2 = SparseVector(nums2)
v1.dotProduct(v2) = 00 + 10 + 00 + 00 + 0*2 = 0]]></description>
</item></channel>
</rss>
