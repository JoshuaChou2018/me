<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - Juexiao Zhou</title>
        <link>https://www.joshuachou.ink/posts/</link>
        <description>All Posts | Juexiao Zhou</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 19 Sep 2022 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://www.joshuachou.ink/posts/" rel="self" type="application/rss+xml" /><item>
    <title>SEAL</title>
    <link>https://www.joshuachou.ink/ms-seal/</link>
    <pubDate>Mon, 19 Sep 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/ms-seal/</guid>
    <description><![CDATA[Microsoft SEAL Ref https://www.youtube.com/watch?v=XaYEHnaAg8M]]></description>
</item><item>
    <title>CKKS</title>
    <link>https://www.joshuachou.ink/ckks/</link>
    <pubDate>Sun, 18 Sep 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/ckks/</guid>
    <description><![CDATA[What’s is CKKS Plain Computation Encrypted Computation bool, int (uint 64), modulo p BGV, BFV, TFHE double (float) CKKS Approximate arithmetic For floating-point arithmetic, we keep the bits of significand to be the same.
For fixed-point arithmetic, we keep the scaling factor to be the same.
Algorithms in CKKS Encoding and decoding 在编码过程中需要使用比较大的scaling factor，这样可以保证更大的精度。
Encrypt and decrypt Ref https://www.youtube.com/watch?v=iQlgeL64vfo]]></description>
</item><item>
    <title>Homomorphic Encryption for Arithmetic of Approximate Numbers</title>
    <link>https://www.joshuachou.ink/homomorphic-encryption-for-arithmetic-of-approximate-numbers/</link>
    <pubDate>Sun, 18 Sep 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/homomorphic-encryption-for-arithmetic-of-approximate-numbers/</guid>
    <description><![CDATA[]]></description>
</item><item>
    <title>Run Ubuntu Linux in Docker with Desktop Environment and VNC</title>
    <link>https://www.joshuachou.ink/run-ubuntu-in-docker/</link>
    <pubDate>Sun, 21 Aug 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/run-ubuntu-in-docker/</guid>
    <description><![CDATA[Run Ubuntu Linux in Docker with Desktop Environment and VNC Step 1 – Install Docker on your System 1 sudo systemctl start docker &amp;&amp; sudo systemctl enable docker Add your system user to the Docker group to be able to execute Docker commands without *sudo*.
1 2 sudo usermod -aG docker $USER newgrp docker Verify the installed Docker version.
1 2 3 4 5 6 7 8 9 10 11 $ docker version Client: Docker Engine - Community Version: 20.]]></description>
</item><item>
    <title>Fully homomorphic encryption (FHE)</title>
    <link>https://www.joshuachou.ink/fhe/</link>
    <pubDate>Wed, 10 Aug 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/fhe/</guid>
    <description><![CDATA[全同态加密 Fully homomorphic encryption (FHE) What’s is FHE 第一种形式：同时使用secret key加密和解密，public key用于第三方加密进行同态计算
第二种形式：asymmetric FHE，只使用public key进行加密，secret key用于解密
Efficient FHE is a giant leap towards httpz://
? what’s httpz?
History Major task: find a new scheme to combine both addition and multiplication together.
1. First generation Plain text: single bit
这个方法的主要问题是noise，随着计算的叠加，there is a notion of noise in ciphertexts，noise accumulates
Defining noise budget thourgh defining parameters
noise growth is exponential
bootstrapping to rescure (decrease the noise)]]></description>
</item><item>
    <title>libc10_cuda.so error for installing pyG</title>
    <link>https://www.joshuachou.ink/libc10_cuda.so-error-for-installing-pyg/</link>
    <pubDate>Sat, 06 Aug 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/libc10_cuda.so-error-for-installing-pyg/</guid>
    <description><![CDATA[After installing PyG, here is the error:
libc10_cuda.so: cannot open shared object file: No such file or directory
Solution
1 2 conda install pytorch==1.11.0 cudatoolkit=11.3 -c pytorch conda install pyg -c pyg ]]></description>
</item><item>
    <title>linux删除百万级别文件</title>
    <link>https://www.joshuachou.ink/linux%E5%88%A0%E9%99%A4%E7%99%BE%E4%B8%87%E7%BA%A7%E5%88%AB%E6%96%87%E4%BB%B6/</link>
    <pubDate>Fri, 05 Aug 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/linux%E5%88%A0%E9%99%A4%E7%99%BE%E4%B8%87%E7%BA%A7%E5%88%AB%E6%96%87%E4%BB%B6/</guid>
    <description><![CDATA[在运行任务时，往linux的同一个文件夹中写入超过500万个文件，导致在硬盘还有空间的情况下，在该文件夹下无法继续写入文件，也无法使用ls、rm等命令。记录处理过程。
Background: physical server, about two years old, 7200-RPM SATA drives connected to a 3Ware RAID card, ext3 FS mounted noatime and data=ordered, not under crazy load, kernel 2.6.18-92.1.22.el5, uptime 545 days. Directory doesn&rsquo;t contain any subdirectories, just millions of small (~100 byte) files, with some larger (a few KB) ones.
We have a server that has gone a bit cuckoo over the course of the last few months, but we only noticed it the other day when it started being unable to write to a directory due to it containing too many files.]]></description>
</item><item>
    <title>Automatically Sort Data in Google Sheets</title>
    <link>https://www.joshuachou.ink/googlesheetautomaticsort/</link>
    <pubDate>Fri, 01 Jul 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/googlesheetautomaticsort/</guid>
    <description><![CDATA[Automatically Sort Data in Google Sheets
Extension -&gt; Apps script
1 2 3 4 5 6 7 8 9 10 function autoSort(e) { const ss = SpreadsheetApp.getActiveSpreadsheet() const ws = ss.getSheetByName(&#34;Sheet1&#34;) const range = ws.getRange(2,1,ws.getLastRow()-1,2) range.sort({column: 2, ascending: false}) } function onEdit(e){ autoSort(e) } ]]></description>
</item><item>
    <title>Check SWAP</title>
    <link>https://www.joshuachou.ink/check-swap/</link>
    <pubDate>Thu, 09 Jun 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/check-swap/</guid>
    <description><![CDATA[ Check SWAP used by differnt PID 1 for i in $(cd /proc;ls | grep &#34;^[0-9]&#34; | awk &#39;$0&gt;100&#39;); do awk &#39;/Swap:/{a=a+$2}END{print &#39;&#34;$i&#34;&#39;,a/1024&#34;M&#34;}&#39; /proc/$i/smaps;done| sort -k2nr | head Get the information about the PID 1 ps aux | grep ${pid} ]]></description>
</item><item>
    <title>xcode-select</title>
    <link>https://www.joshuachou.ink/xcode-select/</link>
    <pubDate>Thu, 09 Jun 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/xcode-select/</guid>
    <description><![CDATA[显示“未能找到金属编译器安装的Xcode。请安装Xcode并运行Xcode.app来接受协议，或确保激活的开发者目录设为当前的Xcode安装（使用xcode-select）
解决方案：
1 sudo xcode-select -s /Applications/Xcode.app/Contents/Developer ]]></description>
</item><item>
    <title>lc1570. Dot Product of Two Sparse Vectors</title>
    <link>https://www.joshuachou.ink/lc1570.-dot-product-of-two-sparse-vectors/</link>
    <pubDate>Tue, 01 Mar 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc1570.-dot-product-of-two-sparse-vectors/</guid>
    <description><![CDATA[给定两个稀疏向量，计算它们的点积（数量积）。
实现类 SparseVector：
SparseVector(nums) 以向量 nums 初始化对象。 dotProduct(vec) 计算此向量与 vec 的点积。 稀疏向量 是指绝大多数分量为 0 的向量。你需要 高效 地存储这个向量，并计算两个稀疏向量的点积。
进阶：当其中只有一个向量是稀疏向量时，你该如何解决此问题？
示例 1：
输入：nums1 = [1,0,0,2,3], nums2 = [0,3,0,4,0]
输出：8
解释：v1 = SparseVector(nums1) , v2 = SparseVector(nums2)
v1.dotProduct(v2) = 10 + 03 + 00 + 24 + 3*0 = 8
示例 2：
输入：nums1 = [0,1,0,0,0], nums2 = [0,0,0,0,2]
输出：0
解释：v1 = SparseVector(nums1) , v2 = SparseVector(nums2)
v1.dotProduct(v2) = 00 + 10 + 00 + 00 + 0*2 = 0]]></description>
</item><item>
    <title>lc50. Pow(x, n)</title>
    <link>https://www.joshuachou.ink/lc50.-powx-n/</link>
    <pubDate>Tue, 01 Mar 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc50.-powx-n/</guid>
    <description><![CDATA[Implement pow(x, n), which calculates x raised to the power n (i.e., xn).
Example 1:
1 2 Input: x = 2.00000, n = 10 Output: 1024.00000 Example 2:
1 2 Input: x = 2.10000, n = 3 Output: 9.26100 Example 3:
1 2 3 Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Constraints:
-100.0 &lt; x &lt; 100.0 -231 &lt;= n &lt;= 231-1 -104 &lt;= xn &lt;= 104 思路 ]]></description>
</item><item>
    <title>lc76. Minimum Window Substring</title>
    <link>https://www.joshuachou.ink/lc76.-minimum-window-substring/</link>
    <pubDate>Tue, 01 Mar 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc76.-minimum-window-substring/</guid>
    <description><![CDATA[Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string &quot;&quot;.
The testcases will be generated such that the answer is unique.
A substring is a contiguous sequence of characters within the string.
Example 1:
1 2 3 Input: s = &#34;ADOBECODEBANC&#34;, t = &#34;ABC&#34; Output: &#34;BANC&#34; Explanation: The minimum window substring &#34;BANC&#34; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.]]></description>
</item><item>
    <title>lc88. Merge Sorted Array</title>
    <link>https://www.joshuachou.ink/lc88.-merge-sorted-array/</link>
    <pubDate>Tue, 01 Mar 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc88.-merge-sorted-array/</guid>
    <description><![CDATA[You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored.]]></description>
</item><item>
    <title>lc621. Task Scheduler</title>
    <link>https://www.joshuachou.ink/lc621.-task-scheduler/</link>
    <pubDate>Wed, 16 Feb 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc621.-task-scheduler/</guid>
    <description><![CDATA[Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.
However, there is a non-negative integer n that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least n units of time between any two same tasks.]]></description>
</item><item>
    <title>lc15. 3Sum</title>
    <link>https://www.joshuachou.ink/lc15.-3sum/</link>
    <pubDate>Mon, 14 Feb 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc15.-3sum/</guid>
    <description><![CDATA[Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
Example 1:
1 2 Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Example 2:
1 2 Input: nums = [] Output: [] Example 3:
1 2 Input: nums = [0] Output: [] Constraints:]]></description>
</item><item>
    <title>lc297. Serialize and Deserialize Binary Tree</title>
    <link>https://www.joshuachou.ink/lc297.-serialize-and-deserialize-binary-tree/</link>
    <pubDate>Mon, 14 Feb 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc297.-serialize-and-deserialize-binary-tree/</guid>
    <description><![CDATA[Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.]]></description>
</item><item>
    <title>lc314. Binary Tree Vertical Order Traversal</title>
    <link>https://www.joshuachou.ink/lc314.binary-tree-vertical-order-traversal/</link>
    <pubDate>Tue, 08 Feb 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/lc314.binary-tree-vertical-order-traversal/</guid>
    <description><![CDATA[Given the root of a binary tree, return the vertical order traversal of its nodes&rsquo; values. (i.e., from top to bottom, column by column).
If two nodes are in the same row and column, the order should be from left to right.
Example 1:
1 2 Input: root = [3,9,20,null,null,15,7] Output: [[9],[3,15],[20],[7]] Example 2:
1 2 Input: root = [3,9,8,4,0,1,7] Output: [[4],[9],[3,0,1],[8],[7]] Example 3:
1 2 Input: root = [3,9,8,4,0,1,7,null,null,null,2,5] Output: [[4],[9,5],[3,0,1],[8,2],[7]] Constraints:]]></description>
</item><item>
    <title>[NeurIPS] Personalized Federated Learning: A Meta-Learning Approach解读</title>
    <link>https://www.joshuachou.ink/neurips-personalized-federated-learning-a-meta-learning-approach/</link>
    <pubDate>Sat, 05 Feb 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/neurips-personalized-federated-learning-a-meta-learning-approach/</guid>
    <description><![CDATA[Title: Personalized Federated Learning: A Meta-Learning Approach
INFO: 34th Conference on Neural Information Processing Systems (NeurIPS 2020)
研究背景 目前的联邦学习框架是基于所有users的数据，整合训练出一个最优的server模型。
However, this scheme only develops a common output for all the users, and, therefore, it does not adapt the model to each user.
但是，这样训练处来的server模型不一定适用于每一个user，尤其在不同的users所独有的数据差异比较大的时候。
This is an important missing feature, especially given the heterogeneity of the underlying data distribution for various users.
在heterogeneous的情景下，使用federated averaging方法训练出来的模型可能在每个独立user上的表现会比较差。
In particular, in the heterogeneous settings where the underlying data distribution of users are not identical, the resulted global model obtained by minimizing the average loss could perform arbitrarily poorly once applied to the local dataset of each user.]]></description>
</item><item>
    <title>[IEEE] Personalized Federated Learning WithDifferential Privacy解读</title>
    <link>https://www.joshuachou.ink/ieee-personalized-federated-learning-with-differential-privacy/</link>
    <pubDate>Fri, 04 Feb 2022 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://www.joshuachou.ink/ieee-personalized-federated-learning-with-differential-privacy/</guid>
    <description><![CDATA[Title: Personalized Federated Learning With Differential Privacy
DOI: 10.1109/JIOT.2020.2991416
INFO: IEEE INTERNET OF THINGS JOURNAL, VOL. 7, NO. 10, OCTOBER 2020
发表周期: Manuscript received December 15, 2019; revised March 20, 2020; accepted April 13, 2020. Date of publication April 30, 2020;]]></description>
</item></channel>
</rss>
